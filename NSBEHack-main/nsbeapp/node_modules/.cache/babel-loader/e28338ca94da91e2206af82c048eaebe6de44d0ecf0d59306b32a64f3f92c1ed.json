{"ast":null,"code":"\"use strict\";\n\nconst AbstractConnectionManager = require(\"../abstract/connection-manager\");\nconst AsyncQueue = require(\"./async-queue\").default;\nconst {\n  logger\n} = require(\"../../utils/logger\");\nconst sequelizeErrors = require(\"../../errors\");\nconst DataTypes = require(\"../../data-types\").mssql;\nconst parserStore = require(\"../parserStore\")(\"mssql\");\nconst debug = logger.debugContext(\"connection:mssql\");\nconst debugTedious = logger.debugContext(\"connection:mssql:tedious\");\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 1433;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule(\"tedious\");\n    this.refreshTypeParser(DataTypes);\n  }\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n  async connect(config) {\n    const connectionConfig = {\n      server: config.host,\n      authentication: {\n        type: \"default\",\n        options: {\n          userName: config.username || void 0,\n          password: config.password || void 0\n        }\n      },\n      options: {\n        port: parseInt(config.port, 10),\n        database: config.database,\n        trustServerCertificate: true\n      }\n    };\n    if (config.dialectOptions) {\n      if (config.dialectOptions.options && config.dialectOptions.options.instanceName) {\n        delete connectionConfig.options.port;\n      }\n      if (config.dialectOptions.authentication) {\n        Object.assign(connectionConfig.authentication, config.dialectOptions.authentication);\n      }\n      Object.assign(connectionConfig.options, config.dialectOptions.options);\n    }\n    try {\n      return await new Promise((resolve, reject) => {\n        const connection = new this.lib.Connection(connectionConfig);\n        if (connection.state === connection.STATE.INITIALIZED) {\n          connection.connect();\n        }\n        connection.queue = new AsyncQueue();\n        connection.lib = this.lib;\n        const connectHandler = error => {\n          connection.removeListener(\"end\", endHandler);\n          connection.removeListener(\"error\", errorHandler);\n          if (error) return reject(error);\n          debug(\"connection acquired\");\n          resolve(connection);\n        };\n        const endHandler = () => {\n          connection.removeListener(\"connect\", connectHandler);\n          connection.removeListener(\"error\", errorHandler);\n          reject(new Error(\"Connection was closed by remote server\"));\n        };\n        const errorHandler = error => {\n          connection.removeListener(\"connect\", connectHandler);\n          connection.removeListener(\"end\", endHandler);\n          reject(error);\n        };\n        connection.once(\"error\", errorHandler);\n        connection.once(\"end\", endHandler);\n        connection.once(\"connect\", connectHandler);\n        connection.on(\"error\", error => {\n          switch (error.code) {\n            case \"ESOCKET\":\n            case \"ECONNRESET\":\n              this.pool.destroy(connection);\n          }\n        });\n        if (config.dialectOptions && config.dialectOptions.debug) {\n          connection.on(\"debug\", debugTedious.log.bind(debugTedious));\n        }\n      });\n    } catch (error) {\n      if (!error.code) {\n        throw new sequelizeErrors.ConnectionError(error);\n      }\n      switch (error.code) {\n        case \"ESOCKET\":\n          if (error.message.includes(\"connect EHOSTUNREACH\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes(\"connect ENETUNREACH\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes(\"connect EADDRNOTAVAIL\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes(\"connect EAFNOSUPPORT\")) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes(\"getaddrinfo ENOTFOUND\")) {\n            throw new sequelizeErrors.HostNotFoundError(error);\n          }\n          if (error.message.includes(\"connect ECONNREFUSED\")) {\n            throw new sequelizeErrors.ConnectionRefusedError(error);\n          }\n          throw new sequelizeErrors.ConnectionError(error);\n        case \"ER_ACCESS_DENIED_ERROR\":\n        case \"ELOGIN\":\n          throw new sequelizeErrors.AccessDeniedError(error);\n        case \"EINVAL\":\n          throw new sequelizeErrors.InvalidConnectionError(error);\n        default:\n          throw new sequelizeErrors.ConnectionError(error);\n      }\n    }\n  }\n  async disconnect(connection) {\n    if (connection.closed) {\n      return;\n    }\n    connection.queue.close();\n    return new Promise(resolve => {\n      connection.on(\"end\", resolve);\n      connection.close();\n      debug(\"connection closed\");\n    });\n  }\n  validate(connection) {\n    return connection && (connection.loggedIn || connection.state.name === \"LoggedIn\");\n  }\n}\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"mappings":"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","names":["AbstractConnectionManager","require","AsyncQueue","default","logger","sequelizeErrors","DataTypes","mssql","parserStore","debug","debugContext","debugTedious","constructor","dialect","sequelize","config","port","lib","_loadDialectModule","refreshTypeParser","_refreshTypeParser","dataType","refresh","_clearTypeParser","clear","connect","connectionConfig","server","host","authentication","type","options","userName","username","password","parseInt","database","trustServerCertificate","dialectOptions","instanceName","Object","assign","Promise","resolve","reject","connection","Connection","state","STATE","INITIALIZED","queue","connectHandler","error","removeListener","endHandler","errorHandler","Error","once","on","code","pool","destroy","log","bind","ConnectionError","message","includes","HostNotReachableError","HostNotFoundError","ConnectionRefusedError","AccessDeniedError","InvalidConnectionError","disconnect","closed","close","validate","loggedIn","name","module","exports","ConnectionManager"],"sources":["C:\\Users\\rizla\\projects\\react\\NSBEHack-main\\nsbeapp\\node_modules\\sequelize\\src\\dialects\\mssql\\connection-manager.js"],"sourcesContent":["'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst AsyncQueue = require('./async-queue').default;\nconst { logger } = require('../../utils/logger');\nconst sequelizeErrors = require('../../errors');\nconst DataTypes = require('../../data-types').mssql;\nconst parserStore = require('../parserStore')('mssql');\nconst debug = logger.debugContext('connection:mssql');\nconst debugTedious = logger.debugContext('connection:mssql:tedious');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 1433;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('tedious');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async connect(config) {\n    const connectionConfig = {\n      server: config.host,\n      authentication: {\n        type: 'default',\n        options: {\n          userName: config.username || undefined,\n          password: config.password || undefined\n        }\n      },\n      options: {\n        port: parseInt(config.port, 10),\n        database: config.database,\n        trustServerCertificate: true\n      }\n    };\n\n    if (config.dialectOptions) {\n      // only set port if no instance name was provided\n      if (\n        config.dialectOptions.options &&\n        config.dialectOptions.options.instanceName\n      ) {\n        delete connectionConfig.options.port;\n      }\n\n      if (config.dialectOptions.authentication) {\n        Object.assign(connectionConfig.authentication, config.dialectOptions.authentication);\n      }\n\n      Object.assign(connectionConfig.options, config.dialectOptions.options);\n    }\n\n    try {\n      return await new Promise((resolve, reject) => {\n        const connection = new this.lib.Connection(connectionConfig);\n        if (connection.state === connection.STATE.INITIALIZED) {\n          connection.connect();\n        }\n        connection.queue = new AsyncQueue();\n        connection.lib = this.lib;\n\n        const connectHandler = error => {\n          connection.removeListener('end', endHandler);\n          connection.removeListener('error', errorHandler);\n\n          if (error) return reject(error);\n\n          debug('connection acquired');\n          resolve(connection);\n        };\n\n        const endHandler = () => {\n          connection.removeListener('connect', connectHandler);\n          connection.removeListener('error', errorHandler);\n          reject(new Error('Connection was closed by remote server'));\n        };\n\n        const errorHandler = error => {\n          connection.removeListener('connect', connectHandler);\n          connection.removeListener('end', endHandler);\n          reject(error);\n        };\n\n        connection.once('error', errorHandler);\n        connection.once('end', endHandler);\n        connection.once('connect', connectHandler);\n\n        /*\n         * Permanently attach this event before connection is even acquired\n         * tedious sometime emits error even after connect(with error).\n         *\n         * If we dont attach this even that unexpected error event will crash node process\n         *\n         * E.g. connectTimeout is set higher than requestTimeout\n         */\n        connection.on('error', error => {\n          switch (error.code) {\n            case 'ESOCKET':\n            case 'ECONNRESET':\n              this.pool.destroy(connection);\n          }\n        });\n\n        if (config.dialectOptions && config.dialectOptions.debug) {\n          connection.on('debug', debugTedious.log.bind(debugTedious));\n        }\n      });\n    } catch (error) {\n      if (!error.code) {\n        throw new sequelizeErrors.ConnectionError(error);\n      }\n\n      switch (error.code) {\n        case 'ESOCKET':\n          if (error.message.includes('connect EHOSTUNREACH')) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes('connect ENETUNREACH')) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes('connect EADDRNOTAVAIL')) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes('connect EAFNOSUPPORT')) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes('getaddrinfo ENOTFOUND')) {\n            throw new sequelizeErrors.HostNotFoundError(error);\n          }\n          if (error.message.includes('connect ECONNREFUSED')) {\n            throw new sequelizeErrors.ConnectionRefusedError(error);\n          }\n          throw new sequelizeErrors.ConnectionError(error);\n        case 'ER_ACCESS_DENIED_ERROR':\n        case 'ELOGIN':\n          throw new sequelizeErrors.AccessDeniedError(error);\n        case 'EINVAL':\n          throw new sequelizeErrors.InvalidConnectionError(error);\n        default:\n          throw new sequelizeErrors.ConnectionError(error);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    // Don't disconnect a connection that is already disconnected\n    if (connection.closed) {\n      return;\n    }\n\n    connection.queue.close();\n\n    return new Promise(resolve => {\n      connection.on('end', resolve);\n      connection.close();\n      debug('connection closed');\n    });\n  }\n\n  validate(connection) {\n    return connection && (connection.loggedIn || connection.state.name === 'LoggedIn');\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}