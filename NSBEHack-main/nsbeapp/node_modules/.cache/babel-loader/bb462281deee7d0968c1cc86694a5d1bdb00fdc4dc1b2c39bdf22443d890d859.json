{"ast":null,"code":"\"use strict\";\n\nconst moment = require(\"moment\");\nconst momentTz = require(\"moment-timezone\");\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(void 0, \"https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-D424D23B-0933-425F-BC69-9C0E6724693C\");\n  BaseTypes.DATE.types.oracle = [\"TIMESTAMP\", \"TIMESTAMP WITH LOCAL TIME ZONE\"];\n  BaseTypes.STRING.types.oracle = [\"VARCHAR2\", \"NVARCHAR2\"];\n  BaseTypes.CHAR.types.oracle = [\"CHAR\", \"RAW\"];\n  BaseTypes.TEXT.types.oracle = [\"CLOB\"];\n  BaseTypes.TINYINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.SMALLINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.MEDIUMINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.INTEGER.types.oracle = [\"INTEGER\"];\n  BaseTypes.BIGINT.types.oracle = [\"NUMBER\"];\n  BaseTypes.FLOAT.types.oracle = [\"BINARY_FLOAT\"];\n  BaseTypes.DATEONLY.types.oracle = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.oracle = [\"CHAR(1)\"];\n  BaseTypes.BLOB.types.oracle = [\"BLOB\"];\n  BaseTypes.DECIMAL.types.oracle = [\"NUMBER\"];\n  BaseTypes.UUID.types.oracle = [\"VARCHAR2\"];\n  BaseTypes.ENUM.types.oracle = [\"VARCHAR2\"];\n  BaseTypes.REAL.types.oracle = [\"BINARY_DOUBLE\"];\n  BaseTypes.DOUBLE.types.oracle = [\"BINARY_DOUBLE\"];\n  BaseTypes.JSON.types.oracle = [\"BLOB\"];\n  BaseTypes.GEOMETRY.types.oracle = false;\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this.length > 4e3 || this._binary && this._length > 2e3) {\n        warn(\"Oracle supports length up to 32764 bytes or characters; Be sure that your administrator has extended the MAX_STRING_SIZE parameter. Check https://docs.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-7B72E154-677A-4342-A1EA-C74C1EA928E6\");\n      }\n      if (!this._binary) {\n        return `NVARCHAR2(${this._length})`;\n      }\n      return `RAW(${this._length})`;\n    }\n    _stringify(value, options) {\n      if (this._binary) {\n        return options.escape(value.toString(\"hex\"));\n      }\n      return options.escape(value);\n    }\n    _getBindDef(oracledb) {\n      if (this._binary) {\n        return {\n          type: oracledb.DB_TYPE_RAW,\n          maxSize: this._length\n        };\n      }\n      return {\n        type: oracledb.DB_TYPE_VARCHAR,\n        maxSize: this._length\n      };\n    }\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n  STRING.prototype.escape = false;\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return \"CHAR(1)\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_CHAR,\n        maxSize: 1\n      };\n    }\n    _stringify(value) {\n      return value === true ? \"1\" : value === false ? \"0\" : value;\n    }\n    _sanitize(value) {\n      if (typeof value === \"string\") {\n        return value === \"1\" || value === \"true\" ? true : value === \"0\" || value === \"false\" ? false : value;\n      }\n      return super._sanitize(value);\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"VARCHAR2(36)\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_VARCHAR,\n        maxSize: 36\n      };\n    }\n  }\n  class NOW extends BaseTypes.NOW {\n    toSql() {\n      return \"SYSDATE\";\n    }\n    _stringify() {\n      return \"SYSDATE\";\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return \"VARCHAR2(512)\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_VARCHAR,\n        maxSize: 512\n      };\n    }\n  }\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      return \"CLOB\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_CLOB\n      };\n    }\n  }\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        warn(\"Oracle CHAR.BINARY datatype is not of Fixed Length.\");\n        return `RAW(${this._length})`;\n      }\n      return super.toSql();\n    }\n    _getBindDef(oracledb) {\n      if (this._binary) {\n        return {\n          type: oracledb.DB_TYPE_RAW,\n          maxSize: this._length\n        };\n      }\n      return {\n        type: oracledb.DB_TYPE_CHAR,\n        maxSize: this._length\n      };\n    }\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return \"TIMESTAMP WITH LOCAL TIME ZONE\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_TIMESTAMP_LTZ\n      };\n    }\n    _stringify(date, options) {\n      const format = \"YYYY-MM-DD HH24:MI:SS.FFTZH:TZM\";\n      date = this._applyTimezone(date, options);\n      const formatedDate = date.format(\"YYYY-MM-DD HH:mm:ss.SSS Z\");\n      return `TO_TIMESTAMP_TZ('${formatedDate}','${format}')`;\n    }\n    _applyTimezone(date, options) {\n      if (options.timezone) {\n        if (momentTz.tz.zone(options.timezone)) {\n          date = momentTz(date).tz(options.timezone);\n        } else {\n          date = moment(date).utcOffset(options.timezone);\n        }\n      } else {\n        date = momentTz(date);\n      }\n      return date;\n    }\n    static parse(value, options) {\n      if (value === null) {\n        return value;\n      }\n      if (options && moment.tz.zone(options.timezone)) {\n        value = moment.tz(value.toString(), options.timezone).toDate();\n      }\n      return value;\n    }\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n  DATE.prototype.escape = false;\n  class DECIMAL extends BaseTypes.DECIMAL {\n    constructor() {\n      super();\n      this.key = \"DECIMAL\";\n    }\n    toSql() {\n      let result = \"\";\n      if (this._length) {\n        result += `(${this._length}`;\n        if (typeof this._decimals === \"number\") {\n          result += `,${this._decimals}`;\n        }\n        result += \")\";\n      }\n      if (!this._length && this._precision) {\n        result += `(${this._precision}`;\n        if (typeof this._scale === \"number\") {\n          result += `,${this._scale}`;\n        }\n        result += \")\";\n      }\n      return `NUMBER${result}`;\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n  }\n  class TINYINT extends BaseTypes.TINYINT {\n    toSql() {\n      return \"NUMBER(3)\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n  }\n  class SMALLINT extends BaseTypes.SMALLINT {\n    toSql() {\n      return \"NUMBER(5)\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n  }\n  class MEDIUMINT extends BaseTypes.MEDIUMINT {\n    toSql() {\n      return \"NUMBER(8)\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n  }\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      if (!(this instanceof BIGINT)) return new BIGINT(length);\n      BaseTypes.BIGINT.apply(this, arguments);\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn(\"Oracle does not support BIGINT with options\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n    }\n    toSql() {\n      return \"NUMBER(19)\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n    _sanitize(value) {\n      if (typeof value === \"bigint\" || typeof value === \"number\") {\n        return value.toString();\n      }\n      return value;\n    }\n  }\n  class NUMBER extends BaseTypes.NUMBER {\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n  }\n  class INTEGER extends BaseTypes.INTEGER {\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_NUMBER\n      };\n    }\n  }\n  class FLOAT extends BaseTypes.FLOAT {\n    toSql() {\n      return \"BINARY_FLOAT\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_BINARY_FLOAT\n      };\n    }\n  }\n  class REAL extends BaseTypes.REAL {\n    toSql() {\n      return \"BINARY_DOUBLE\";\n    }\n    _stringify(value) {\n      if (value === Number.POSITIVE_INFINITY) {\n        return \"inf\";\n      }\n      if (value === Number.NEGATIVE_INFINITY) {\n        return \"-inf\";\n      }\n      return value;\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_BINARY_DOUBLE\n      };\n    }\n  }\n  class BLOB extends BaseTypes.BLOB {\n    _hexify(hex) {\n      return `'${hex}'`;\n    }\n    toSql() {\n      return \"BLOB\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_BLOB\n      };\n    }\n  }\n  class JSONTYPE extends BaseTypes.JSON {\n    toSql() {\n      return \"BLOB\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_BLOB\n      };\n    }\n    _stringify(value, options) {\n      return options.operation === \"where\" && typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n    _bindParam(value, options) {\n      return options.bindParam(Buffer.from(JSON.stringify(value)));\n    }\n  }\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (!(this instanceof DOUBLE)) return new BaseTypes.DOUBLE(length, decimals);\n      BaseTypes.DOUBLE.apply(this, arguments);\n      if (this._length || this._unsigned || this._zerofill) {\n        warn(\"Oracle does not support DOUBLE with options.\");\n        this._length = void 0;\n        this.options.length = void 0;\n        this._unsigned = void 0;\n        this._zerofill = void 0;\n      }\n      this.key = \"DOUBLE PRECISION\";\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_BINARY_DOUBLE\n      };\n    }\n    toSql() {\n      return \"BINARY_DOUBLE\";\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    parse(value) {\n      return moment(value).format(\"YYYY-MM-DD\");\n    }\n    _sanitize(value) {\n      if (value) {\n        return moment(value).format(\"YYYY-MM-DD\");\n      }\n      return value;\n    }\n    _stringify(date, options) {\n      if (date) {\n        const format = \"YYYY/MM/DD\";\n        return options.escape(`TO_DATE('${date}','${format}')`);\n      }\n      return options.escape(date);\n    }\n    _getBindDef(oracledb) {\n      return {\n        type: oracledb.DB_TYPE_DATE\n      };\n    }\n    _bindParam(value, options) {\n      if (typeof value === \"string\") {\n        return options.bindParam(new Date(value));\n      }\n      return options.bindParam(value);\n    }\n  }\n  DATEONLY.prototype.escape = false;\n  return {\n    BOOLEAN,\n    \"DOUBLE PRECISION\": DOUBLE,\n    DOUBLE,\n    STRING,\n    TINYINT,\n    SMALLINT,\n    MEDIUMINT,\n    BIGINT,\n    NUMBER,\n    INTEGER,\n    FLOAT,\n    UUID,\n    DATEONLY,\n    DATE,\n    NOW,\n    BLOB,\n    ENUM,\n    TEXT,\n    CHAR,\n    JSON: JSONTYPE,\n    REAL,\n    DECIMAL\n  };\n};","map":{"version":3,"mappings":"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","names":["moment","require","momentTz","module","exports","BaseTypes","warn","ABSTRACT","bind","DATE","types","oracle","STRING","CHAR","TEXT","TINYINT","SMALLINT","MEDIUMINT","INTEGER","BIGINT","FLOAT","DATEONLY","BOOLEAN","BLOB","DECIMAL","UUID","ENUM","REAL","DOUBLE","JSON","GEOMETRY","toSql","length","_binary","_length","_stringify","value","options","escape","toString","_getBindDef","oracledb","type","DB_TYPE_RAW","maxSize","DB_TYPE_VARCHAR","_bindParam","bindParam","prototype","DB_TYPE_CHAR","_sanitize","NOW","DB_TYPE_CLOB","DB_TYPE_TIMESTAMP_LTZ","date","format","_applyTimezone","formatedDate","timezone","tz","zone","utcOffset","parse","toDate","constructor","key","result","_decimals","_precision","_scale","DB_TYPE_NUMBER","apply","arguments","_unsigned","_zerofill","NUMBER","DB_TYPE_BINARY_FLOAT","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","DB_TYPE_BINARY_DOUBLE","_hexify","hex","DB_TYPE_BLOB","operation","stringify","Buffer","from","decimals","DB_TYPE_DATE","Date","JSONTYPE"],"sources":["C:\\Users\\rizla\\projects\\react\\NSBEHack-main\\nsbeapp\\node_modules\\sequelize\\src\\dialects\\oracle\\data-types.js"],"sourcesContent":["// Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved\n\n'use strict';\n\nconst moment = require('moment');\nconst momentTz = require('moment-timezone');\n\nmodule.exports = BaseTypes => {\n  const warn = BaseTypes.ABSTRACT.warn.bind(\n    undefined,\n    'https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-D424D23B-0933-425F-BC69-9C0E6724693C'\n  );\n\n  BaseTypes.DATE.types.oracle = ['TIMESTAMP', 'TIMESTAMP WITH LOCAL TIME ZONE'];\n  BaseTypes.STRING.types.oracle = ['VARCHAR2', 'NVARCHAR2'];\n  BaseTypes.CHAR.types.oracle = ['CHAR', 'RAW'];\n  BaseTypes.TEXT.types.oracle = ['CLOB'];\n  BaseTypes.TINYINT.types.oracle = ['NUMBER'];\n  BaseTypes.SMALLINT.types.oracle = ['NUMBER'];\n  BaseTypes.MEDIUMINT.types.oracle = ['NUMBER'];\n  BaseTypes.INTEGER.types.oracle = ['INTEGER'];\n  BaseTypes.BIGINT.types.oracle = ['NUMBER'];\n  BaseTypes.FLOAT.types.oracle = ['BINARY_FLOAT'];\n  BaseTypes.DATEONLY.types.oracle = ['DATE'];\n  BaseTypes.BOOLEAN.types.oracle = ['CHAR(1)'];\n  BaseTypes.BLOB.types.oracle = ['BLOB'];\n  BaseTypes.DECIMAL.types.oracle = ['NUMBER'];\n  BaseTypes.UUID.types.oracle = ['VARCHAR2'];\n  BaseTypes.ENUM.types.oracle = ['VARCHAR2'];\n  BaseTypes.REAL.types.oracle = ['BINARY_DOUBLE'];\n  BaseTypes.DOUBLE.types.oracle = ['BINARY_DOUBLE'];\n  BaseTypes.JSON.types.oracle = ['BLOB'];\n  BaseTypes.GEOMETRY.types.oracle = false;\n\n  class STRING extends BaseTypes.STRING {\n    toSql() {\n      if (this.length > 4000 || this._binary && this._length > 2000) {\n        warn(\n          'Oracle supports length up to 32764 bytes or characters; Be sure that your administrator has extended the MAX_STRING_SIZE parameter. Check https://docs.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-7B72E154-677A-4342-A1EA-C74C1EA928E6'\n        );\n      }\n      if (!this._binary) {\n        return `NVARCHAR2(${this._length})`;\n      }\n      return `RAW(${this._length})`;\n    }\n\n    _stringify(value, options) {\n      if (this._binary) {\n        // For Binary numbers we're converting a buffer to hex then\n        // sending it over the wire as a string,\n        // We pass it through escape function to remove un-necessary quotes\n        // this.format in insert/bulkinsert query calls stringify hence we need to convert binary buffer\n        // to hex string. Since this block is used by both bind (insert/bulkinsert) and\n        // non-bind (select query where clause) hence we need to\n        // have an operation that supports both\n        return options.escape(value.toString('hex'));\n      }\n      return options.escape(value);\n    }\n\n    _getBindDef(oracledb) {\n      if (this._binary) {\n        return { type: oracledb.DB_TYPE_RAW, maxSize: this._length };\n      }\n      return { type: oracledb.DB_TYPE_VARCHAR, maxSize: this._length };\n    }\n\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n\n  STRING.prototype.escape = false;\n\n  class BOOLEAN extends BaseTypes.BOOLEAN {\n    toSql() {\n      return 'CHAR(1)';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_CHAR, maxSize: 1 };\n    }\n\n    _stringify(value) {\n      // If value is true we return '1'\n      // If value is false we return '0'\n      // Else we return it as is\n      // Converting number to char since in bindDef\n      // the type would be oracledb.DB_TYPE_CHAR\n      return value === true ? '1' : value === false ? '0' : value;\n    }\n\n    _sanitize(value) {\n      if (typeof value === 'string') {\n        // If value is a string we return true if among '1' and 'true'\n        // We return false if among '0' and 'false'\n        // Else return the value as is and let the DB raise error for invalid values\n        return value === '1' || value === 'true' ? true : value === '0' || value === 'false' ? false : value;\n      }\n      return super._sanitize(value);\n    }\n  }\n\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return 'VARCHAR2(36)';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_VARCHAR, maxSize: 36 };\n    }\n  }\n\n  class NOW extends BaseTypes.NOW {\n    toSql() {\n      return 'SYSDATE';\n    }\n\n    _stringify() {\n      return 'SYSDATE';\n    }\n  }\n\n  class ENUM extends BaseTypes.ENUM {\n    toSql() {\n      return 'VARCHAR2(512)';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_VARCHAR, maxSize: 512 };\n    }\n  }\n\n  class TEXT extends BaseTypes.TEXT {\n    toSql() {\n      return 'CLOB';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_CLOB };\n    }\n  }\n\n  class CHAR extends BaseTypes.CHAR {\n    toSql() {\n      if (this._binary) {\n        warn('Oracle CHAR.BINARY datatype is not of Fixed Length.');\n        return `RAW(${this._length})`;\n      }\n      return super.toSql();\n    }\n\n    _getBindDef(oracledb) {\n      if (this._binary) {\n        return { type: oracledb.DB_TYPE_RAW, maxSize: this._length };\n      }\n      return { type: oracledb.DB_TYPE_CHAR, maxSize: this._length };\n    }\n\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return 'TIMESTAMP WITH LOCAL TIME ZONE';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_TIMESTAMP_LTZ };\n    }\n\n    _stringify(date, options) {\n      const format = 'YYYY-MM-DD HH24:MI:SS.FFTZH:TZM';\n\n      date = this._applyTimezone(date, options);\n\n      const formatedDate = date.format('YYYY-MM-DD HH:mm:ss.SSS Z');\n\n      return `TO_TIMESTAMP_TZ('${formatedDate}','${format}')`;\n    }\n\n    _applyTimezone(date, options) {\n      if (options.timezone) {\n        if (momentTz.tz.zone(options.timezone)) {\n          date = momentTz(date).tz(options.timezone);\n        } else {\n          date = moment(date).utcOffset(options.timezone);\n        }\n      } else {\n        date = momentTz(date);\n      }\n      return date;\n    }\n\n    static parse(value, options) {\n      if (value === null) {\n        return value;\n      }\n      if (options && moment.tz.zone(options.timezone)) {\n        value = moment.tz(value.toString(), options.timezone).toDate();\n      }\n      return value;\n    }\n\n    /**\n     * avoids appending TO_TIMESTAMP_TZ in _stringify\n     *\n     * @override\n     */\n    _bindParam(value, options) {\n      return options.bindParam(value);\n    }\n  }\n\n  DATE.prototype.escape = false;\n\n  class DECIMAL extends BaseTypes.DECIMAL {\n    constructor() {\n      super();\n      this.key = 'DECIMAL';\n    }\n\n    toSql() {\n      let result = '';\n      if (this._length) {\n        result += `(${this._length}`;\n        if (typeof this._decimals === 'number') {\n          result += `,${this._decimals}`;\n        }\n        result += ')';\n      }\n\n      if (!this._length && this._precision) {\n        result += `(${this._precision}`;\n        if (typeof this._scale === 'number') {\n          result += `,${this._scale}`;\n        }\n        result += ')';\n      }\n\n      return `NUMBER${result}`;\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n\n  class TINYINT extends BaseTypes.TINYINT {\n    toSql() {\n      return 'NUMBER(3)';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n\n  class SMALLINT extends BaseTypes.SMALLINT {\n    toSql() {\n      return 'NUMBER(5)';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n\n  class MEDIUMINT extends BaseTypes.MEDIUMINT {\n    toSql() {\n      return 'NUMBER(8)';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n\n  class BIGINT extends BaseTypes.BIGINT {\n    constructor(length) {\n      super(length);\n      if (!(this instanceof BIGINT)) return new BIGINT(length);\n      BaseTypes.BIGINT.apply(this, arguments);\n\n      // ORACLE does not support any options for bigint\n      if (this._length || this.options.length || this._unsigned || this._zerofill) {\n        warn('Oracle does not support BIGINT with options');\n        this._length = undefined;\n        this.options.length = undefined;\n        this._unsigned = undefined;\n        this._zerofill = undefined;\n      }\n    }\n\n    toSql() {\n      return 'NUMBER(19)';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n\n    _sanitize(value) {\n      if (typeof value === 'bigint' || typeof value === 'number') {\n        return value.toString();\n      }\n      return value;\n    }\n\n  }\n\n  class NUMBER extends BaseTypes.NUMBER {\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n\n  class INTEGER extends BaseTypes.INTEGER {\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_NUMBER };\n    }\n  }\n\n  class FLOAT extends BaseTypes.FLOAT {\n    toSql() {\n      return 'BINARY_FLOAT';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BINARY_FLOAT };\n    }\n  }\n\n  class REAL extends BaseTypes.REAL {\n    toSql() {\n      return 'BINARY_DOUBLE';\n    }\n\n    // https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-0BA2E065-8006-426C-A3CB-1F6B0C8F283C\n    _stringify(value) {\n      if (value === Number.POSITIVE_INFINITY) {\n        return 'inf';\n      }\n      if (value === Number.NEGATIVE_INFINITY) {\n        return '-inf';\n      }\n      return value;\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BINARY_DOUBLE };\n    }\n  }\n\n  class BLOB extends BaseTypes.BLOB {\n    // Generic hexify returns X'${hex}' but Oracle expects '${hex}' for BLOB datatype\n    _hexify(hex) {\n      return `'${hex}'`;\n    }\n\n    toSql() {\n      return 'BLOB';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BLOB };\n    }\n  }\n\n  class JSONTYPE extends BaseTypes.JSON {\n    toSql() {\n      return 'BLOB';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BLOB };\n    }\n\n    _stringify(value, options) {\n      return options.operation === 'where' && typeof value === 'string' ? value : JSON.stringify(value);\n    }\n\n    _bindParam(value, options) {\n      return options.bindParam(Buffer.from(JSON.stringify(value)));\n    }\n  }\n\n  class DOUBLE extends BaseTypes.DOUBLE {\n    constructor(length, decimals) {\n      super(length, decimals);\n      if (!(this instanceof DOUBLE)) return new BaseTypes.DOUBLE(length, decimals);\n      BaseTypes.DOUBLE.apply(this, arguments);\n\n      if (this._length || this._unsigned || this._zerofill) {\n        warn('Oracle does not support DOUBLE with options.');\n        this._length = undefined;\n        this.options.length = undefined;\n        this._unsigned = undefined;\n        this._zerofill = undefined;\n      }\n\n      this.key = 'DOUBLE PRECISION';\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_BINARY_DOUBLE };\n    }\n\n    toSql() {\n      return 'BINARY_DOUBLE';\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    parse(value) {\n      return moment(value).format('YYYY-MM-DD');\n    }\n\n    _sanitize(value) {\n      if (value) {\n        return moment(value).format('YYYY-MM-DD');\n      }\n      return value;\n    }\n\n    _stringify(date, options) {\n      // If date is not null only then we format the date\n      if (date) {\n        const format = 'YYYY/MM/DD';\n        return options.escape(`TO_DATE('${date}','${format}')`);\n      }\n      return options.escape(date);\n    }\n\n    _getBindDef(oracledb) {\n      return { type: oracledb.DB_TYPE_DATE };\n    }\n\n    /**\n     * avoids appending TO_DATE in _stringify\n     *\n     * @override\n     */\n    _bindParam(value, options) {\n      if (typeof value === 'string') {\n        return options.bindParam(new Date(value));\n      }\n      return options.bindParam(value);\n\n    }\n  }\n\n  DATEONLY.prototype.escape = false;\n\n  return {\n    BOOLEAN,\n    'DOUBLE PRECISION': DOUBLE,\n    DOUBLE,\n    STRING,\n    TINYINT,\n    SMALLINT,\n    MEDIUMINT,\n    BIGINT,\n    NUMBER,\n    INTEGER,\n    FLOAT,\n    UUID,\n    DATEONLY,\n    DATE,\n    NOW,\n    BLOB,\n    ENUM,\n    TEXT,\n    CHAR,\n    JSON: JSONTYPE,\n    REAL,\n    DECIMAL\n  };\n};\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}