{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = require(\"lodash\");\nconst Utils = require(\"../../utils\");\nconst DataTypes = require(\"../../data-types\");\nconst AbstractQueryGenerator = require(\"../abstract/query-generator\");\nconst randomBytes = require(\"crypto\").randomBytes;\nconst Op = require(\"../../operators\");\nconst throwMethodUndefined = function (methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n};\nclass Db2QueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n    this.OperatorMap = __spreadProps(__spreadValues({}, this.OperatorMap), {\n      [Op.regexp]: \"REGEXP_LIKE\",\n      [Op.notRegexp]: \"NOT REGEXP_LIKE\"\n    });\n    this.autoGenValue = 1;\n  }\n  createSchema(schema) {\n    return [\"CREATE SCHEMA\", this.quoteIdentifier(schema), \";\"].join(\" \");\n  }\n  dropSchema(schema) {\n    const query = `CALL SYSPROC.ADMIN_DROP_SCHEMA(${wrapSingleQuote(schema.trim())}, NULL, ? , ?)`;\n    const sql = {\n      query\n    };\n    sql.bind = [{\n      ParamType: \"INOUT\",\n      Data: \"ERRORSCHEMA\"\n    }, {\n      ParamType: \"INOUT\",\n      Data: \"ERRORTABLE\"\n    }];\n    return sql;\n  }\n  showSchemasQuery() {\n    return `SELECT SCHEMANAME AS \"schema_name\" FROM SYSCAT.SCHEMATA WHERE (SCHEMANAME NOT LIKE 'SYS%') AND SCHEMANAME NOT IN ('NULLID', 'SQLJ', 'ERRORSCHEMA')`;\n  }\n  versionQuery() {\n    return \"select service_level as VERSION from TABLE (sysproc.env_get_inst_info()) as A\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    const query = \"CREATE TABLE <%= table %> (<%= attributes %>)\",\n      primaryKeys = [],\n      foreignKeys = {},\n      attrStr = [],\n      commentTemplate = \" -- <%= comment %>, TableName = <%= table %>, ColumnName = <%= column %>;\";\n    let commentStr = \"\";\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n        if (dataType.includes(\"COMMENT \")) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          if (commentMatch && commentMatch.length > 2) {\n            const commentText = commentMatch[2].replace(/COMMENT/, \"\").trim();\n            commentStr += _.template(commentTemplate, this._templateSettings)({\n              table: this.quoteIdentifier(tableName),\n              comment: this.escape(commentText),\n              column: this.quoteIdentifier(attr)\n            });\n            dataType = commentMatch[1];\n          }\n        }\n        if (_.includes(dataType, \"PRIMARY KEY\")) {\n          primaryKeys.push(attr);\n          if (_.includes(dataType, \"REFERENCES\")) {\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace(/PRIMARY KEY/, \"\")}`);\n            foreignKeys[attr] = match[2];\n          } else {\n            attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace(/PRIMARY KEY/, \"\")}`);\n          }\n        } else if (_.includes(dataType, \"REFERENCES\")) {\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          if (options && options.uniqueKeys) {\n            for (const ukey in options.uniqueKeys) {\n              if (options.uniqueKeys[ukey].fields.includes(attr) && !_.includes(dataType, \"NOT NULL\")) {\n                dataType += \" NOT NULL\";\n                break;\n              }\n            }\n          }\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n        }\n      }\n    }\n    const values = {\n        table: this.quoteTable(tableName),\n        attributes: attrStr.join(\", \")\n      },\n      pkString = primaryKeys.map(pk => {\n        return this.quoteIdentifier(pk);\n      }).join(\", \");\n    if (options && options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (!_.isString(indexName)) {\n            indexName = `uniq_${tableName}_${columns.fields.join(\"_\")}`;\n          }\n          values.attributes += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(\", \")})`;\n        }\n      });\n    }\n    if (pkString.length > 0) {\n      values.attributes += `, PRIMARY KEY (${pkString})`;\n    }\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        values.attributes += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n    return `${_.template(query, this._templateSettings)(values).trim()};${commentStr}`;\n  }\n  describeTableQuery(tableName, schema) {\n    let sql = ['SELECT NAME AS \"Name\", TBNAME AS \"Table\", TBCREATOR AS \"Schema\",', 'TRIM(COLTYPE) AS \"Type\", LENGTH AS \"Length\", SCALE AS \"Scale\",', 'NULLS AS \"IsNull\", DEFAULT AS \"Default\", COLNO AS \"Colno\",', 'IDENTITY AS \"IsIdentity\", KEYSEQ AS \"KeySeq\", REMARKS AS \"Comment\"', \"FROM\", \"SYSIBM.SYSCOLUMNS\", \"WHERE TBNAME =\", wrapSingleQuote(tableName)].join(\" \");\n    if (schema) {\n      sql += ` AND TBCREATOR =${wrapSingleQuote(schema)}`;\n    } else {\n      sql += \" AND TBCREATOR = USER\";\n    }\n    return `${sql};`;\n  }\n  renameTableQuery(before, after) {\n    const query = \"RENAME TABLE <%= before %> TO <%= after %>;\";\n    return _.template(query, this._templateSettings)({\n      before: this.quoteTable(before),\n      after: this.quoteTable(after)\n    });\n  }\n  showTablesQuery() {\n    return `SELECT TABNAME AS \"tableName\", TRIM(TABSCHEMA) AS \"tableSchema\" FROM SYSCAT.TABLES WHERE TABSCHEMA = USER AND TYPE = 'T' ORDER BY TABSCHEMA, TABNAME`;\n  }\n  tableExistsQuery(table) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema || this.sequelize.config.username.toUpperCase();\n    return `SELECT name FROM sysibm.systables WHERE NAME = ${wrapSingleQuote(tableName)} AND CREATOR = ${wrapSingleQuote(schemaName)}`;\n  }\n  dropTableQuery(tableName) {\n    const query = \"DROP TABLE <%= table %>\";\n    const values = {\n      table: this.quoteTable(tableName)\n    };\n    return `${_.template(query, this._templateSettings)(values).trim()};`;\n  }\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n    const query = \"ALTER TABLE <%= table %> ADD <%= attribute %>;\",\n      attribute = _.template(\"<%= key %> <%= definition %>\", this._templateSettings)({\n        key: this.quoteIdentifier(key),\n        definition: this.attributeToSQL(dataType, {\n          context: \"addColumn\"\n        })\n      });\n    return _.template(query, this._templateSettings)({\n      table: this.quoteTable(table),\n      attribute\n    });\n  }\n  removeColumnQuery(tableName, attributeName) {\n    const query = \"ALTER TABLE <%= tableName %> DROP COLUMN <%= attributeName %>;\";\n    return _.template(query, this._templateSettings)({\n      tableName: this.quoteTable(tableName),\n      attributeName: this.quoteIdentifier(attributeName)\n    });\n  }\n  changeColumnQuery(tableName, attributes) {\n    const query = \"ALTER TABLE <%= tableName %> <%= query %>;\";\n    const attrString = [],\n      constraintString = [];\n    for (const attributeName in attributes) {\n      const attrValue = attributes[attributeName];\n      let defs = [attrValue];\n      if (Array.isArray(attrValue)) {\n        defs = attrValue;\n      }\n      for (let i = 0; i < defs.length; i++) {\n        const definition = defs[i];\n        if (definition.match(/REFERENCES/)) {\n          constraintString.push(_.template(\"<%= fkName %> FOREIGN KEY (<%= attrName %>) <%= definition %>\", this._templateSettings)({\n            fkName: this.quoteIdentifier(`${attributeName}_foreign_idx`),\n            attrName: this.quoteIdentifier(attributeName),\n            definition: definition.replace(/.+?(?=REFERENCES)/, \"\")\n          }));\n        } else if (_.startsWith(definition, \"DROP \")) {\n          attrString.push(_.template(\"<%= attrName %> <%= definition %>\", this._templateSettings)({\n            attrName: this.quoteIdentifier(attributeName),\n            definition\n          }));\n        } else {\n          attrString.push(_.template(\"<%= attrName %> SET <%= definition %>\", this._templateSettings)({\n            attrName: this.quoteIdentifier(attributeName),\n            definition\n          }));\n        }\n      }\n    }\n    let finalQuery = \"\";\n    if (attrString.length) {\n      finalQuery += `ALTER COLUMN ${attrString.join(\" ALTER COLUMN \")}`;\n      finalQuery += constraintString.length ? \" \" : \"\";\n    }\n    if (constraintString.length) {\n      finalQuery += `ADD CONSTRAINT ${constraintString.join(\" ADD CONSTRAINT \")}`;\n    }\n    return _.template(query, this._templateSettings)({\n      tableName: this.quoteTable(tableName),\n      query: finalQuery\n    });\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const query = \"ALTER TABLE <%= tableName %> RENAME COLUMN <%= before %> TO <%= after %>;\",\n      newName = Object.keys(attributes)[0];\n    return _.template(query, this._templateSettings)({\n      tableName: this.quoteTable(tableName),\n      before: this.quoteIdentifier(attrBefore),\n      after: this.quoteIdentifier(newName)\n    });\n  }\n  addConstraintQuery(tableName, options) {\n    options = options || {};\n    if (options.onUpdate && options.onUpdate.toUpperCase() === \"CASCADE\") {\n      delete options.onUpdate;\n    }\n    const constraintSnippet = this.getConstraintSnippet(tableName, options);\n    if (typeof tableName === \"string\") {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;\n  }\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    options = options || {};\n    attributes = attributes || {};\n    let query = \"INSERT INTO <%= table %> (<%= attributes %>)<%= output %> VALUES <%= tuples %>;\";\n    if (options.returning) {\n      query = \"SELECT * FROM FINAL TABLE( INSERT INTO <%= table %> (<%= attributes %>)<%= output %> VALUES <%= tuples %>);\";\n    }\n    const emptyQuery = \"INSERT INTO <%= table %>\",\n      tuples = [],\n      allAttributes = [],\n      allQueries = [];\n    let outputFragment;\n    const valuesForEmptyQuery = [];\n    if (options.returning) {\n      outputFragment = \"\";\n    }\n    _.forEach(attrValueHashes, attrValueHash => {\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        valuesForEmptyQuery.push(`(${this.autoGenValue++})`);\n        return;\n      }\n      _.forOwn(attrValueHash, (value, key) => {\n        if (allAttributes.indexOf(key) === -1) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement) return;\n          allAttributes.push(key);\n        }\n      });\n    });\n    if (valuesForEmptyQuery.length > 0) {\n      allQueries.push(`${emptyQuery} VALUES ${valuesForEmptyQuery.join(\",\")}`);\n    }\n    if (allAttributes.length > 0) {\n      _.forEach(attrValueHashes, attrValueHash => {\n        tuples.push(`(${allAttributes.map(key => this.escape(attrValueHash[key]), void 0, {\n          context: \"INSERT\"\n        }).join(\",\")})`);\n      });\n      allQueries.push(query);\n    }\n    const replacements = {\n      table: this.quoteTable(tableName),\n      attributes: allAttributes.map(attr => this.quoteIdentifier(attr)).join(\",\"),\n      tuples,\n      output: outputFragment\n    };\n    const generatedQuery = _.template(allQueries.join(\";\"), this._templateSettings)(replacements);\n    return generatedQuery;\n  }\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n    options = options || {};\n    _.defaults(options, this.options);\n    if (!options.limit) {\n      sql.query = `SELECT * FROM FINAL TABLE (${sql.query});`;\n      return sql;\n    }\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || void 0, {\n          context: \"UPDATE\"\n        })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || void 0, {\n          context: \"UPDATE\"\n        }, bindParam)}`);\n      }\n    }\n    let query;\n    const whereOptions = _.defaults({\n      bindParam\n    }, options);\n    query = `UPDATE (SELECT * FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} FETCH NEXT ${this.escape(options.limit)} ROWS ONLY) SET ${values.join(\",\")}`;\n    query = `SELECT * FROM FINAL TABLE (${query});`;\n    return {\n      query,\n      bind\n    };\n  }\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    }\n    for (const index of model._indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === \"string\" ? field : field.name || field.attribute;\n          if (uniqueAttrs.indexOf(fieldName) === -1 && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map(key => this.quoteIdentifier(key)).join(\", \");\n    const insertValuesEscaped = insertKeys.map(key => this.escape(insertValues[key])).join(\", \");\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`;\n    let joinCondition;\n    const clauses = where[Op.or].filter(clause => {\n      let valid = true;\n      for (const key in clause) {\n        if (!clause[key]) {\n          valid = false;\n          break;\n        }\n      }\n      return valid;\n    });\n    const getJoinSnippet = array => {\n      return array.map(key => {\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n    if (clauses.length === 0) {\n      throw new Error(\"Primary Key or Unique key should be passed to upsert query\");\n    } else {\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n        if (primaryKeysAttrs.indexOf(keys[0]) !== -1) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(\" AND \");\n          break;\n        }\n      }\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(\" AND \");\n      }\n    }\n    const filteredUpdateClauses = updateKeys.filter(key => {\n      if (identityAttrs.indexOf(key) === -1) {\n        return true;\n      }\n      return false;\n    }).map(key => {\n      const value = this.escape(updateValues[key]);\n      key = this.quoteIdentifier(key);\n      return `${targetTableAlias}.${key} = ${value}`;\n    }).join(\", \");\n    const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses}` : \"\";\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n    let query = `MERGE INTO ${tableNameQuoted} AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet};`;\n    return query;\n  }\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)} IMMEDIATE`;\n  }\n  deleteQuery(tableName, where) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let model = arguments.length > 3 ? arguments[3] : undefined;\n    const table = this.quoteTable(tableName);\n    const query = \"DELETE FROM <%= table %><%= where %><%= limit %>\";\n    where = this.getWhereConditions(where, null, model, options);\n    let limit = \"\";\n    if (options.offset > 0) {\n      limit = ` OFFSET ${this.escape(options.offset)} ROWS`;\n    }\n    if (options.limit) {\n      limit += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n    }\n    const replacements = {\n      limit,\n      table,\n      where\n    };\n    if (replacements.where) {\n      replacements.where = ` WHERE ${replacements.where}`;\n    }\n    return _.template(query, this._templateSettings)(replacements);\n  }\n  showIndexesQuery(tableName) {\n    let sql = 'SELECT NAME AS \"name\", TBNAME AS \"tableName\", UNIQUERULE AS \"keyType\", COLNAMES, INDEXTYPE AS \"type\" FROM SYSIBM.SYSINDEXES WHERE TBNAME = <%= tableName %>';\n    let schema = void 0;\n    if (_.isObject(tableName)) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n    if (schema) {\n      sql = `${sql} AND TBCREATOR = <%= schemaName %>`;\n    }\n    sql = `${sql} ORDER BY NAME;`;\n    return _.template(sql, this._templateSettings)({\n      tableName: wrapSingleQuote(tableName),\n      schemaName: wrapSingleQuote(schema)\n    });\n  }\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT CONSTNAME AS \"constraintName\", TRIM(TABSCHEMA) AS \"schemaName\", TABNAME AS \"tableName\" FROM SYSCAT.TABCONST WHERE TABNAME = '${tableName}'`;\n    if (constraintName) {\n      sql += ` AND CONSTNAME LIKE '%${constraintName}%'`;\n    }\n    return `${sql} ORDER BY CONSTNAME;`;\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    const sql = \"DROP INDEX <%= indexName %>\";\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    const values = {\n      tableName: this.quoteIdentifiers(tableName),\n      indexName: this.quoteIdentifiers(indexName)\n    };\n    return _.template(sql, this._templateSettings)(values);\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    let template;\n    let changeNull = 1;\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map(value => {\n        return this.escape(value);\n      }).join(\", \")}))`;\n    } else {\n      template = attribute.type.toString();\n    }\n    if (options && options.context === \"changeColumn\" && attribute.type) {\n      template = `DATA TYPE ${template}`;\n    } else if (attribute.allowNull === false || attribute.primaryKey === true || attribute.unique) {\n      template += \" NOT NULL\";\n      changeNull = 0;\n    }\n    if (attribute.autoIncrement) {\n      let initialValue = 1;\n      if (attribute.initialAutoIncrement) {\n        initialValue = attribute.initialAutoIncrement;\n      }\n      template += ` GENERATED BY DEFAULT AS IDENTITY(START WITH ${initialValue}, INCREMENT BY 1)`;\n    }\n    if (attribute.type !== \"TEXT\" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (attribute.unique === true) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      if (options && options.context === \"addColumn\" && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = `${options.tableName}_${attrName}_fidx`;\n        template += `, CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n      if (attribute.onUpdate && attribute.onUpdate.toUpperCase() != \"CASCADE\") {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n    if (options && options.context === \"changeColumn\" && changeNull === 1 && attribute.allowNull !== void 0) {\n      template = [template];\n      if (attribute.allowNull) {\n        template.push(\"DROP NOT NULL\");\n      } else {\n        template.push(\"NOT NULL\");\n      }\n    }\n    if (attribute.comment && typeof attribute.comment === \"string\") {\n      template += ` COMMENT ${attribute.comment}`;\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {},\n      existingConstraints = [];\n    let key, attribute;\n    for (key in attributes) {\n      attribute = attributes[key];\n      if (attribute.references) {\n        if (existingConstraints.indexOf(attribute.references.model.toString()) !== -1) {\n          attribute.onDelete = \"\";\n          attribute.onUpdate = \"\";\n        } else if (attribute.unique && attribute.unique === true) {\n          attribute.onDelete = \"\";\n          attribute.onUpdate = \"\";\n        } else {\n          existingConstraints.push(attribute.references.model.toString());\n        }\n      }\n      if (key && !attribute.field && typeof attribute === \"object\") attribute.field = key;\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n    return result;\n  }\n  createTrigger() {\n    throwMethodUndefined(\"createTrigger\");\n  }\n  dropTrigger() {\n    throwMethodUndefined(\"dropTrigger\");\n  }\n  renameTrigger() {\n    throwMethodUndefined(\"renameTrigger\");\n  }\n  createFunction() {\n    throwMethodUndefined(\"createFunction\");\n  }\n  dropFunction() {\n    throwMethodUndefined(\"dropFunction\");\n  }\n  renameFunction() {\n    throwMethodUndefined(\"renameFunction\");\n  }\n  _getForeignKeysQuerySQL(condition) {\n    return `SELECT R.CONSTNAME AS \"constraintName\", TRIM(R.TABSCHEMA) AS \"constraintSchema\", R.TABNAME AS \"tableName\", TRIM(R.TABSCHEMA) AS \"tableSchema\", LISTAGG(C.COLNAME,', ') WITHIN GROUP (ORDER BY C.COLNAME) AS \"columnName\", TRIM(R.REFTABSCHEMA) AS \"referencedTableSchema\", R.REFTABNAME AS \"referencedTableName\", TRIM(R.PK_COLNAMES) AS \"referencedColumnName\" FROM SYSCAT.REFERENCES R, SYSCAT.KEYCOLUSE C WHERE R.CONSTNAME = C.CONSTNAME AND R.TABSCHEMA = C.TABSCHEMA AND R.TABNAME = C.TABNAME${condition} GROUP BY R.REFTABSCHEMA, R.REFTABNAME, R.TABSCHEMA, R.TABNAME, R.CONSTNAME, R.PK_COLNAMES`;\n  }\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    schemaName = table.schema || schemaName;\n    let sql = \"\";\n    if (tableName) {\n      sql = ` AND R.TABNAME = ${wrapSingleQuote(tableName)}`;\n    }\n    if (schemaName) {\n      sql += ` AND R.TABSCHEMA = ${wrapSingleQuote(schemaName)}`;\n    }\n    return this._getForeignKeysQuerySQL(sql);\n  }\n  getForeignKeyQuery(table, columnName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    let sql = \"\";\n    if (tableName) {\n      sql = ` AND R.TABNAME = ${wrapSingleQuote(tableName)}`;\n    }\n    if (schemaName) {\n      sql += ` AND R.TABSCHEMA = ${wrapSingleQuote(schemaName)}`;\n    }\n    if (columnName) {\n      sql += ` AND C.COLNAME = ${wrapSingleQuote(columnName)}`;\n    }\n    return this._getForeignKeysQuerySQL(sql);\n  }\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n    return ['SELECT TABNAME AS \"tableName\",', 'COLNAME AS \"columnName\",', 'CONSTNAME AS \"constraintName\"', \"FROM SYSCAT.KEYCOLUSE WHERE CONSTNAME LIKE 'PK_%'\", `AND COLNAME = ${wrapSingleQuote(attributeName)}`, `AND TABNAME = ${tableName};`].join(\" \");\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return _.template(\"ALTER TABLE <%= table %> DROP <%= key %>\", this._templateSettings)({\n      table: this.quoteTable(tableName),\n      key: this.quoteIdentifier(foreignKey)\n    });\n  }\n  dropConstraintQuery(tableName, constraintName) {\n    const sql = \"ALTER TABLE <%= table %> DROP CONSTRAINT <%= constraint %>;\";\n    return _.template(sql, this._templateSettings)({\n      table: this.quoteTable(tableName),\n      constraint: this.quoteIdentifier(constraintName)\n    });\n  }\n  setAutocommitQuery() {\n    return \"\";\n  }\n  setIsolationLevelQuery() {}\n  generateTransactionId() {\n    return randomBytes(10).toString(\"hex\");\n  }\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return \"BEGIN TRANSACTION;\";\n  }\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n    return \"COMMIT TRANSACTION;\";\n  }\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n    return \"ROLLBACK TRANSACTION;\";\n  }\n  addLimitAndOffset(options) {\n    const offset = options.offset || 0;\n    let fragment = \"\";\n    if (offset > 0) {\n      fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n    }\n    if (options.limit) {\n      fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n    }\n    return fragment;\n  }\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n  addUniqueFields(dataValues, rawAttributes, uniqno) {\n    uniqno = uniqno === void 0 ? 1 : uniqno;\n    for (const key in rawAttributes) {\n      if (rawAttributes[key].unique && dataValues[key] === void 0) {\n        if (rawAttributes[key].type instanceof DataTypes.DATE) {\n          dataValues[key] = Utils.now(\"db2\");\n        } else if (rawAttributes[key].type instanceof DataTypes.STRING) {\n          dataValues[key] = `unique${uniqno++}`;\n        } else if (rawAttributes[key].type instanceof DataTypes.INTEGER) {\n          dataValues[key] = uniqno++;\n        } else if (rawAttributes[key].type instanceof DataTypes.BOOLEAN) {\n          dataValues[key] = new DataTypes.BOOLEAN(false);\n        }\n      }\n    }\n    return uniqno;\n  }\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, '\"'), '\"');\n  }\n}\nfunction wrapSingleQuote(identifier) {\n  if (identifier) {\n    return `'${identifier}'`;\n  }\n  return \"\";\n}\nmodule.exports = Db2QueryGenerator;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;AAEA,MAAMA,IAAIC,QAAQ;AAClB,MAAMC,QAAQD,QAAQ;AACtB,MAAME,YAAYF,QAAQ;AAC1B,MAAMG,yBAAyBH,QAAQ;AACvC,MAAMI,cAAcJ,QAAQ,UAAUI;AACtC,MAAMC,KAAKL,QAAQ;AAGnB,MAAMM,uBAAuB,UAASC,YAAY;EAChD,MAAM,IAAIC,MAAM,eAAeD;AAAA;AAGjC,gCAAgCJ,uBAAuB;EACrDM,YAAYC,SAAS;IACnB,MAAMA;IAEN,KAAKC,cAAcC,iCAAK,KAAKD,cAAV;MAAA,CAAwBN,GAAGQ,SAAS;MAAA,CACpDR,GAAGS,YAAY;IAAA;IAClB,KAAKC,eAAe;EAAA;EAGtBC,aAAaC,QAAQ;IACnB,OAAO,CACL,iBACA,KAAKC,gBAAgBD,SACrB,KACAE,KAAK;EAAA;EAGTC,WAAWH,QAAQ;IAIjB,MAAMI,QAAQ,kCAAmCC,gBAAgBL,OAAOM;IACxE,MAAMC,MAAM;MAAEH;IAAA;IACdG,IAAIC,OAAO,CAAC;MAAEC,WAAW;MAASC,MAAM;IAAA,GACtC;MAAED,WAAW;MAASC,MAAM;IAAA;IAC9B,OAAOH;EAAA;EAGTI,mBAAmB;IACjB,OAAO;EAAA;EAMTC,eAAe;IACb,OAAO;EAAA;EAGTC,iBAAiBC,WAAWC,YAAYtB,SAAS;IAC/C,MAAMW,QAAQ;MACZY,cAAc;MACdC,cAAc;MACdC,UAAU;MACVC,kBAAkB;IAGpB,IAAIC,aAAa;IAEjB,WAAWC,QAAQN,YAAY;MAC7B,IAAIO,OAAOC,UAAUC,eAAeC,KAAKV,YAAYM,OAAO;QAC1D,IAAIK,WAAWX,WAAWM;QAC1B,IAAIM;QAEJ,IAAID,SAASE,SAAS,aAAa;UACjC,MAAMC,eAAeH,SAASC,MAAM;UACpC,IAAIE,gBAAgBA,aAAaC,SAAS,GAAG;YAC3C,MAAMC,cAAcF,aAAa,GAAGG,QAAQ,WAAW,IAAI1B;YAC3Dc,cAActC,EAAEmD,SAASd,iBAAiB,KAAKe,mBAAmB;cAChEC,OAAO,KAAKlC,gBAAgBa;cAC5BsB,SAAS,KAAKC,OAAON;cACrBO,QAAQ,KAAKrC,gBAAgBoB;YAAA;YAG/BK,WAAWG,aAAa;UAAA;QAAA;QAI5B,IAAI/C,EAAE8C,SAASF,UAAU,gBAAgB;UACvCV,YAAYuB,KAAKlB;UAEjB,IAAIvC,EAAE8C,SAASF,UAAU,eAAe;YAEtCC,QAAQD,SAASC,MAAM;YACvBT,QAAQqB,KAAK,GAAI,KAAKtC,gBAAgBoB,SAAWM,MAAM,GAAGK,QAAQ,eAAe;YACjFf,YAAYI,QAAQM,MAAM;UAAA,OACrB;YACLT,QAAQqB,KAAK,GAAI,KAAKtC,gBAAgBoB,SAAWK,SAASM,QAAQ,eAAe;UAAA;QAAA,WAE1ElD,EAAE8C,SAASF,UAAU,eAAe;UAE7CC,QAAQD,SAASC,MAAM;UACvBT,QAAQqB,KAAK,GAAG,KAAKtC,gBAAgBoB,SAASM,MAAM;UACpDV,YAAYI,QAAQM,MAAM;QAAA,OACrB;UACL,IAAIlC,WAAWA,QAAQ+C,YAAY;YACjC,WAAWC,QAAQhD,QAAQ+C,YAAY;cACrC,IAAI/C,QAAQ+C,WAAWC,MAAMC,OAAOd,SAASP,SACzC,CAAEvC,EAAE8C,SAASF,UAAU,aAC3B;gBACEA,YAAY;gBACZ;cAAA;YAAA;UAAA;UAINR,QAAQqB,KAAK,GAAG,KAAKtC,gBAAgBoB,SAASK;QAAA;MAAA;IAAA;IAMpD,MAAMiB,SAAS;QACXR,OAAO,KAAKS,WAAW9B;QACvBC,YAAYG,QAAQhB,KAAK;MAAA;MAE3B2C,WAAW7B,YAAY8B,IAAIC,MAAM;QAAE,OAAO,KAAK9C,gBAAgB8C;MAAA,GAAQ7C,KAAK;IAE9E,IAAIT,WAAWA,QAAQ+C,YAAY;MACjC1D,EAAEkE,KAAKvD,QAAQ+C,YAAY,CAACS,SAASC,cAAc;QACjD,IAAID,QAAQE,aAAa;UACvB,IAAI,CAACrE,EAAEsE,SAASF,YAAY;YAC1BA,YAAY,QAASpC,aAAemC,QAAQP,OAAOxC,KAAK;UAAA;UAE1DyC,OAAO5B,cAAc,gBAAgB,KAAKd,gBAAgBiD,sBAAsBD,QAAQP,OAAOI,IAAIO,SAAS,KAAKpD,gBAAgBoD,QAAQnD,KAAK;QAAA;MAAA;IAAA;IAKpJ,IAAI2C,SAASf,SAAS,GAAG;MACvBa,OAAO5B,cAAc,kBAAkB8B;IAAA;IAGzC,WAAWS,QAAQrC,aAAa;MAC9B,IAAIK,OAAOC,UAAUC,eAAeC,KAAKR,aAAaqC,OAAO;QAC3DX,OAAO5B,cAAc,kBAAmB,KAAKd,gBAAgBqD,UAAYrC,YAAYqC;MAAA;IAAA;IAGzF,OAAO,GAAGxE,EAAEmD,SAAS7B,OAAO,KAAK8B,mBAAmBS,QAAQrC,UAAYc;EAAA;EAI1EmC,mBAAmBzC,WAAWd,QAAQ;IACpC,IAAIO,MAAM,CACR,oEACA,kEACA,8DACA,sEACA,QACA,qBACA,kBAAkBF,gBAAgBS,YAClCZ,KAAK;IAEP,IAAIF,QAAQ;MACVO,OAAO,mBAAmBF,gBAAgBL;IAAA,OACrC;MACLO,OAAO;IAAA;IAGT,OAAO,GAAGA;EAAA;EAGZiD,iBAAiBC,QAAQC,OAAO;IAC9B,MAAMtD,QAAQ;IACd,OAAOtB,EAAEmD,SAAS7B,OAAO,KAAK8B,mBAAmB;MAC/CuB,QAAQ,KAAKb,WAAWa;MACxBC,OAAO,KAAKd,WAAWc;IAAA;EAAA;EAI3BC,kBAAkB;IAChB,OAAO;EAAA;EAGTC,iBAAiBzB,OAAO;IACtB,MAAMrB,YAAYqB,MAAMrB,aAAaqB;IAGrC,MAAM0B,aAAa1B,MAAMnC,UAAU,KAAK8D,UAAUC,OAAOC,SAASC;IAGlE,OAAO,kDAAkD5D,gBAAgBS,4BAA4BT,gBAAgBwD;EAAA;EAGvHK,eAAepD,WAAW;IACxB,MAAMV,QAAQ;IACd,MAAMuC,SAAS;MACbR,OAAO,KAAKS,WAAW9B;IAAA;IAGzB,OAAO,GAAGhC,EAAEmD,SAAS7B,OAAO,KAAK8B,mBAAmBS,QAAQrC;EAAA;EAG9D6D,eAAehC,OAAOiC,KAAK1C,UAAU;IACnCA,SAAS2B,QAAQe;IAEjB,MAAMhE,QAAQ;MACZiE,YAAYvF,EAAEmD,SAAS,gCAAgC,KAAKC,mBAAmB;QAC7EkC,KAAK,KAAKnE,gBAAgBmE;QAC1BE,YAAY,KAAKC,eAAe7C,UAAU;UACxC8C,SAAS;QAAA;MAAA;IAIf,OAAO1F,EAAEmD,SAAS7B,OAAO,KAAK8B,mBAAmB;MAC/CC,OAAO,KAAKS,WAAWT;MACvBkC;IAAA;EAAA;EAIJI,kBAAkB3D,WAAW4D,eAAe;IAC1C,MAAMtE,QAAQ;IACd,OAAOtB,EAAEmD,SAAS7B,OAAO,KAAK8B,mBAAmB;MAC/CpB,WAAW,KAAK8B,WAAW9B;MAC3B4D,eAAe,KAAKzE,gBAAgByE;IAAA;EAAA;EAIxCC,kBAAkB7D,WAAWC,YAAY;IACvC,MAAMX,QAAQ;IACd,MAAMwE,aAAa;MACjBC,mBAAmB;IAErB,WAAWH,iBAAiB3D,YAAY;MACtC,MAAM+D,YAAY/D,WAAW2D;MAC7B,IAAIK,OAAO,CAACD;MACZ,IAAIE,MAAMC,QAAQH,YAAY;QAC5BC,OAAOD;MAAA;MAET,SAASI,IAAI,GAAGA,IAAIH,KAAKjD,QAAQoD,KAAK;QACpC,MAAMZ,aAAaS,KAAKG;QACxB,IAAIZ,WAAW3C,MAAM,eAAe;UAClCkD,iBAAiBtC,KAAKzD,EAAEmD,SAAS,iEAAiE,KAAKC,mBAAmB;YACxHiD,QAAQ,KAAKlF,gBAAgB,GAAGyE;YAChCU,UAAU,KAAKnF,gBAAgByE;YAC/BJ,YAAYA,WAAWtC,QAAQ,qBAAqB;UAAA;QAAA,WAE7ClD,EAAEuG,WAAWf,YAAY,UAAU;UAC5CM,WAAWrC,KAAKzD,EAAEmD,SAAS,qCAAqC,KAAKC,mBAAmB;YACtFkD,UAAU,KAAKnF,gBAAgByE;YAC/BJ;UAAA;QAAA,OAEG;UACLM,WAAWrC,KAAKzD,EAAEmD,SAAS,yCAAyC,KAAKC,mBAAmB;YAC1FkD,UAAU,KAAKnF,gBAAgByE;YAC/BJ;UAAA;QAAA;MAAA;IAAA;IAMR,IAAIgB,aAAa;IACjB,IAAIV,WAAW9C,QAAQ;MACrBwD,cAAc,gBAAgBV,WAAW1E,KAAK;MAC9CoF,cAAcT,iBAAiB/C,SAAS,MAAM;IAAA;IAEhD,IAAI+C,iBAAiB/C,QAAQ;MAC3BwD,cAAc,kBAAkBT,iBAAiB3E,KAAK;IAAA;IAGxD,OAAOpB,EAAEmD,SAAS7B,OAAO,KAAK8B,mBAAmB;MAC/CpB,WAAW,KAAK8B,WAAW9B;MAC3BV,OAAOkF;IAAA;EAAA;EAIXC,kBAAkBzE,WAAW0E,YAAYzE,YAAY;IACnD,MAAMX,QAAQ;MACZqF,UAAUnE,OAAOoE,KAAK3E,YAAY;IAEpC,OAAOjC,EAAEmD,SAAS7B,OAAO,KAAK8B,mBAAmB;MAC/CpB,WAAW,KAAK8B,WAAW9B;MAC3B2C,QAAQ,KAAKxD,gBAAgBuF;MAC7B9B,OAAO,KAAKzD,gBAAgBwF;IAAA;EAAA;EAIhCE,mBAAmB7E,WAAWrB,SAAS;IACrCA,UAAUA,WAAW;IACrB,IAAIA,QAAQmG,YAAYnG,QAAQmG,SAAS3B,kBAAkB,WAAW;MAEpE,OAAOxE,QAAQmG;IAAA;IAEjB,MAAMC,oBAAoB,KAAKC,qBAAqBhF,WAAWrB;IAE/D,IAAI,OAAOqB,cAAc,UAAU;MACjCA,YAAY,KAAKiF,iBAAiBjF;IAAA,OAC7B;MACLA,YAAY,KAAK8B,WAAW9B;IAAA;IAG9B,OAAO,eAAeA,iBAAiB+E;EAAA;EAGzCG,gBAAgBlF,WAAWmF,iBAAiBxG,SAASsB,YAAY;IAC/DtB,UAAUA,WAAW;IACrBsB,aAAaA,cAAc;IAC3B,IAAIX,QAAQ;IACZ,IAAIX,QAAQyG,WAAW;MACrB9F,QAAQ;IAAA;IAEV,MAAM+F,aAAa;MACjBC,SAAS;MACTC,gBAAgB;MAChBC,aAAa;IAEf,IAAIC;IACJ,MAAMC,sBAAsB;IAE5B,IAAI/G,QAAQyG,WAAW;MACrBK,iBAAiB;IAAA;IAEnBzH,EAAE2H,QAAQR,iBAAiBS,iBAAiB;MAE1C,MAAMhE,SAASpB,OAAOoE,KAAKgB;MAC3B,MAAMC,YAAY5F,WAAW2B,OAAO;MACpC,IAAIA,OAAOZ,WAAW,KAAK6E,aAAaA,UAAUC,iBAAiBF,cAAchE,OAAO,QAAQ,MAAM;QACpG8D,oBAAoBjE,KAAK,IAAK,KAAKzC;QACnC;MAAA;MAIFhB,EAAE+H,OAAOH,eAAe,CAACI,OAAO1C,QAAQ;QACtC,IAAIiC,cAAcU,QAAQ3C,SAAS,IAAI;UACrC,IAAI0C,UAAU,QAAQ/F,WAAWqD,QAAQrD,WAAWqD,KAAKwC,eACvD;UAEFP,cAAc9D,KAAK6B;QAAA;MAAA;IAAA;IAIzB,IAAIoC,oBAAoB1E,SAAS,GAAG;MAClCwE,WAAW/D,KAAK,GAAG4D,qBAAuBK,oBAAoBtG,KAAK;IAAA;IAGrE,IAAImG,cAAcvE,SAAS,GAAG;MAC5BhD,EAAE2H,QAAQR,iBAAiBS,iBAAiB;QAC1CN,OAAO7D,KAAK,IACV8D,cAAcvD,IAAIsB,OAChB,KAAK/B,OAAOqE,cAActC,OAAO,QAAW;UAAEI,SAAS;QAAA,GAAYtE,KAAK;MAAA;MAE9EoG,WAAW/D,KAAKnC;IAAA;IAElB,MAAM4G,eAAe;MACnB7E,OAAO,KAAKS,WAAW9B;MACvBC,YAAYsF,cAAcvD,IAAIzB,QAC5B,KAAKpB,gBAAgBoB,OAAOnB,KAAK;MACnCkG;MACAa,QAAQV;IAAA;IAGV,MAAMW,iBAAiBpI,EAAEmD,SAASqE,WAAWpG,KAAK,MAAM,KAAKgC,mBAAmB8E;IAChF,OAAOE;EAAA;EAGTC,YAAYrG,WAAW4F,eAAeU,OAAO3H,SAASsB,YAAY;IAChE,MAAMR,MAAM,MAAM4G,YAAYrG,WAAW4F,eAAeU,OAAO3H,SAASsB;IACxEtB,UAAUA,WAAW;IACrBX,EAAEuI,SAAS5H,SAAS,KAAKA;IACzB,IAAK,CAAEA,QAAQ6H,OAAQ;MACrB/G,IAAIH,QAAQ,8BAA+BG,IAAIH;MAC/C,OAAOG;IAAA;IAGTmG,gBAAgB1H,MAAMuI,yBAAyBb,eAAejH,QAAQ+H,UAAU/H;IAEhF,MAAMgI,oBAAoB;IAC1B,MAAM9E,SAAS;IACf,MAAMnC,OAAO;IACb,MAAMkH,YAAYjI,QAAQiI,aAAa,KAAKA,UAAUlH;IAEtD,IAAIO,YAAY;MACdjC,EAAEkE,KAAKjC,YAAY,CAACsD,WAAWD,QAAQ;QACrCqD,kBAAkBrD,OAAOC;QACzB,IAAIA,UAAUhB,OAAO;UACnBoE,kBAAkBpD,UAAUhB,SAASgB;QAAA;MAAA;IAAA;IAK3C,WAAWD,OAAOsC,eAAe;MAC/B,MAAMI,QAAQJ,cAActC;MAE5B,IAAI0C,iBAAiB9H,MAAM2I,mBAAmBlI,QAAQiI,cAAc,OACpE;QACE/E,OAAOJ,KAAK,GAAG,KAAKtC,gBAAgBmE,QAAU,KAAK/B,OAAOyE,OAAOW,qBAAqBA,kBAAkBrD,QAAQ,QAAW;UAAEI,SAAS;QAAA;MAAA,OACjI;QACL7B,OAAOJ,KAAK,GAAG,KAAKtC,gBAAgBmE,QAAU,KAAKwD,OAAOd,OAAOW,qBAAqBA,kBAAkBrD,QAAQ,QAAW;UAAEI,SAAS;QAAA,GAAYkD;MAAA;IAAA;IAItJ,IAAItH;IACJ,MAAMyH,eAAe/I,EAAEuI,SAAS;MAAEK;IAAA,GAAajI;IAE/CW,QAAQ,yBAAyB,KAAKwC,WAAW9B,cAAc,KAAKgH,WAAWV,OAAOS,4BAA4B,KAAKxF,OAAO5C,QAAQ6H,yBAAyB3E,OAAOzC,KAAK;IAC3KE,QAAQ,8BAA+BA;IACvC,OAAO;MAAEA;MAAOI;IAAA;EAAA;EAGlBuH,YAAYjH,WAAWkH,cAAcC,cAAcb,OAAOc,OAAO;IAC/D,MAAMC,mBAAmB,KAAKvF,WAAW,GAAG9B;IAC5C,MAAMsH,mBAAmB,KAAKxF,WAAW,GAAG9B;IAC5C,MAAMuH,mBAAmB;IACzB,MAAMC,gBAAgB;IACtB,MAAMC,cAAc;IACpB,MAAMC,kBAAkB,KAAK5F,WAAW9B;IAGxC,WAAWsD,OAAO8D,MAAMO,eAAe;MACrC,IAAIP,MAAMO,cAAcrE,KAAKsE,YAAY;QACvCL,iBAAiB9F,KAAK2F,MAAMO,cAAcrE,KAAKf,SAASe;MAAA;MAE1D,IAAI8D,MAAMO,cAAcrE,KAAKuE,QAAQ;QACnCJ,YAAYhG,KAAK2F,MAAMO,cAAcrE,KAAKf,SAASe;MAAA;MAErD,IAAI8D,MAAMO,cAAcrE,KAAKwC,eAAe;QAC1C0B,cAAc/F,KAAK2F,MAAMO,cAAcrE,KAAKf,SAASe;MAAA;IAAA;IAKzD,WAAWwE,SAASV,MAAMW,UAAU;MAClC,IAAID,MAAMD,UAAUC,MAAMlG,QAAQ;QAChC,WAAWW,SAASuF,MAAMlG,QAAQ;UAChC,MAAMoG,YAAY,OAAOzF,UAAU,WAAWA,QAAQA,MAAM0F,QAAQ1F,MAAMgB;UAC1E,IAAIkE,YAAYxB,QAAQ+B,eAAe,MAAMZ,MAAMO,cAAcK,YAAY;YAC3EP,YAAYhG,KAAKuG;UAAA;QAAA;MAAA;IAAA;IAMzB,MAAME,aAAa1H,OAAOoE,KAAKuC;IAC/B,MAAMgB,aAAa3H,OAAOoE,KAAKsC;IAC/B,MAAMkB,mBAAmBD,WAAWnG,IAAIsB,OAAO,KAAKnE,gBAAgBmE,MAAMlE,KAAK;IAC/E,MAAMiJ,sBAAsBF,WAAWnG,IAAIsB,OAAO,KAAK/B,OAAO2F,aAAa5D,OAAOlE,KAAK;IACvF,MAAMkJ,mBAAmB,UAAUD;IACnC,IAAIE;IAGJ,MAAMC,UAAUlC,MAAMhI,GAAGmK,IAAIC,OAAOC,UAAU;MAC5C,IAAIC,QAAQ;MAIZ,WAAWtF,OAAOqF,QAAQ;QACxB,IAAI,CAACA,OAAOrF,MAAM;UAChBsF,QAAQ;UACR;QAAA;MAAA;MAGJ,OAAOA;IAAA;IAOT,MAAMC,iBAAiBC,SAAS;MAC9B,OAAOA,MAAM9G,IAAIsB,OAAO;QACtBA,MAAM,KAAKnE,gBAAgBmE;QAC3B,OAAO,GAAG+D,oBAAoB/D,SAASgE,oBAAoBhE;MAAA;IAAA;IAI/D,IAAIkF,QAAQxH,WAAW,GAAG;MACxB,MAAM,IAAIvC,MAAM;IAAA,OACX;MAEL,WAAW6E,OAAOkF,SAAS;QACzB,MAAM5D,OAAOpE,OAAOoE,KAAK4D,QAAQlF;QACjC,IAAIiE,iBAAiBtB,QAAQrB,KAAK,QAAQ,IAAI;UAC5C2D,gBAAgBM,eAAetB,kBAAkBnI,KAAK;UACtD;QAAA;MAAA;MAGJ,IAAI,CAACmJ,eAAe;QAClBA,gBAAgBM,eAAepB,aAAarI,KAAK;MAAA;IAAA;IAKrD,MAAM2J,wBAAwBb,WAAWQ,OAAOpF,OAAO;MACrD,IAAIkE,cAAcvB,QAAQ3C,SAAS,IAAI;QACrC,OAAO;MAAA;MAET,OAAO;IAAA,GAENtB,IAAIsB,OAAO;MACV,MAAM0C,QAAQ,KAAKzE,OAAO4F,aAAa7D;MACvCA,MAAM,KAAKnE,gBAAgBmE;MAC3B,OAAO,GAAG+D,oBAAoB/D,SAAS0C;IAAA,GACtC5G,KAAK;IACV,MAAM4J,gBAAgBD,sBAAsB/H,SAAS,IAAI,gCAAgC+H,0BAA0B;IAEnH,MAAME,gBAAgB,IAAIb,4BAA4BC;IAEtD,IAAI/I,QAAQ,cAAcoI,sBAAsBL,2BAA2BiB,wBAAwBhB,oBAAoBc,wBAAwBG;IAC/IjJ,SAAS,IAAI0J,8CAA8CC;IAC3D,OAAO3J;EAAA;EAGT4J,mBAAmBlJ,WAAW;IAC5B,OAAO,kBAAkB,KAAK8B,WAAW9B;EAAA;EAG3CmJ,YAAYnJ,WAAWsG,OAA4B;IAAA,IAArB3H,8EAAU;IAAA,IAAIyI;IAC1C,MAAM/F,QAAQ,KAAKS,WAAW9B;IAC9B,MAAMV,QAAQ;IAEdgH,QAAQ,KAAK8C,mBAAmB9C,OAAO,MAAMc,OAAOzI;IAEpD,IAAI6H,QAAQ;IAEZ,IAAI7H,QAAQ0K,SAAS,GAAG;MACtB7C,QAAQ,WAAY,KAAKjF,OAAO5C,QAAQ0K;IAAA;IAE1C,IAAI1K,QAAQ6H,OAAO;MACjBA,SAAS,eAAgB,KAAKjF,OAAO5C,QAAQ6H;IAAA;IAG/C,MAAMN,eAAe;MACnBM;MACAnF;MACAiF;IAAA;IAGF,IAAIJ,aAAaI,OAAO;MACtBJ,aAAaI,QAAQ,UAAUJ,aAAaI;IAAA;IAG9C,OAAOtI,EAAEmD,SAAS7B,OAAO,KAAK8B,mBAAmB8E;EAAA;EAGnDoD,iBAAiBtJ,WAAW;IAC1B,IAAIP,MAAM;IACV,IAAIP,SAAS;IACb,IAAIlB,EAAEuL,SAASvJ,YAAY;MACzBd,SAASc,UAAUd;MACnBc,YAAYA,UAAUA;IAAA;IAExB,IAAId,QAAQ;MACVO,MAAM,GAAGA;IAAA;IAEXA,MAAM,GAAGA;IACT,OAAOzB,EAAEmD,SAAS1B,KAAK,KAAK2B,mBAAmB;MAC7CpB,WAAWT,gBAAgBS;MAC3B+C,YAAYxD,gBAAgBL;IAAA;EAAA;EAIhCsK,qBAAqBxJ,WAAWyJ,gBAAgB;IAC9C,IAAIhK,MAAM,uIAAuIO;IAEjJ,IAAIyJ,gBAAgB;MAClBhK,OAAO,yBAAyBgK;IAAA;IAGlC,OAAO,GAAGhK;EAAA;EAGZiK,iBAAiB1J,WAAW2J,uBAAuB;IACjD,MAAMlK,MAAM;IACZ,IAAI2C,YAAYuH;IAEhB,IAAI,OAAOvH,cAAc,UAAU;MACjCA,YAAYlE,MAAM0L,WAAW,GAAG5J,aAAa2J,sBAAsBvK,KAAK;IAAA;IAG1E,MAAMyC,SAAS;MACb7B,WAAW,KAAKiF,iBAAiBjF;MACjCoC,WAAW,KAAK6C,iBAAiB7C;IAAA;IAGnC,OAAOpE,EAAEmD,SAAS1B,KAAK,KAAK2B,mBAAmBS;EAAA;EAGjD4B,eAAeF,WAAW5E,SAAS;IACjC,IAAI,CAACX,EAAE6L,cAActG,YAAY;MAC/BA,YAAY;QACVuG,MAAMvG;MAAA;IAAA;IAIV,IAAIpC;IACJ,IAAI4I,aAAa;IAEjB,IAAIxG,UAAUuG,gBAAgB3L,UAAU6L,MAAM;MAC5C,IAAIzG,UAAUuG,KAAKjI,UAAU,CAAC0B,UAAU1B,QAAQ0B,UAAU1B,SAAS0B,UAAUuG,KAAKjI;MAGlFV,WAAWoC,UAAUuG,KAAKG;MAC1B9I,YAAY,WAAW,KAAKhC,gBAAgBoE,UAAUhB,aAAagB,UAAU1B,OAAOG,IAAIgE,SAAS;QAC/F,OAAO,KAAKzE,OAAOyE;MAAA,GAClB5G,KAAK;IAAA,OACH;MACL+B,WAAWoC,UAAUuG,KAAKI;IAAA;IAG5B,IAAIvL,WAAWA,QAAQ+E,YAAY,kBAAkBH,UAAUuG,MAAM;MACnE3I,WAAW,aAAaA;IAAA,WAEjBoC,UAAU4G,cAAc,SAAS5G,UAAUqE,eAAe,QAC1DrE,UAAUsE,QAAQ;MACzB1G,YAAY;MACZ4I,aAAa;IAAA;IAGf,IAAIxG,UAAUuC,eAAe;MAC3B,IAAIsE,eAAe;MACnB,IAAI7G,UAAU8G,sBAAsB;QAClCD,eAAe7G,UAAU8G;MAAA;MAE3BlJ,YAAY,gDAAgDiJ;IAAA;IAI9D,IAAI7G,UAAUuG,SAAS,UAAUvG,UAAUuG,KAAKQ,YAAY,QACxDpM,MAAMqM,sBAAsBhH,UAAUiH,eAAe;MACvDrJ,YAAY,YAAY,KAAKI,OAAOgC,UAAUiH;IAAA;IAGhD,IAAIjH,UAAUsE,WAAW,MAAM;MAC7B1G,YAAY;IAAA;IAGd,IAAIoC,UAAUqE,YAAY;MACxBzG,YAAY;IAAA;IAGd,IAAK,EAACxC,WAAW,CAACA,QAAQ8L,iCAAiClH,UAAUmH,YAAY;MAC/E,IAAI/L,WAAWA,QAAQ+E,YAAY,eAAe/E,QAAQgM,YAAY;QACpE,MAAMrG,WAAW,KAAKnF,gBAAgBR,QAAQgM;QAC9C,MAAMtG,SAAS,GAAG1F,QAAQqB,aAAesE;QACzCnD,YAAY,gBAAiBkD,uBAAyBC;MAAA;MAExDnD,YAAY,eAAe,KAAKW,WAAWyB,UAAUmH,WAAWtD;MAEhE,IAAI7D,UAAUmH,WAAWpH,KAAK;QAC5BnC,YAAY,KAAM,KAAKhC,gBAAgBoE,UAAUmH,WAAWpH;MAAA,OACvD;QACLnC,YAAY,KAAM,KAAKhC,gBAAgB;MAAA;MAGzC,IAAIoE,UAAUqH,UAAU;QACtBzJ,YAAY,cAAeoC,UAAUqH,SAASzH;MAAA;MAGhD,IAAII,UAAUuB,YAAYvB,UAAUuB,SAAS3B,iBAAiB,WAAW;QAEvEhC,YAAY,cAAeoC,UAAUuB,SAAS3B;MAAA;IAAA;IAIlD,IAAIxE,WAAWA,QAAQ+E,YAAY,kBAAkBqG,eAAe,KAChExG,UAAU4G,cAAc,QAAW;MACrChJ,WAAW,CAACA;MACZ,IAAIoC,UAAU4G,WAAW;QACvBhJ,SAASM,KAAK;MAAA,OACT;QACLN,SAASM,KAAK;MAAA;IAAA;IAIlB,IAAI8B,UAAUjC,WAAW,OAAOiC,UAAUjC,YAAY,UAAU;MAC9DH,YAAY,YAAYoC,UAAUjC;IAAA;IAGpC,OAAOH;EAAA;EAGT0J,gBAAgB5K,YAAYtB,SAAS;IACnC,MAAMmM,SAAS;MACbC,sBAAsB;IACxB,IAAIzH,KACFC;IAEF,KAAKD,OAAOrD,YAAY;MACtBsD,YAAYtD,WAAWqD;MAEvB,IAAIC,UAAUmH,YAAY;QAExB,IAAIK,oBAAoB9E,QAAQ1C,UAAUmH,WAAWtD,MAAM8C,gBAAgB,IAAI;UAE7E3G,UAAUqH,WAAW;UACrBrH,UAAUuB,WAAW;QAAA,WACZvB,UAAUsE,UAAUtE,UAAUsE,WAAW,MAAM;UACxDtE,UAAUqH,WAAW;UACrBrH,UAAUuB,WAAW;QAAA,OAChB;UACLiG,oBAAoBtJ,KAAK8B,UAAUmH,WAAWtD,MAAM8C;QAAA;MAAA;MAIxD,IAAI5G,OAAO,CAACC,UAAUhB,SAAS,OAAOgB,cAAc,UAAUA,UAAUhB,QAAQe;MAChFwH,OAAOvH,UAAUhB,SAASe,OAAO,KAAKG,eAAeF,WAAW5E;IAAA;IAGlE,OAAOmM;EAAA;EAGTE,gBAAgB;IACdzM,qBAAqB;EAAA;EAGvB0M,cAAc;IACZ1M,qBAAqB;EAAA;EAGvB2M,gBAAgB;IACd3M,qBAAqB;EAAA;EAGvB4M,iBAAiB;IACf5M,qBAAqB;EAAA;EAGvB6M,eAAe;IACb7M,qBAAqB;EAAA;EAGvB8M,iBAAiB;IACf9M,qBAAqB;EAAA;EASvB+M,wBAAwBC,WAAW;IACjC,OAAO,ueAU0BA;EAAA;EAWnCC,oBAAoBnK,OAAO0B,YAAY;IACrC,MAAM/C,YAAYqB,MAAMrB,aAAaqB;IACrC0B,aAAa1B,MAAMnC,UAAU6D;IAC7B,IAAItD,MAAM;IACV,IAAIO,WAAW;MACbP,MAAM,oBAAoBF,gBAAgBS;IAAA;IAE5C,IAAI+C,YAAY;MACdtD,OAAO,sBAAsBF,gBAAgBwD;IAAA;IAE/C,OAAO,KAAKuI,wBAAwB7L;EAAA;EAGtCgM,mBAAmBpK,OAAOqK,YAAY;IACpC,MAAM1L,YAAYqB,MAAMrB,aAAaqB;IACrC,MAAM0B,aAAa1B,MAAMnC;IACzB,IAAIO,MAAM;IACV,IAAIO,WAAW;MACbP,MAAM,oBAAoBF,gBAAgBS;IAAA;IAE5C,IAAI+C,YAAY;MACdtD,OAAO,sBAAsBF,gBAAgBwD;IAAA;IAE/C,IAAI2I,YAAY;MACdjM,OAAO,oBAAoBF,gBAAgBmM;IAAA;IAE7C,OAAO,KAAKJ,wBAAwB7L;EAAA;EAGtCkM,6BAA6BtK,OAAOuC,eAAe;IACjD,MAAM5D,YAAYT,gBAAgB8B,MAAMrB,aAAaqB;IACrD,OAAO,CACL,kCACA,4BACA,iCACA,qDACA,iBAAiB9B,gBAAgBqE,kBACjC,iBAAiB5D,cACjBZ,KAAK;EAAA;EAGTwM,oBAAoB5L,WAAW2K,YAAY;IACzC,OAAO3M,EAAEmD,SAAS,4CAA4C,KAAKC,mBAAmB;MACpFC,OAAO,KAAKS,WAAW9B;MACvBsD,KAAK,KAAKnE,gBAAgBwL;IAAA;EAAA;EAI9BkB,oBAAoB7L,WAAWyJ,gBAAgB;IAC7C,MAAMhK,MAAM;IACZ,OAAOzB,EAAEmD,SAAS1B,KAAK,KAAK2B,mBAAmB;MAC7CC,OAAO,KAAKS,WAAW9B;MACvB8L,YAAY,KAAK3M,gBAAgBsK;IAAA;EAAA;EAIrCsC,qBAAqB;IACnB,OAAO;EAAA;EAGTC,yBAAyB;EAIzBC,wBAAwB;IACtB,OAAO5N,YAAY,IAAI6L,SAAS;EAAA;EAGlCgC,sBAAsBC,aAAa;IACjC,IAAIA,YAAYC,QAAQ;MACtB,OAAO,oBAAoB,KAAKjN,gBAAgBgN,YAAYlE;IAAA;IAG9D,OAAO;EAAA;EAGToE,uBAAuBF,aAAa;IAClC,IAAIA,YAAYC,QAAQ;MACtB;IAAA;IAGF,OAAO;EAAA;EAGTE,yBAAyBH,aAAa;IACpC,IAAIA,YAAYC,QAAQ;MACtB,OAAO,wBAAwB,KAAKjN,gBAAgBgN,YAAYlE;IAAA;IAGlE,OAAO;EAAA;EAGTsE,kBAAkB5N,SAAS;IACzB,MAAM0K,SAAS1K,QAAQ0K,UAAU;IACjC,IAAImD,WAAW;IAEf,IAAInD,SAAS,GAAG;MACdmD,YAAY,WAAY,KAAKjL,OAAO8H;IAAA;IAGtC,IAAI1K,QAAQ6H,OAAO;MACjBgG,YAAY,eAAgB,KAAKjL,OAAO5C,QAAQ6H;IAAA;IAGlD,OAAOgG;EAAA;EAGTC,aAAazG,OAAO;IAClB,OAAOA,QAAQ,IAAI;EAAA;EAGrB0G,gBAAgBC,YAAYhF,eAAeiF,QAAQ;IACjDA,SAASA,WAAW,SAAY,IAAIA;IACpC,WAAWtJ,OAAOqE,eAAe;MAC/B,IAAIA,cAAcrE,KAAKuE,UAAU8E,WAAWrJ,SAAS,QAAW;QAC9D,IAAIqE,cAAcrE,KAAKwG,gBAAgB3L,UAAU0O,MAAM;UACrDF,WAAWrJ,OAAOpF,MAAM4O,IAAI;QAAA,WACnBnF,cAAcrE,KAAKwG,gBAAgB3L,UAAU4O,QAAQ;UAC9DJ,WAAWrJ,OAAO,SAASsJ;QAAA,WAClBjF,cAAcrE,KAAKwG,gBAAgB3L,UAAU6O,SAAS;UAC/DL,WAAWrJ,OAAOsJ;QAAA,WACTjF,cAAcrE,KAAKwG,gBAAgB3L,UAAU8O,SAAS;UAC/DN,WAAWrJ,OAAO,IAAInF,UAAU8O,QAAQ;QAAA;MAAA;IAAA;IAI9C,OAAOL;EAAA;EAWTzN,gBAAgB+N,YAAYC,OAAO;IACjC,OAAOjP,MAAMkP,SAASlP,MAAMmP,YAAYH,YAAY,MAAM;EAAA;AAAA;AAM9D,yBAAyBA,YAAY;EACnC,IAAIA,YAAY;IACd,OAAO,IAAKA;EAAA;EAGd,OAAO;AAAA;AAGTI,OAAOC,UAAUC","names":["_","require","Utils","DataTypes","AbstractQueryGenerator","randomBytes","Op","throwMethodUndefined","methodName","Error","constructor","options","OperatorMap","__spreadProps","regexp","notRegexp","autoGenValue","createSchema","schema","quoteIdentifier","join","dropSchema","query","wrapSingleQuote","trim","sql","bind","ParamType","Data","showSchemasQuery","versionQuery","createTableQuery","tableName","attributes","primaryKeys","foreignKeys","attrStr","commentTemplate","commentStr","attr","Object","prototype","hasOwnProperty","call","dataType","match","includes","commentMatch","length","commentText","replace","template","_templateSettings","table","comment","escape","column","push","uniqueKeys","ukey","fields","values","quoteTable","pkString","map","pk","each","columns","indexName","customIndex","isString","field","fkey","describeTableQuery","renameTableQuery","before","after","showTablesQuery","tableExistsQuery","schemaName","sequelize","config","username","toUpperCase","dropTableQuery","addColumnQuery","key","attribute","definition","attributeToSQL","context","removeColumnQuery","attributeName","changeColumnQuery","attrString","constraintString","attrValue","defs","Array","isArray","i","fkName","attrName","startsWith","finalQuery","renameColumnQuery","attrBefore","newName","keys","addConstraintQuery","onUpdate","constraintSnippet","getConstraintSnippet","quoteIdentifiers","bulkInsertQuery","attrValueHashes","returning","emptyQuery","tuples","allAttributes","allQueries","outputFragment","valuesForEmptyQuery","forEach","attrValueHash","firstAttr","autoIncrement","forOwn","value","indexOf","replacements","output","generatedQuery","updateQuery","where","defaults","limit","removeNullValuesFromHash","omitNull","modelAttributeMap","bindParam","SequelizeMethod","format","whereOptions","whereQuery","upsertQuery","insertValues","updateValues","model","targetTableAlias","sourceTableAlias","primaryKeysAttrs","identityAttrs","uniqueAttrs","tableNameQuoted","rawAttributes","primaryKey","unique","index","_indexes","fieldName","name","updateKeys","insertKeys","insertKeysQuoted","insertValuesEscaped","sourceTableQuery","joinCondition","clauses","or","filter","clause","valid","getJoinSnippet","array","filteredUpdateClauses","updateSnippet","insertSnippet","truncateTableQuery","deleteQuery","getWhereConditions","offset","showIndexesQuery","isObject","showConstraintsQuery","constraintName","removeIndexQuery","indexNameOrAttributes","underscore","isPlainObject","type","changeNull","ENUM","toSql","toString","allowNull","initialValue","initialAutoIncrement","_binary","defaultValueSchemable","defaultValue","withoutForeignKeyConstraints","references","foreignKey","onDelete","attributesToSQL","result","existingConstraints","createTrigger","dropTrigger","renameTrigger","createFunction","dropFunction","renameFunction","_getForeignKeysQuerySQL","condition","getForeignKeysQuery","getForeignKeyQuery","columnName","getPrimaryKeyConstraintQuery","dropForeignKeyQuery","dropConstraintQuery","constraint","setAutocommitQuery","setIsolationLevelQuery","generateTransactionId","startTransactionQuery","transaction","parent","commitTransactionQuery","rollbackTransactionQuery","addLimitAndOffset","fragment","booleanValue","addUniqueFields","dataValues","uniqno","DATE","now","STRING","INTEGER","BOOLEAN","identifier","force","addTicks","removeTicks","module","exports","Db2QueryGenerator"],"sources":["C:\\Users\\rizla\\projects\\react\\NSBEHack-main\\nsbeapp\\node_modules\\sequelize\\src\\dialects\\db2\\query-generator.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst DataTypes = require('../../data-types');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst randomBytes = require('crypto').randomBytes;\nconst Op = require('../../operators');\n\n/* istanbul ignore next */\nconst throwMethodUndefined = function(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n};\n\nclass Db2QueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n\n    this.OperatorMap = { ...this.OperatorMap, [Op.regexp]: 'REGEXP_LIKE',\n      [Op.notRegexp]: 'NOT REGEXP_LIKE' };\n    this.autoGenValue = 1;\n  }\n\n  createSchema(schema) {\n    return [\n      'CREATE SCHEMA',\n      this.quoteIdentifier(schema),\n      ';'\n    ].join(' ');\n  }\n\n  dropSchema(schema) {\n    // DROP SCHEMA Can't drop schema if it is not empty.\n    // DROP SCHEMA Can't drop objects belonging to the schema\n    // So, call the admin procedure to drop schema.\n    const query = `CALL SYSPROC.ADMIN_DROP_SCHEMA(${ wrapSingleQuote(schema.trim()) }, NULL, ? , ?)`;\n    const sql = { query };\n    sql.bind = [{ ParamType: 'INOUT', Data: 'ERRORSCHEMA' },\n      { ParamType: 'INOUT', Data: 'ERRORTABLE' }];\n    return sql;\n  }\n\n  showSchemasQuery() {\n    return 'SELECT SCHEMANAME AS \"schema_name\" FROM SYSCAT.SCHEMATA WHERE ' +\n      \"(SCHEMANAME NOT LIKE 'SYS%') AND SCHEMANAME NOT IN ('NULLID', 'SQLJ', 'ERRORSCHEMA')\";\n  }\n\n\n\n  versionQuery() {\n    return 'select service_level as VERSION from TABLE (sysproc.env_get_inst_info()) as A';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    const query = 'CREATE TABLE <%= table %> (<%= attributes %>)',\n      primaryKeys = [],\n      foreignKeys = {},\n      attrStr = [],\n      commentTemplate = ' -- <%= comment %>, ' +\n          'TableName = <%= table %>, ColumnName = <%= column %>;';\n\n    let commentStr = '';\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n\n        if (dataType.includes('COMMENT ')) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          if (commentMatch && commentMatch.length > 2) {\n            const commentText = commentMatch[2].replace(/COMMENT/, '').trim();\n            commentStr += _.template(commentTemplate, this._templateSettings)({\n              table: this.quoteIdentifier(tableName),\n              comment: this.escape(commentText),\n              column: this.quoteIdentifier(attr)\n            });\n            // remove comment related substring from dataType\n            dataType = commentMatch[1];\n          }\n        }\n\n        if (_.includes(dataType, 'PRIMARY KEY')) {\n          primaryKeys.push(attr);\n\n          if (_.includes(dataType, 'REFERENCES')) {\n            // Db2 doesn't support inline REFERENCES declarations: move to the end\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attrStr.push(`${ this.quoteIdentifier(attr) } ${ match[1].replace(/PRIMARY KEY/, '') }`);\n            foreignKeys[attr] = match[2];\n          } else {\n            attrStr.push(`${ this.quoteIdentifier(attr) } ${ dataType.replace(/PRIMARY KEY/, '') }`);\n          }\n        } else if (_.includes(dataType, 'REFERENCES')) {\n          // Db2 doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          if (options && options.uniqueKeys) {\n            for (const ukey in options.uniqueKeys) {\n              if (options.uniqueKeys[ukey].fields.includes(attr) &&\n                  ! _.includes(dataType, 'NOT NULL'))\n              {\n                dataType += ' NOT NULL';\n                break;\n              }\n            }\n          }\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n        }\n\n      }\n    }\n\n    const values = {\n        table: this.quoteTable(tableName),\n        attributes: attrStr.join(', ')\n      },\n      pkString = primaryKeys.map(pk => { return this.quoteIdentifier(pk); }).join(', ');\n\n    if (options && options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (!_.isString(indexName)) {\n            indexName = `uniq_${ tableName }_${ columns.fields.join('_')}`;\n          }\n          values.attributes += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      values.attributes += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        values.attributes += `, FOREIGN KEY (${ this.quoteIdentifier(fkey) }) ${ foreignKeys[fkey] }`;\n      }\n    }\n    return `${_.template(query, this._templateSettings)(values).trim() };${ commentStr}`;\n  }\n\n\n  describeTableQuery(tableName, schema) {\n    let sql = [\n      'SELECT NAME AS \"Name\", TBNAME AS \"Table\", TBCREATOR AS \"Schema\",',\n      'TRIM(COLTYPE) AS \"Type\", LENGTH AS \"Length\", SCALE AS \"Scale\",',\n      'NULLS AS \"IsNull\", DEFAULT AS \"Default\", COLNO AS \"Colno\",',\n      'IDENTITY AS \"IsIdentity\", KEYSEQ AS \"KeySeq\", REMARKS AS \"Comment\"',\n      'FROM',\n      'SYSIBM.SYSCOLUMNS',\n      'WHERE TBNAME =', wrapSingleQuote(tableName)\n    ].join(' ');\n\n    if (schema) {\n      sql += ` AND TBCREATOR =${wrapSingleQuote(schema)}`;\n    } else {\n      sql += ' AND TBCREATOR = USER';\n    }\n\n    return `${sql};`;\n  }\n\n  renameTableQuery(before, after) {\n    const query = 'RENAME TABLE <%= before %> TO <%= after %>;';\n    return _.template(query, this._templateSettings)({\n      before: this.quoteTable(before),\n      after: this.quoteTable(after)\n    });\n  }\n\n  showTablesQuery() {\n    return \"SELECT TABNAME AS \\\"tableName\\\", TRIM(TABSCHEMA) AS \\\"tableSchema\\\" FROM SYSCAT.TABLES WHERE TABSCHEMA = USER AND TYPE = 'T' ORDER BY TABSCHEMA, TABNAME\";\n  }\n\n  tableExistsQuery(table) {\n    const tableName = table.tableName || table;\n    // The default schema is the authorization ID of the owner of the plan or package.\n    // https://www.ibm.com/docs/en/db2-for-zos/12?topic=concepts-db2-schemas-schema-qualifiers\n    const schemaName = table.schema || this.sequelize.config.username.toUpperCase();\n\n    // https://www.ibm.com/docs/en/db2-for-zos/11?topic=tables-systables\n    return `SELECT name FROM sysibm.systables WHERE NAME = ${wrapSingleQuote(tableName)} AND CREATOR = ${wrapSingleQuote(schemaName)}`;\n  }\n\n  dropTableQuery(tableName) {\n    const query = 'DROP TABLE <%= table %>';\n    const values = {\n      table: this.quoteTable(tableName)\n    };\n\n    return `${_.template(query, this._templateSettings)(values).trim()};`;\n  }\n\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n\n    const query = 'ALTER TABLE <%= table %> ADD <%= attribute %>;',\n      attribute = _.template('<%= key %> <%= definition %>', this._templateSettings)({\n        key: this.quoteIdentifier(key),\n        definition: this.attributeToSQL(dataType, {\n          context: 'addColumn'\n        })\n      });\n\n    return _.template(query, this._templateSettings)({\n      table: this.quoteTable(table),\n      attribute\n    });\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    const query = 'ALTER TABLE <%= tableName %> DROP COLUMN <%= attributeName %>;';\n    return _.template(query, this._templateSettings)({\n      tableName: this.quoteTable(tableName),\n      attributeName: this.quoteIdentifier(attributeName)\n    });\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const query = 'ALTER TABLE <%= tableName %> <%= query %>;';\n    const attrString = [],\n      constraintString = [];\n\n    for (const attributeName in attributes) {\n      const attrValue = attributes[attributeName];\n      let defs = [attrValue];\n      if (Array.isArray(attrValue)) {\n        defs = attrValue;\n      }\n      for (let i = 0; i < defs.length; i++) {\n        const definition = defs[i];\n        if (definition.match(/REFERENCES/)) {\n          constraintString.push(_.template('<%= fkName %> FOREIGN KEY (<%= attrName %>) <%= definition %>', this._templateSettings)({\n            fkName: this.quoteIdentifier(`${attributeName}_foreign_idx`),\n            attrName: this.quoteIdentifier(attributeName),\n            definition: definition.replace(/.+?(?=REFERENCES)/, '')\n          }));\n        } else if (_.startsWith(definition, 'DROP ')) {\n          attrString.push(_.template('<%= attrName %> <%= definition %>', this._templateSettings)({\n            attrName: this.quoteIdentifier(attributeName),\n            definition\n          }));\n        } else {\n          attrString.push(_.template('<%= attrName %> SET <%= definition %>', this._templateSettings)({\n            attrName: this.quoteIdentifier(attributeName),\n            definition\n          }));\n        }\n      }\n    }\n\n    let finalQuery = '';\n    if (attrString.length) {\n      finalQuery += `ALTER COLUMN ${attrString.join(' ALTER COLUMN ')}`;\n      finalQuery += constraintString.length ? ' ' : '';\n    }\n    if (constraintString.length) {\n      finalQuery += `ADD CONSTRAINT ${constraintString.join(' ADD CONSTRAINT ')}`;\n    }\n\n    return _.template(query, this._templateSettings)({\n      tableName: this.quoteTable(tableName),\n      query: finalQuery\n    });\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const query = 'ALTER TABLE <%= tableName %> RENAME COLUMN <%= before %> TO <%= after %>;',\n      newName = Object.keys(attributes)[0];\n\n    return _.template(query, this._templateSettings)({\n      tableName: this.quoteTable(tableName),\n      before: this.quoteIdentifier(attrBefore),\n      after: this.quoteIdentifier(newName)\n    });\n  }\n\n  addConstraintQuery(tableName, options) {\n    options = options || {};\n    if (options.onUpdate && options.onUpdate.toUpperCase() === 'CASCADE') {\n      // Db2 does not support ON UPDATE CASCADE, remove it.\n      delete options.onUpdate;\n    }\n    const constraintSnippet = this.getConstraintSnippet(tableName, options);\n\n    if (typeof tableName === 'string') {\n      tableName = this.quoteIdentifiers(tableName);\n    } else {\n      tableName = this.quoteTable(tableName);\n    }\n\n    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;\n  }\n\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    options = options || {};\n    attributes = attributes || {};\n    let query = 'INSERT INTO <%= table %> (<%= attributes %>)<%= output %> VALUES <%= tuples %>;';\n    if (options.returning) {\n      query = 'SELECT * FROM FINAL TABLE( INSERT INTO <%= table %> (<%= attributes %>)<%= output %> VALUES <%= tuples %>);';\n    }\n    const emptyQuery = 'INSERT INTO <%= table %>',\n      tuples = [],\n      allAttributes = [],\n      allQueries = [];\n\n    let outputFragment;\n    const valuesForEmptyQuery = [];\n\n    if (options.returning) {\n      outputFragment = '';\n    }\n    _.forEach(attrValueHashes, attrValueHash => {\n      // special case for empty objects with primary keys\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        valuesForEmptyQuery.push(`(${ this.autoGenValue++ })`);\n        return;\n      }\n\n      // normal case\n      _.forOwn(attrValueHash, (value, key) => {\n        if (allAttributes.indexOf(key) === -1) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement)\n            return;\n\n          allAttributes.push(key);\n        }\n      });\n    });\n    if (valuesForEmptyQuery.length > 0) {\n      allQueries.push(`${emptyQuery } VALUES ${ valuesForEmptyQuery.join(',')}`);\n    }\n\t\n    if (allAttributes.length > 0) {\n      _.forEach(attrValueHashes, attrValueHash => {\n        tuples.push(`(${\n          allAttributes.map(key =>\n            this.escape(attrValueHash[key]), undefined, { context: 'INSERT' }).join(',')})`);\n      });\n      allQueries.push(query);\n    }\n    const replacements = {\n      table: this.quoteTable(tableName),\n      attributes: allAttributes.map(attr =>\n        this.quoteIdentifier(attr)).join(','),\n      tuples,\n      output: outputFragment\n    };\n\n    const generatedQuery = _.template(allQueries.join(';'), this._templateSettings)(replacements);\n    return generatedQuery;\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n    options = options || {};\n    _.defaults(options, this.options);\n    if ( ! options.limit ) {\n      sql.query = `SELECT * FROM FINAL TABLE (${ sql.query });`;\n      return sql;\n    }\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false)\n      {\n        values.push(`${this.quoteIdentifier(key) }=${ this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key) }=${ this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);\n      }\n    }\n\n    let query;\n    const whereOptions = _.defaults({ bindParam }, options);\n\n    query = `UPDATE (SELECT * FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} FETCH NEXT ${this.escape(options.limit)} ROWS ONLY) SET ${values.join(',')}`;\n    query = `SELECT * FROM FINAL TABLE (${ query });`;\n    return { query, bind };\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n\n    //Obtain primaryKeys, uniquekeys and identity attrs from rawAttributes as model is not passed\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    }\n\n    //Add unique indexes defined by indexes option to uniqueAttrs\n    for (const index of model._indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === 'string' ? field : field.name || field.attribute;\n          if (uniqueAttrs.indexOf(fieldName) === -1 && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map(key => this.quoteIdentifier(key)).join(', ');\n    const insertValuesEscaped = insertKeys.map(key => this.escape(insertValues[key])).join(', ');\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`; //Virtual Table\n    let joinCondition;\n\n    //Filter NULL Clauses\n    const clauses = where[Op.or].filter(clause => {\n      let valid = true;\n      /*\n       * Exclude NULL Composite PK/UK. Partial Composite clauses should also be excluded as it doesn't guarantee a single row\n       */\n      for (const key in clause) {\n        if (!clause[key]) {\n          valid = false;\n          break;\n        }\n      }\n      return valid;\n    });\n\n    /*\n     * Generate ON condition using PK(s).\n     * If not, generate using UK(s). Else throw error\n     */\n    const getJoinSnippet = array => {\n      return array.map(key => {\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n\n    if (clauses.length === 0) {\n      throw new Error('Primary Key or Unique key should be passed to upsert query');\n    } else {\n      // Search for primary key attribute in clauses -- Model can have two separate unique keys\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n        if (primaryKeysAttrs.indexOf(keys[0]) !== -1) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(' AND ');\n          break;\n        }\n      }\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(' AND ');\n      }\n    }\n\n    // Remove the IDENTITY_INSERT Column from update\n    const filteredUpdateClauses = updateKeys.filter(key => {\n      if (identityAttrs.indexOf(key) === -1) {\n        return true;\n      }\n      return false;\n    })\n      .map(key => {\n        const value = this.escape(updateValues[key]);\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${value}`;\n      }).join(', ');\n    const updateSnippet = filteredUpdateClauses.length > 0 ? `WHEN MATCHED THEN UPDATE SET ${filteredUpdateClauses}` : '';\n\t\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n\t\n    let query = `MERGE INTO ${tableNameQuoted} AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet};`;\n    return query;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)} IMMEDIATE`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    const query = 'DELETE FROM <%= table %><%= where %><%= limit %>';\n\n    where = this.getWhereConditions(where, null, model, options);\n\n    let limit = '';\n\n    if (options.offset > 0) {\n      limit = ` OFFSET ${ this.escape(options.offset) } ROWS`;\n    }\n    if (options.limit) {\n      limit += ` FETCH NEXT ${ this.escape(options.limit) } ROWS ONLY`;\n    }\n\n    const replacements = {\n      limit,\n      table,\n      where\n    };\n\n    if (replacements.where) {\n      replacements.where = ` WHERE ${replacements.where}`;\n    }\n\n    return _.template(query, this._templateSettings)(replacements);\n  }\n\n  showIndexesQuery(tableName) {\n    let sql = 'SELECT NAME AS \"name\", TBNAME AS \"tableName\", UNIQUERULE AS \"keyType\", COLNAMES, INDEXTYPE AS \"type\" FROM SYSIBM.SYSINDEXES WHERE TBNAME = <%= tableName %>';\n    let schema = undefined;\n    if (_.isObject(tableName)) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n    if (schema) {\n      sql = `${sql} AND TBCREATOR = <%= schemaName %>`;\n    }\n    sql = `${sql} ORDER BY NAME;`;\n    return _.template(sql, this._templateSettings)({\n      tableName: wrapSingleQuote(tableName),\n      schemaName: wrapSingleQuote(schema)\n    });\n  }\n\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT CONSTNAME AS \"constraintName\", TRIM(TABSCHEMA) AS \"schemaName\", TABNAME AS \"tableName\" FROM SYSCAT.TABCONST WHERE TABNAME = '${tableName}'`;\n\n    if (constraintName) {\n      sql += ` AND CONSTNAME LIKE '%${constraintName}%'`;\n    }\n\n    return `${sql } ORDER BY CONSTNAME;`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    const sql = 'DROP INDEX <%= indexName %>';\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    const values = {\n      tableName: this.quoteIdentifiers(tableName),\n      indexName: this.quoteIdentifiers(indexName)\n    };\n\n    return _.template(sql, this._templateSettings)(values);\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    let template;\n    let changeNull = 1;\n\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n\n      // enums are a special case\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map(value => {\n        return this.escape(value);\n      }).join(', ') }))`;\n    } else {\n      template = attribute.type.toString();\n    }\n\n    if (options && options.context === 'changeColumn' && attribute.type) {\n      template = `DATA TYPE ${template}`;\n    }\n    else if (attribute.allowNull === false || attribute.primaryKey === true ||\n             attribute.unique) {\n      template += ' NOT NULL';\n      changeNull = 0;\n    }\n\n    if (attribute.autoIncrement) {\n      let initialValue = 1;\n      if (attribute.initialAutoIncrement) {\n        initialValue = attribute.initialAutoIncrement;\n      }\n      template += ` GENERATED BY DEFAULT AS IDENTITY(START WITH ${initialValue}, INCREMENT BY 1)`;\n    }\n\n    // Blobs/texts cannot have a defaultValue\n    if (attribute.type !== 'TEXT' && attribute.type._binary !== true &&\n        Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      if (options && options.context === 'addColumn' && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = `${options.tableName }_${ attrName }_fidx`;\n        template += `, CONSTRAINT ${ fkName } FOREIGN KEY (${ attrName })`;\n      }\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${ this.quoteIdentifier(attribute.references.key) })`;\n      } else {\n        template += ` (${ this.quoteIdentifier('id') })`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${ attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate && attribute.onUpdate.toUpperCase() != 'CASCADE') {\n        // Db2 do not support CASCADE option for ON UPDATE clause.\n        template += ` ON UPDATE ${ attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    if (options && options.context === 'changeColumn' && changeNull === 1 &&\n        attribute.allowNull !== undefined) {\n      template = [template];\n      if (attribute.allowNull) {\n        template.push('DROP NOT NULL');\n      } else {\n        template.push('NOT NULL');\n      }\n    }\n\n    if (attribute.comment && typeof attribute.comment === 'string') {\n      template += ` COMMENT ${attribute.comment}`;\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {},\n      existingConstraints = [];\n    let key,\n      attribute;\n\n    for (key in attributes) {\n      attribute = attributes[key];\n\n      if (attribute.references) {\n\n        if (existingConstraints.indexOf(attribute.references.model.toString()) !== -1) {\n          // no cascading constraints to a table more than once\n          attribute.onDelete = '';\n          attribute.onUpdate = '';\n        } else if (attribute.unique && attribute.unique === true) {\n          attribute.onDelete = '';\n          attribute.onUpdate = '';\n        } else {\n          existingConstraints.push(attribute.references.model.toString());\n        }\n      }\n\n      if (key && !attribute.field && typeof attribute === 'object') attribute.field = key;\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  createTrigger() {\n    throwMethodUndefined('createTrigger');\n  }\n\n  dropTrigger() {\n    throwMethodUndefined('dropTrigger');\n  }\n\n  renameTrigger() {\n    throwMethodUndefined('renameTrigger');\n  }\n\n  createFunction() {\n    throwMethodUndefined('createFunction');\n  }\n\n  dropFunction() {\n    throwMethodUndefined('dropFunction');\n  }\n\n  renameFunction() {\n    throwMethodUndefined('renameFunction');\n  }\n\n  /**\n   * Generate SQL for ForeignKeysQuery.\n   *\n   * @param {string} condition   The condition string for query.\n   * @returns {string}\n   */\n  _getForeignKeysQuerySQL(condition) {\n    return 'SELECT R.CONSTNAME AS \"constraintName\", ' +\n        'TRIM(R.TABSCHEMA) AS \"constraintSchema\", ' +\n        'R.TABNAME AS \"tableName\", ' +\n        'TRIM(R.TABSCHEMA) AS \"tableSchema\", LISTAGG(C.COLNAME,\\', \\') ' +\n        'WITHIN GROUP (ORDER BY C.COLNAME) AS \"columnName\", ' +\n        'TRIM(R.REFTABSCHEMA) AS \"referencedTableSchema\", ' +\n        'R.REFTABNAME AS \"referencedTableName\", ' +\n        'TRIM(R.PK_COLNAMES) AS \"referencedColumnName\" ' +\n        'FROM SYSCAT.REFERENCES R, SYSCAT.KEYCOLUSE C ' +\n        'WHERE R.CONSTNAME = C.CONSTNAME AND R.TABSCHEMA = C.TABSCHEMA ' +\n        `AND R.TABNAME = C.TABNAME${ condition } GROUP BY R.REFTABSCHEMA, ` +\n        'R.REFTABNAME, R.TABSCHEMA, R.TABNAME, R.CONSTNAME, R.PK_COLNAMES';\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param {Stirng|object} table The name of the table.\n   * @param {string} schemaName   The name of the schema. \n   * @returns {string}            The generated sql query.\n   */\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    schemaName = table.schema || schemaName;\n    let sql = '';\n    if (tableName) {\n      sql = ` AND R.TABNAME = ${wrapSingleQuote(tableName)}`;\n    }\n    if (schemaName) {\n      sql += ` AND R.TABSCHEMA = ${wrapSingleQuote(schemaName)}`;\n    }\n    return this._getForeignKeysQuerySQL(sql);\n  }\n\n  getForeignKeyQuery(table, columnName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n    let sql = '';\n    if (tableName) {\n      sql = ` AND R.TABNAME = ${wrapSingleQuote(tableName)}`;\n    }\n    if (schemaName) {\n      sql += ` AND R.TABSCHEMA = ${wrapSingleQuote(schemaName)}`;\n    }\n    if (columnName) {\n      sql += ` AND C.COLNAME = ${wrapSingleQuote(columnName)}`;\n    }\n    return this._getForeignKeysQuerySQL(sql);\n  }\n\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n    return [\n      'SELECT TABNAME AS \"tableName\",',\n      'COLNAME AS \"columnName\",',\n      'CONSTNAME AS \"constraintName\"',\n      'FROM SYSCAT.KEYCOLUSE WHERE CONSTNAME LIKE \\'PK_%\\'',\n      `AND COLNAME = ${wrapSingleQuote(attributeName)}`,\n      `AND TABNAME = ${tableName};`\n    ].join(' ');\n  }\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return _.template('ALTER TABLE <%= table %> DROP <%= key %>', this._templateSettings)({\n      table: this.quoteTable(tableName),\n      key: this.quoteIdentifier(foreignKey)\n    });\n  }\n\n  dropConstraintQuery(tableName, constraintName) {\n    const sql = 'ALTER TABLE <%= table %> DROP CONSTRAINT <%= constraint %>;';\n    return _.template(sql, this._templateSettings)({\n      table: this.quoteTable(tableName),\n      constraint: this.quoteIdentifier(constraintName)\n    });\n  }\n\n  setAutocommitQuery() {\n    return '';\n  }\n\n  setIsolationLevelQuery() {\n\n  }\n\n  generateTransactionId() {\n    return randomBytes(10).toString('hex');\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return 'BEGIN TRANSACTION;';\n  }\n\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return 'COMMIT TRANSACTION;';\n  }\n\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return 'ROLLBACK TRANSACTION;';\n  }\n\n  addLimitAndOffset(options) {\n    const offset = options.offset || 0;\n    let fragment = '';\n\n    if (offset > 0) {\n      fragment += ` OFFSET ${ this.escape(offset) } ROWS`;\n    }\n\n    if (options.limit) {\n      fragment += ` FETCH NEXT ${ this.escape(options.limit) } ROWS ONLY`;\n    }\n\n    return fragment;\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  addUniqueFields(dataValues, rawAttributes, uniqno) {\n    uniqno = uniqno === undefined ? 1 : uniqno;\n    for (const key in rawAttributes) {\n      if (rawAttributes[key].unique && dataValues[key] === undefined) {\n        if (rawAttributes[key].type instanceof DataTypes.DATE) {\n          dataValues[key] = Utils.now('db2');\n        } else if (rawAttributes[key].type instanceof DataTypes.STRING) {\n          dataValues[key] = `unique${uniqno++}`;\n        } else if (rawAttributes[key].type instanceof DataTypes.INTEGER) {\n          dataValues[key] = uniqno++;\n        } else if (rawAttributes[key].type instanceof DataTypes.BOOLEAN) {\n          dataValues[key] = new DataTypes.BOOLEAN(false);\n        }\n      }\n    }\n    return uniqno;\n  }\n\n  /**\n   * Quote identifier in sql clause\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    return Utils.addTicks(Utils.removeTicks(identifier, '\"'), '\"');\n  }\n\n}\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  if (identifier) {\n    return `'${ identifier }'`;\n    //return Utils.addTicks(\"'\"); // It removes quote from center too.\n  }\n  return '';\n}\n\nmodule.exports = Db2QueryGenerator;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}