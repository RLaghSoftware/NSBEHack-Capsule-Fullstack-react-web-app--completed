{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nconst Utils = require(\"./../utils\");\nconst Helpers = require(\"./helpers\");\nconst _ = require(\"lodash\");\nconst Association = require(\"./base\");\nconst Op = require(\"../operators\");\nclass BelongsTo extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    this.associationType = \"BelongsTo\";\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize([this.as, this.target.primaryKeyAttribute].join(\"_\"));\n    }\n    this.identifier = this.foreignKey;\n    if (this.source.rawAttributes[this.identifier]) {\n      this.identifierField = this.source.rawAttributes[this.identifier].field || this.identifier;\n    }\n    if (this.options.targetKey && !this.target.rawAttributes[this.options.targetKey]) {\n      throw new Error(`Unknown attribute \"${this.options.targetKey}\" passed as targetKey, define this attribute on model \"${this.target.name}\" first`);\n    }\n    this.targetKey = this.options.targetKey || this.target.primaryKeyAttribute;\n    this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    this.targetKeyIsPrimary = this.targetKey === this.target.primaryKeyAttribute;\n    this.targetIdentifier = this.targetKey;\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n    const singular = _.upperFirst(this.options.name.singular);\n    this.accessors = {\n      get: `get${singular}`,\n      set: `set${singular}`,\n      create: `create${singular}`\n    };\n  }\n  _injectAttributes() {\n    const newAttributes = {\n      [this.foreignKey]: __spreadValues({\n        type: this.options.keyType || this.target.rawAttributes[this.targetKey].type,\n        allowNull: true\n      }, this.foreignKeyAttribute)\n    };\n    if (this.options.constraints !== false) {\n      const source = this.source.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (source.allowNull ? \"SET NULL\" : \"NO ACTION\");\n      this.options.onUpdate = this.options.onUpdate || \"CASCADE\";\n    }\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.target, this.source, this.options, this.targetKeyField);\n    Utils.mergeDefaults(this.source.rawAttributes, newAttributes);\n    this.source.refreshAttributes();\n    this.identifierField = this.source.rawAttributes[this.foreignKey].field || this.foreignKey;\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n  mixin(obj) {\n    const methods = [\"get\", \"set\", \"create\"];\n    Helpers.mixinMethods(this, obj, methods);\n  }\n  async get(instances, options) {\n    const where = {};\n    let Target = this.target;\n    let instance;\n    options = Utils.cloneDeep(options);\n    if (Object.prototype.hasOwnProperty.call(options, \"scope\")) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"schema\")) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = void 0;\n    }\n    if (instances) {\n      where[this.targetKey] = {\n        [Op.in]: instances.map(_instance => _instance.get(this.foreignKey))\n      };\n    } else {\n      if (this.targetKeyIsPrimary && !options.where) {\n        return Target.findByPk(instance.get(this.foreignKey), options);\n      }\n      where[this.targetKey] = instance.get(this.foreignKey);\n      options.limit = null;\n    }\n    options.where = options.where ? {\n      [Op.and]: [where, options.where]\n    } : where;\n    if (instances) {\n      const results = await Target.findAll(options);\n      const result = {};\n      for (const _instance of instances) {\n        result[_instance.get(this.foreignKey, {\n          raw: true\n        })] = null;\n      }\n      for (const _instance of results) {\n        result[_instance.get(this.targetKey, {\n          raw: true\n        })] = _instance;\n      }\n      return result;\n    }\n    return Target.findOne(options);\n  }\n  async set(sourceInstance, associatedInstance) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let value = associatedInstance;\n    if (associatedInstance instanceof this.target) {\n      value = associatedInstance[this.targetKey];\n    }\n    sourceInstance.set(this.foreignKey, value);\n    if (options.save === false) return;\n    options = __spreadValues({\n      fields: [this.foreignKey],\n      allowNull: [this.foreignKey],\n      association: true\n    }, options);\n    return await sourceInstance.save(options);\n  }\n  async create(sourceInstance, values, options) {\n    values = values || {};\n    options = options || {};\n    const newAssociatedObject = await this.target.create(values, options);\n    await sourceInstance[this.accessors.set](newAssociatedObject, options);\n    return newAssociatedObject;\n  }\n  verifyAssociationAlias(alias) {\n    if (typeof alias === \"string\") {\n      return this.as === alias;\n    }\n    if (alias && alias.singular) {\n      return this.as === alias.singular;\n    }\n    return !this.isAliased;\n  }\n}\nmodule.exports = BelongsTo;\nmodule.exports.BelongsTo = BelongsTo;\nmodule.exports.default = BelongsTo;","map":{"version":3,"mappings":"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","names":["Utils","require","Helpers","_","Association","Op","constructor","source","target","options","associationType","isSingleAssociation","foreignKeyAttribute","as","isAliased","name","singular","isObject","foreignKey","fieldName","camelize","primaryKeyAttribute","join","identifier","rawAttributes","identifierField","field","targetKey","Error","targetKeyField","targetKeyIsPrimary","targetIdentifier","associationAccessor","useHooks","upperFirst","accessors","get","set","create","_injectAttributes","newAttributes","__spreadValues","type","keyType","allowNull","constraints","onDelete","onUpdate","addForeignKeyConstraints","mergeDefaults","refreshAttributes","checkNamingCollision","mixin","obj","methods","mixinMethods","instances","where","Target","instance","cloneDeep","Object","prototype","hasOwnProperty","call","scope","unscoped","schema","schemaDelimiter","Array","isArray","in","map","_instance","findByPk","limit","and","results","findAll","result","raw","findOne","sourceInstance","associatedInstance","value","save","fields","association","values","newAssociatedObject","verifyAssociationAlias","alias","module","exports","BelongsTo","default"],"sources":["C:\\Users\\rizla\\projects\\react\\NSBEHack-main\\nsbeapp\\node_modules\\sequelize\\src\\associations\\belongs-to.js"],"sourcesContent":["'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst Op = require('../operators');\n\n/**\n * One-to-one association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.belongsTo(Project)` the getter will be `user.getProject()`.\n *\n * @see {@link Model.belongsTo}\n */\nclass BelongsTo extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    this.associationType = 'BelongsTo';\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize(\n        [\n          this.as,\n          this.target.primaryKeyAttribute\n        ].join('_')\n      );\n    }\n\n    this.identifier = this.foreignKey;\n    if (this.source.rawAttributes[this.identifier]) {\n      this.identifierField = this.source.rawAttributes[this.identifier].field || this.identifier;\n    }\n\n    if (\n      this.options.targetKey\n      && !this.target.rawAttributes[this.options.targetKey]\n    ) {\n      throw new Error(`Unknown attribute \"${this.options.targetKey}\" passed as targetKey, define this attribute on model \"${this.target.name}\" first`);\n    }\n\n    this.targetKey = this.options.targetKey || this.target.primaryKeyAttribute;\n    this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    this.targetKeyIsPrimary = this.targetKey === this.target.primaryKeyAttribute;\n    this.targetIdentifier = this.targetKey;\n\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n\n    // Get singular name, trying to uppercase the first letter, unless the model forbids it\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: `get${singular}`,\n      set: `set${singular}`,\n      create: `create${singular}`\n    };\n  }\n\n  // the id is in the source table\n  _injectAttributes() {\n    const newAttributes = {\n      [this.foreignKey]: {\n        type: this.options.keyType || this.target.rawAttributes[this.targetKey].type,\n        allowNull: true,\n        ...this.foreignKeyAttribute\n      }\n    };\n\n    if (this.options.constraints !== false) {\n      const source = this.source.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (source.allowNull ? 'SET NULL' : 'NO ACTION');\n      this.options.onUpdate = this.options.onUpdate || 'CASCADE';\n    }\n\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.target, this.source, this.options, this.targetKeyField);\n    Utils.mergeDefaults(this.source.rawAttributes, newAttributes);\n\n    this.source.refreshAttributes();\n\n    this.identifierField = this.source.rawAttributes[this.foreignKey].field || this.foreignKey;\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'set', 'create'];\n\n    Helpers.mixinMethods(this, obj, methods);\n  }\n\n  /**\n   * Get the associated instance.\n   *\n   * @param {Model|Array<Model>} instances source instances\n   * @param {object}         [options] find options\n   * @param {string|boolean} [options.scope]  Apply a scope on the related model, or remove its default scope by passing false.\n   * @param {string}         [options.schema] Apply a schema on the related model\n   *\n   * @see\n   * {@link Model.findOne} for a full explanation of options\n   *\n   * @returns {Promise<Model>}\n   */\n  async get(instances, options) {\n    const where = {};\n    let Target = this.target;\n    let instance;\n\n    options = Utils.cloneDeep(options);\n\n    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = undefined;\n    }\n\n    if (instances) {\n      where[this.targetKey] = {\n        [Op.in]: instances.map(_instance => _instance.get(this.foreignKey))\n      };\n    } else {\n      if (this.targetKeyIsPrimary && !options.where) {\n        return Target.findByPk(instance.get(this.foreignKey), options);\n      }\n      where[this.targetKey] = instance.get(this.foreignKey);\n      options.limit = null;\n    }\n\n    options.where = options.where ?\n      { [Op.and]: [where, options.where] } :\n      where;\n\n    if (instances) {\n      const results = await Target.findAll(options);\n      const result = {};\n      for (const _instance of instances) {\n        result[_instance.get(this.foreignKey, { raw: true })] = null;\n      }\n\n      for (const _instance of results) {\n        result[_instance.get(this.targetKey, { raw: true })] = _instance;\n      }\n\n      return result;\n    }\n\n    return Target.findOne(options);\n  }\n\n  /**\n   * Set the associated model.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {?Model|string|number} [associatedInstance] An persisted instance or the primary key of an instance to associate with this. Pass `null` or `undefined` to remove the association.\n   * @param {object} [options={}] options passed to `this.save`\n   * @param {boolean} [options.save=true] Skip saving this after setting the foreign key if false.\n   *\n   *  @returns {Promise}\n   */\n  async set(sourceInstance, associatedInstance, options = {}) {\n    let value = associatedInstance;\n\n    if (associatedInstance instanceof this.target) {\n      value = associatedInstance[this.targetKey];\n    }\n\n    sourceInstance.set(this.foreignKey, value);\n\n    if (options.save === false) return;\n\n    options = {\n      fields: [this.foreignKey],\n      allowNull: [this.foreignKey],\n      association: true,\n      ...options\n    };\n\n    // passes the changed field to save, so only that field get updated.\n    return await sourceInstance.save(options);\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {object} [values={}] values to create associated model instance with\n   * @param {object} [options={}] Options passed to `target.create` and setAssociation.\n   *\n   * @see\n   * {@link Model#create}  for a full explanation of options\n   *\n   * @returns {Promise<Model>} The created target model\n   */\n  async create(sourceInstance, values, options) {\n    values = values || {};\n    options = options || {};\n\n    const newAssociatedObject = await this.target.create(values, options);\n    await sourceInstance[this.accessors.set](newAssociatedObject, options);\n\n    return newAssociatedObject;\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === 'string') {\n      return this.as === alias;\n    }\n\n    if (alias && alias.singular) {\n      return this.as === alias.singular;\n    }\n\n    return !this.isAliased;\n  }\n}\n\nmodule.exports = BelongsTo;\nmodule.exports.BelongsTo = BelongsTo;\nmodule.exports.default = BelongsTo;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}