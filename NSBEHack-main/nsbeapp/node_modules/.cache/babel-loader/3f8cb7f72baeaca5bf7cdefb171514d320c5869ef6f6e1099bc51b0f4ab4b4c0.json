{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nconst DataTypes = require(\"./data-types\");\nconst SqlString = require(\"./sql-string\");\nconst _ = require(\"lodash\");\nconst baseIsNative = require(\"lodash/_baseIsNative\");\nconst uuidv1 = require(\"uuid\").v1;\nconst uuidv4 = require(\"uuid\").v4;\nconst operators = require(\"./operators\");\nconst operatorsSet = new Set(Object.values(operators));\nlet inflection = require(\"inflection\");\nexports.classToInvokable = require(\"./utils/class-to-invokable\").classToInvokable;\nexports.joinSQLFragments = require(\"./utils/join-sql-fragments\").joinSQLFragments;\nfunction useInflection(_inflection) {\n  inflection = _inflection;\n}\nexports.useInflection = useInflection;\nfunction camelizeIf(str, condition) {\n  let result = str;\n  if (condition) {\n    result = camelize(str);\n  }\n  return result;\n}\nexports.camelizeIf = camelizeIf;\nfunction underscoredIf(str, condition) {\n  let result = str;\n  if (condition) {\n    result = underscore(str);\n  }\n  return result;\n}\nexports.underscoredIf = underscoredIf;\nfunction isPrimitive(val) {\n  const type = typeof val;\n  return [\"string\", \"number\", \"boolean\"].includes(type);\n}\nexports.isPrimitive = isPrimitive;\nfunction mergeDefaults(a, b) {\n  return _.mergeWith(a, b, (objectValue, sourceValue) => {\n    if (!_.isPlainObject(objectValue) && objectValue !== void 0) {\n      if (_.isFunction(objectValue) && baseIsNative(objectValue)) {\n        return sourceValue || objectValue;\n      }\n      return objectValue;\n    }\n  });\n}\nexports.mergeDefaults = mergeDefaults;\nfunction merge() {\n  const result = {};\n  for (const obj of arguments) {\n    _.forOwn(obj, (value, key) => {\n      if (value !== void 0) {\n        if (!result[key]) {\n          result[key] = value;\n        } else if (_.isPlainObject(value) && _.isPlainObject(result[key])) {\n          result[key] = merge(result[key], value);\n        } else if (Array.isArray(value) && Array.isArray(result[key])) {\n          result[key] = value.concat(result[key]);\n        } else {\n          result[key] = value;\n        }\n      }\n    });\n  }\n  return result;\n}\nexports.merge = merge;\nfunction spliceStr(str, index, count, add) {\n  return str.slice(0, index) + add + str.slice(index + count);\n}\nexports.spliceStr = spliceStr;\nfunction camelize(str) {\n  return str.trim().replace(/[-_\\s]+(.)?/g, (match, c) => c.toUpperCase());\n}\nexports.camelize = camelize;\nfunction underscore(str) {\n  return inflection.underscore(str);\n}\nexports.underscore = underscore;\nfunction singularize(str) {\n  return inflection.singularize(str);\n}\nexports.singularize = singularize;\nfunction pluralize(str) {\n  return inflection.pluralize(str);\n}\nexports.pluralize = pluralize;\nfunction format(arr, dialect) {\n  const timeZone = null;\n  return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);\n}\nexports.format = format;\nfunction formatNamedParameters(sql, parameters, dialect) {\n  const timeZone = null;\n  return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);\n}\nexports.formatNamedParameters = formatNamedParameters;\nfunction cloneDeep(obj, onlyPlain) {\n  obj = obj || {};\n  return _.cloneDeepWith(obj, elem => {\n    if (Array.isArray(elem) || _.isPlainObject(elem)) {\n      return void 0;\n    }\n    if (onlyPlain || typeof elem === \"object\") {\n      return elem;\n    }\n    if (elem && typeof elem.clone === \"function\") {\n      return elem.clone();\n    }\n  });\n}\nexports.cloneDeep = cloneDeep;\nfunction mapFinderOptions(options, Model) {\n  if (options.attributes && Array.isArray(options.attributes)) {\n    options.attributes = Model._injectDependentVirtualAttributes(options.attributes);\n    options.attributes = options.attributes.filter(v => !Model._virtualAttributes.has(v));\n  }\n  mapOptionFieldNames(options, Model);\n  return options;\n}\nexports.mapFinderOptions = mapFinderOptions;\nfunction mapOptionFieldNames(options, Model) {\n  if (Array.isArray(options.attributes)) {\n    options.attributes = options.attributes.map(attr => {\n      if (typeof attr !== \"string\") return attr;\n      if (Model.rawAttributes[attr] && attr !== Model.rawAttributes[attr].field) {\n        return [Model.rawAttributes[attr].field, attr];\n      }\n      return attr;\n    });\n  }\n  if (options.where && _.isPlainObject(options.where)) {\n    options.where = mapWhereFieldNames(options.where, Model);\n  }\n  return options;\n}\nexports.mapOptionFieldNames = mapOptionFieldNames;\nfunction mapWhereFieldNames(attributes, Model) {\n  if (attributes) {\n    attributes = cloneDeep(attributes);\n    getComplexKeys(attributes).forEach(attribute => {\n      const rawAttribute = Model.rawAttributes[attribute];\n      if (rawAttribute && rawAttribute.field !== rawAttribute.fieldName) {\n        attributes[rawAttribute.field] = attributes[attribute];\n        delete attributes[attribute];\n      }\n      if (_.isPlainObject(attributes[attribute]) && !(rawAttribute && (rawAttribute.type instanceof DataTypes.HSTORE || rawAttribute.type instanceof DataTypes.JSON))) {\n        attributes[attribute] = mapOptionFieldNames({\n          where: attributes[attribute]\n        }, Model).where;\n      }\n      if (Array.isArray(attributes[attribute])) {\n        attributes[attribute].forEach((where, index) => {\n          if (_.isPlainObject(where)) {\n            attributes[attribute][index] = mapWhereFieldNames(where, Model);\n          }\n        });\n      }\n    });\n  }\n  return attributes;\n}\nexports.mapWhereFieldNames = mapWhereFieldNames;\nfunction mapValueFieldNames(dataValues, fields, Model) {\n  const values = {};\n  for (const attr of fields) {\n    if (dataValues[attr] !== void 0 && !Model._virtualAttributes.has(attr)) {\n      if (Model.rawAttributes[attr] && Model.rawAttributes[attr].field && Model.rawAttributes[attr].field !== attr) {\n        values[Model.rawAttributes[attr].field] = dataValues[attr];\n      } else {\n        values[attr] = dataValues[attr];\n      }\n    }\n  }\n  return values;\n}\nexports.mapValueFieldNames = mapValueFieldNames;\nfunction isColString(value) {\n  return typeof value === \"string\" && value[0] === \"$\" && value[value.length - 1] === \"$\";\n}\nexports.isColString = isColString;\nfunction canTreatArrayAsAnd(arr) {\n  return arr.some(arg => _.isPlainObject(arg) || arg instanceof Where);\n}\nexports.canTreatArrayAsAnd = canTreatArrayAsAnd;\nfunction combineTableNames(tableName1, tableName2) {\n  return tableName1.toLowerCase() < tableName2.toLowerCase() ? tableName1 + tableName2 : tableName2 + tableName1;\n}\nexports.combineTableNames = combineTableNames;\nfunction toDefaultValue(value, dialect) {\n  if (typeof value === \"function\") {\n    const tmp = value();\n    if (tmp instanceof DataTypes.ABSTRACT) {\n      return tmp.toSql();\n    }\n    return tmp;\n  }\n  if (value instanceof DataTypes.UUIDV1) {\n    return uuidv1();\n  }\n  if (value instanceof DataTypes.UUIDV4) {\n    return uuidv4();\n  }\n  if (value instanceof DataTypes.NOW) {\n    return now(dialect);\n  }\n  if (Array.isArray(value)) {\n    return value.slice();\n  }\n  if (_.isPlainObject(value)) {\n    return __spreadValues({}, value);\n  }\n  return value;\n}\nexports.toDefaultValue = toDefaultValue;\nfunction defaultValueSchemable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  if (value instanceof DataTypes.NOW) {\n    return false;\n  }\n  if (value instanceof DataTypes.UUIDV1 || value instanceof DataTypes.UUIDV4) {\n    return false;\n  }\n  return typeof value !== \"function\";\n}\nexports.defaultValueSchemable = defaultValueSchemable;\nfunction removeNullValuesFromHash(hash, omitNull, options) {\n  let result = hash;\n  options = options || {};\n  options.allowNull = options.allowNull || [];\n  if (omitNull) {\n    const _hash = {};\n    _.forIn(hash, (val, key) => {\n      if (options.allowNull.includes(key) || key.endsWith(\"Id\") || val !== null && val !== void 0) {\n        _hash[key] = val;\n      }\n    });\n    result = _hash;\n  }\n  return result;\n}\nexports.removeNullValuesFromHash = removeNullValuesFromHash;\nconst dialects = /* @__PURE__ */new Set([\"mariadb\", \"mysql\", \"postgres\", \"sqlite\", \"mssql\", \"db2\", \"oracle\"]);\nfunction now(dialect) {\n  const d = new Date();\n  if (!dialects.has(dialect)) {\n    d.setMilliseconds(0);\n  }\n  return d;\n}\nexports.now = now;\nconst TICK_CHAR = \"`\";\nexports.TICK_CHAR = TICK_CHAR;\nfunction addTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return tickChar + removeTicks(s, tickChar) + tickChar;\n}\nexports.addTicks = addTicks;\nfunction removeTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return s.replace(new RegExp(tickChar, \"g\"), \"\");\n}\nexports.removeTicks = removeTicks;\nfunction flattenObjectDeep(value) {\n  if (!_.isPlainObject(value)) return value;\n  const flattenedObj = {};\n  function flattenObject(obj, subPath) {\n    Object.keys(obj).forEach(key => {\n      const pathToProperty = subPath ? `${subPath}.${key}` : key;\n      if (typeof obj[key] === \"object\" && obj[key] !== null) {\n        flattenObject(obj[key], pathToProperty);\n      } else {\n        flattenedObj[pathToProperty] = _.get(obj, key);\n      }\n    });\n    return flattenedObj;\n  }\n  return flattenObject(value, void 0);\n}\nexports.flattenObjectDeep = flattenObjectDeep;\nclass SequelizeMethod {}\nexports.SequelizeMethod = SequelizeMethod;\nclass Fn extends SequelizeMethod {\n  constructor(fn, args) {\n    super();\n    this.fn = fn;\n    this.args = args;\n  }\n  clone() {\n    return new Fn(this.fn, this.args);\n  }\n}\nexports.Fn = Fn;\nclass Col extends SequelizeMethod {\n  constructor(col) {\n    super();\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    if (args.length > 0) {\n      col = args;\n    }\n    this.col = col;\n  }\n}\nexports.Col = Col;\nclass Cast extends SequelizeMethod {\n  constructor(val, type, json) {\n    super();\n    this.val = val;\n    this.type = (type || \"\").trim();\n    this.json = json || false;\n  }\n}\nexports.Cast = Cast;\nclass Literal extends SequelizeMethod {\n  constructor(val) {\n    super();\n    this.val = val;\n  }\n}\nexports.Literal = Literal;\nclass Json extends SequelizeMethod {\n  constructor(conditionsOrPath, value) {\n    super();\n    if (_.isObject(conditionsOrPath)) {\n      this.conditions = conditionsOrPath;\n    } else {\n      this.path = conditionsOrPath;\n      if (value) {\n        this.value = value;\n      }\n    }\n  }\n}\nexports.Json = Json;\nclass Where extends SequelizeMethod {\n  constructor(attribute, comparator, logic) {\n    super();\n    if (logic === void 0) {\n      logic = comparator;\n      comparator = \"=\";\n    }\n    this.attribute = attribute;\n    this.comparator = comparator;\n    this.logic = logic;\n  }\n}\nexports.Where = Where;\nfunction getOperators(obj) {\n  return Object.getOwnPropertySymbols(obj).filter(s => operatorsSet.has(s));\n}\nexports.getOperators = getOperators;\nfunction getComplexKeys(obj) {\n  return getOperators(obj).concat(Object.keys(obj));\n}\nexports.getComplexKeys = getComplexKeys;\nfunction getComplexSize(obj) {\n  return Array.isArray(obj) ? obj.length : getComplexKeys(obj).length;\n}\nexports.getComplexSize = getComplexSize;\nfunction isWhereEmpty(obj) {\n  return !!obj && _.isEmpty(obj) && getOperators(obj).length === 0;\n}\nexports.isWhereEmpty = isWhereEmpty;\nfunction generateEnumName(tableName, columnName) {\n  return `enum_${tableName}_${columnName}`;\n}\nexports.generateEnumName = generateEnumName;\nfunction camelizeObjectKeys(obj) {\n  const newObj = new Object();\n  Object.keys(obj).forEach(key => {\n    newObj[camelize(key)] = obj[key];\n  });\n  return newObj;\n}\nexports.camelizeObjectKeys = camelizeObjectKeys;\nfunction defaults(object) {\n  object = Object(object);\n  for (var _len2 = arguments.length, sources = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    sources[_key2 - 1] = arguments[_key2];\n  }\n  sources.forEach(source => {\n    if (source) {\n      source = Object(source);\n      getComplexKeys(source).forEach(key => {\n        const value = object[key];\n        if (value === void 0 || _.eq(value, Object.prototype[key]) && !Object.prototype.hasOwnProperty.call(object, key)) {\n          object[key] = source[key];\n        }\n      });\n    }\n  });\n  return object;\n}\nexports.defaults = defaults;\nfunction nameIndex(index, tableName) {\n  if (tableName.tableName) tableName = tableName.tableName;\n  if (!Object.prototype.hasOwnProperty.call(index, \"name\")) {\n    const fields = index.fields.map(field => typeof field === \"string\" ? field : field.name || field.attribute);\n    index.name = underscore(`${tableName}_${fields.join(\"_\")}`);\n  }\n  return index;\n}\nexports.nameIndex = nameIndex;\nfunction intersects(arr1, arr2) {\n  return arr1.some(v => arr2.includes(v));\n}\nexports.intersects = intersects;\nfunction safeStringifyJson(value) {\n  return JSON.stringify(value, (key, value2) => {\n    if (typeof value2 === \"bigint\") {\n      return String(value2);\n    }\n    return value2;\n  });\n}\nexports.safeStringifyJson = safeStringifyJson;","map":{"version":3,"mappings":"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","names":["DataTypes","require","SqlString","_","baseIsNative","uuidv1","v1","uuidv4","v4","operators","operatorsSet","Set","Object","values","inflection","exports","classToInvokable","joinSQLFragments","_inflection","useInflection","str","condition","result","camelize","camelizeIf","underscore","underscoredIf","val","type","includes","isPrimitive","a","b","mergeWith","objectValue","sourceValue","isPlainObject","isFunction","mergeDefaults","obj","arguments","forOwn","value","key","merge","Array","isArray","concat","index","count","add","slice","spliceStr","trim","replace","match","c","toUpperCase","singularize","pluralize","arr","dialect","timeZone","format","sql","parameters","formatNamedParameters","onlyPlain","cloneDeepWith","elem","clone","cloneDeep","options","Model","attributes","_injectDependentVirtualAttributes","filter","v","_virtualAttributes","has","mapOptionFieldNames","mapFinderOptions","map","attr","rawAttributes","field","where","mapWhereFieldNames","getComplexKeys","forEach","attribute","rawAttribute","fieldName","HSTORE","JSON","dataValues","fields","mapValueFieldNames","length","isColString","some","arg","Where","canTreatArrayAsAnd","tableName1","tableName2","toLowerCase","combineTableNames","tmp","ABSTRACT","toSql","UUIDV1","UUIDV4","NOW","now","__spreadValues","toDefaultValue","defaultValueSchemable","hash","omitNull","allowNull","_hash","forIn","endsWith","removeNullValuesFromHash","dialects","d","Date","setMilliseconds","TICK_CHAR","s","tickChar","removeTicks","addTicks","RegExp","flattenedObj","subPath","keys","pathToProperty","flattenObject","get","flattenObjectDeep","SequelizeMethod","constructor","fn","args","Fn","col","Col","json","Cast","Literal","conditionsOrPath","isObject","conditions","path","Json","comparator","logic","getOwnPropertySymbols","getOperators","getComplexSize","isEmpty","isWhereEmpty","tableName","columnName","generateEnumName","newObj","camelizeObjectKeys","object","sources","source","eq","prototype","hasOwnProperty","call","defaults","name","join","nameIndex","arr1","arr2","intersects","stringify","value2","String","safeStringifyJson"],"sources":["C:\\Users\\rizla\\projects\\react\\NSBEHack-main\\nsbeapp\\node_modules\\sequelize\\src\\utils.js"],"sourcesContent":["'use strict';\n\nconst DataTypes = require('./data-types');\nconst SqlString = require('./sql-string');\nconst _ = require('lodash');\nconst baseIsNative = require('lodash/_baseIsNative');\nconst uuidv1 = require('uuid').v1;\nconst uuidv4 = require('uuid').v4;\nconst operators = require('./operators');\nconst operatorsSet = new Set(Object.values(operators));\n\nlet inflection = require('inflection');\n\nexports.classToInvokable = require('./utils/class-to-invokable').classToInvokable;\nexports.joinSQLFragments = require('./utils/join-sql-fragments').joinSQLFragments;\n\nfunction useInflection(_inflection) {\n  inflection = _inflection;\n}\nexports.useInflection = useInflection;\n\nfunction camelizeIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = camelize(str);\n  }\n\n  return result;\n}\nexports.camelizeIf = camelizeIf;\n\nfunction underscoredIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = underscore(str);\n  }\n\n  return result;\n}\nexports.underscoredIf = underscoredIf;\n\nfunction isPrimitive(val) {\n  const type = typeof val;\n  return ['string', 'number', 'boolean'].includes(type);\n}\nexports.isPrimitive = isPrimitive;\n\n// Same concept as _.merge, but don't overwrite properties that have already been assigned\nfunction mergeDefaults(a, b) {\n  return _.mergeWith(a, b, (objectValue, sourceValue) => {\n    // If it's an object, let _ handle it this time, we will be called again for each property\n    if (!_.isPlainObject(objectValue) && objectValue !== undefined) {\n      // _.isNative includes a check for core-js and throws an error if present.\n      // Depending on _baseIsNative bypasses the core-js check.\n      if (_.isFunction(objectValue) && baseIsNative(objectValue)) {\n        return sourceValue || objectValue;\n      }\n      return objectValue;\n    }\n  });\n}\nexports.mergeDefaults = mergeDefaults;\n\n// An alternative to _.merge, which doesn't clone its arguments\n// Cloning is a bad idea because options arguments may contain references to sequelize\n// models - which again reference database libs which don't like to be cloned (in particular pg-native)\nfunction merge() {\n  const result = {};\n\n  for (const obj of arguments) {\n    _.forOwn(obj, (value, key) => {\n      if (value !== undefined) {\n        if (!result[key]) {\n          result[key] = value;\n        } else if (_.isPlainObject(value) && _.isPlainObject(result[key])) {\n          result[key] = merge(result[key], value);\n        } else if (Array.isArray(value) && Array.isArray(result[key])) {\n          result[key] = value.concat(result[key]);\n        } else {\n          result[key] = value;\n        }\n      }\n    });\n  }\n\n  return result;\n}\nexports.merge = merge;\n\nfunction spliceStr(str, index, count, add) {\n  return str.slice(0, index) + add + str.slice(index + count);\n}\nexports.spliceStr = spliceStr;\n\nfunction camelize(str) {\n  return str.trim().replace(/[-_\\s]+(.)?/g, (match, c) => c.toUpperCase());\n}\nexports.camelize = camelize;\n\nfunction underscore(str) {\n  return inflection.underscore(str);\n}\nexports.underscore = underscore;\n\nfunction singularize(str) {\n  return inflection.singularize(str);\n}\nexports.singularize = singularize;\n\nfunction pluralize(str) {\n  return inflection.pluralize(str);\n}\nexports.pluralize = pluralize;\n\n/**\n * @deprecated use {@link injectReplacements} instead. This method has been removed in v7.\n *\n * @param {unknown[]} arr - first item is the SQL, following items are the positional replacements.\n * @param {AbstractDialect} dialect\n */\nfunction format(arr, dialect) {\n  const timeZone = null;\n  // Make a clone of the array beacuse format modifies the passed args\n  return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);\n}\nexports.format = format;\n\n/**\n * @deprecated use {@link injectReplacements} instead. This method has been removed in v7.\n *\n * @param {string} sql\n * @param {object} parameters\n * @param {AbstractDialect} dialect\n */\nfunction formatNamedParameters(sql, parameters, dialect) {\n  const timeZone = null;\n  return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);\n}\nexports.formatNamedParameters = formatNamedParameters;\n\nfunction cloneDeep(obj, onlyPlain) {\n  obj = obj || {};\n  return _.cloneDeepWith(obj, elem => {\n    // Do not try to customize cloning of arrays or POJOs\n    if (Array.isArray(elem) || _.isPlainObject(elem)) {\n      return undefined;\n    }\n\n    // If we specified to clone only plain objects & arrays, we ignore everyhing else\n    // In any case, don't clone stuff that's an object, but not a plain one - fx example sequelize models and instances\n    if (onlyPlain || typeof elem === 'object') {\n      return elem;\n    }\n\n    // Preserve special data-types like `fn` across clones. _.get() is used for checking up the prototype chain\n    if (elem && typeof elem.clone === 'function') {\n      return elem.clone();\n    }\n  });\n}\nexports.cloneDeep = cloneDeep;\n\n/* Expand and normalize finder options */\nfunction mapFinderOptions(options, Model) {\n  if (options.attributes && Array.isArray(options.attributes)) {\n    options.attributes = Model._injectDependentVirtualAttributes(options.attributes);\n    options.attributes = options.attributes.filter(v => !Model._virtualAttributes.has(v));\n  }\n\n  mapOptionFieldNames(options, Model);\n\n  return options;\n}\nexports.mapFinderOptions = mapFinderOptions;\n\n/* Used to map field names in attributes and where conditions */\nfunction mapOptionFieldNames(options, Model) {\n  if (Array.isArray(options.attributes)) {\n    options.attributes = options.attributes.map(attr => {\n      // Object lookups will force any variable to strings, we don't want that for special objects etc\n      if (typeof attr !== 'string') return attr;\n      // Map attributes to aliased syntax attributes\n      if (Model.rawAttributes[attr] && attr !== Model.rawAttributes[attr].field) {\n        return [Model.rawAttributes[attr].field, attr];\n      }\n      return attr;\n    });\n  }\n\n  if (options.where && _.isPlainObject(options.where)) {\n    options.where = mapWhereFieldNames(options.where, Model);\n  }\n\n  return options;\n}\nexports.mapOptionFieldNames = mapOptionFieldNames;\n\nfunction mapWhereFieldNames(attributes, Model) {\n  if (attributes) {\n    attributes = cloneDeep(attributes);\n    getComplexKeys(attributes).forEach(attribute => {\n      const rawAttribute = Model.rawAttributes[attribute];\n\n      if (rawAttribute && rawAttribute.field !== rawAttribute.fieldName) {\n        attributes[rawAttribute.field] = attributes[attribute];\n        delete attributes[attribute];\n      }\n\n      if (_.isPlainObject(attributes[attribute])\n        && !(rawAttribute && (\n          rawAttribute.type instanceof DataTypes.HSTORE\n          || rawAttribute.type instanceof DataTypes.JSON))) { // Prevent renaming of HSTORE & JSON fields\n        attributes[attribute] = mapOptionFieldNames({\n          where: attributes[attribute]\n        }, Model).where;\n      }\n\n      if (Array.isArray(attributes[attribute])) {\n        attributes[attribute].forEach((where, index) => {\n          if (_.isPlainObject(where)) {\n            attributes[attribute][index] = mapWhereFieldNames(where, Model);\n          }\n        });\n      }\n\n    });\n  }\n\n  return attributes;\n}\nexports.mapWhereFieldNames = mapWhereFieldNames;\n\n/* Used to map field names in values */\nfunction mapValueFieldNames(dataValues, fields, Model) {\n  const values = {};\n\n  for (const attr of fields) {\n    if (dataValues[attr] !== undefined && !Model._virtualAttributes.has(attr)) {\n      // Field name mapping\n      if (Model.rawAttributes[attr] && Model.rawAttributes[attr].field && Model.rawAttributes[attr].field !== attr) {\n        values[Model.rawAttributes[attr].field] = dataValues[attr];\n      } else {\n        values[attr] = dataValues[attr];\n      }\n    }\n  }\n\n  return values;\n}\nexports.mapValueFieldNames = mapValueFieldNames;\n\nfunction isColString(value) {\n  return typeof value === 'string' && value[0] === '$' && value[value.length - 1] === '$';\n}\nexports.isColString = isColString;\n\nfunction canTreatArrayAsAnd(arr) {\n  return arr.some(arg => _.isPlainObject(arg) || arg instanceof Where);\n}\nexports.canTreatArrayAsAnd = canTreatArrayAsAnd;\n\nfunction combineTableNames(tableName1, tableName2) {\n  return tableName1.toLowerCase() < tableName2.toLowerCase() ? tableName1 + tableName2 : tableName2 + tableName1;\n}\nexports.combineTableNames = combineTableNames;\n\nfunction toDefaultValue(value, dialect) {\n  if (typeof value === 'function') {\n    const tmp = value();\n    if (tmp instanceof DataTypes.ABSTRACT) {\n      return tmp.toSql();\n    }\n    return tmp;\n  }\n  if (value instanceof DataTypes.UUIDV1) {\n    return uuidv1();\n  }\n  if (value instanceof DataTypes.UUIDV4) {\n    return uuidv4();\n  }\n  if (value instanceof DataTypes.NOW) {\n    return now(dialect);\n  }\n  if (Array.isArray(value)) {\n    return value.slice();\n  }\n  if (_.isPlainObject(value)) {\n    return { ...value };\n  }\n  return value;\n}\nexports.toDefaultValue = toDefaultValue;\n\n/**\n * Determine if the default value provided exists and can be described\n * in a db schema using the DEFAULT directive.\n *\n * @param  {*} value Any default value.\n * @returns {boolean} yes / no.\n * @private\n */\nfunction defaultValueSchemable(value) {\n  if (value === undefined) { return false; }\n\n  // TODO this will be schemable when all supported db\n  // have been normalized for this case\n  if (value instanceof DataTypes.NOW) { return false; }\n\n  if (value instanceof DataTypes.UUIDV1 || value instanceof DataTypes.UUIDV4) { return false; }\n\n  return typeof value !== 'function';\n}\nexports.defaultValueSchemable = defaultValueSchemable;\n\nfunction removeNullValuesFromHash(hash, omitNull, options) {\n  let result = hash;\n\n  options = options || {};\n  options.allowNull = options.allowNull || [];\n\n  if (omitNull) {\n    const _hash = {};\n\n    _.forIn(hash, (val, key) => {\n      if (options.allowNull.includes(key) || key.endsWith('Id') || val !== null && val !== undefined) {\n        _hash[key] = val;\n      }\n    });\n\n    result = _hash;\n  }\n\n  return result;\n}\nexports.removeNullValuesFromHash = removeNullValuesFromHash;\n\nconst dialects = new Set(['mariadb', 'mysql', 'postgres', 'sqlite', 'mssql', 'db2', 'oracle']);\n\nfunction now(dialect) {\n  const d = new Date();\n  if (!dialects.has(dialect)) {\n    d.setMilliseconds(0);\n  }\n  return d;\n}\nexports.now = now;\n\n// Note: Use the `quoteIdentifier()` and `escape()` methods on the\n// `QueryInterface` instead for more portable code.\n\nconst TICK_CHAR = '`';\nexports.TICK_CHAR = TICK_CHAR;\n\nfunction addTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return tickChar + removeTicks(s, tickChar) + tickChar;\n}\nexports.addTicks = addTicks;\n\nfunction removeTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return s.replace(new RegExp(tickChar, 'g'), '');\n}\nexports.removeTicks = removeTicks;\n\n/**\n * Receives a tree-like object and returns a plain object which depth is 1.\n *\n * - Input:\n *\n *  {\n *    name: 'John',\n *    address: {\n *      street: 'Fake St. 123',\n *      coordinates: {\n *        longitude: 55.6779627,\n *        latitude: 12.5964313\n *      }\n *    }\n *  }\n *\n * - Output:\n *\n *  {\n *    name: 'John',\n *    address.street: 'Fake St. 123',\n *    address.coordinates.latitude: 55.6779627,\n *    address.coordinates.longitude: 12.5964313\n *  }\n *\n * @param {object} value an Object\n * @returns {object} a flattened object\n * @private\n */\nfunction flattenObjectDeep(value) {\n  if (!_.isPlainObject(value)) return value;\n  const flattenedObj = {};\n\n  function flattenObject(obj, subPath) {\n    Object.keys(obj).forEach(key => {\n      const pathToProperty = subPath ? `${subPath}.${key}` : key;\n      if (typeof obj[key] === 'object' && obj[key] !== null) {\n        flattenObject(obj[key], pathToProperty);\n      } else {\n        flattenedObj[pathToProperty] = _.get(obj, key);\n      }\n    });\n    return flattenedObj;\n  }\n\n  return flattenObject(value, undefined);\n}\nexports.flattenObjectDeep = flattenObjectDeep;\n\n/**\n * Utility functions for representing SQL functions, and columns that should be escaped.\n * Please do not use these functions directly, use Sequelize.fn and Sequelize.col instead.\n *\n * @private\n */\nclass SequelizeMethod {}\nexports.SequelizeMethod = SequelizeMethod;\n\nclass Fn extends SequelizeMethod {\n  constructor(fn, args) {\n    super();\n    this.fn = fn;\n    this.args = args;\n  }\n  clone() {\n    return new Fn(this.fn, this.args);\n  }\n}\nexports.Fn = Fn;\n\nclass Col extends SequelizeMethod {\n  constructor(col, ...args) {\n    super();\n    if (args.length > 0) {\n      col = args;\n    }\n    this.col = col;\n  }\n}\nexports.Col = Col;\n\nclass Cast extends SequelizeMethod {\n  constructor(val, type, json) {\n    super();\n    this.val = val;\n    this.type = (type || '').trim();\n    this.json = json || false;\n  }\n}\nexports.Cast = Cast;\n\nclass Literal extends SequelizeMethod {\n  constructor(val) {\n    super();\n    this.val = val;\n  }\n}\nexports.Literal = Literal;\n\nclass Json extends SequelizeMethod {\n  constructor(conditionsOrPath, value) {\n    super();\n    if (_.isObject(conditionsOrPath)) {\n      this.conditions = conditionsOrPath;\n    } else {\n      this.path = conditionsOrPath;\n      if (value) {\n        this.value = value;\n      }\n    }\n  }\n}\nexports.Json = Json;\n\nclass Where extends SequelizeMethod {\n  constructor(attribute, comparator, logic) {\n    super();\n    if (logic === undefined) {\n      logic = comparator;\n      comparator = '=';\n    }\n\n    this.attribute = attribute;\n    this.comparator = comparator;\n    this.logic = logic;\n  }\n}\nexports.Where = Where;\n\n//Collection of helper methods to make it easier to work with symbol operators\n\n/**\n * getOperators\n *\n * @param  {object} obj\n * @returns {Array<symbol>} All operators properties of obj\n * @private\n */\nfunction getOperators(obj) {\n  return Object.getOwnPropertySymbols(obj).filter(s => operatorsSet.has(s));\n}\nexports.getOperators = getOperators;\n\n/**\n * getComplexKeys\n *\n * @param  {object} obj\n * @returns {Array<string|symbol>} All keys including operators\n * @private\n */\nfunction getComplexKeys(obj) {\n  return getOperators(obj).concat(Object.keys(obj));\n}\nexports.getComplexKeys = getComplexKeys;\n\n/**\n * getComplexSize\n *\n * @param  {object|Array} obj\n * @returns {number}      Length of object properties including operators if obj is array returns its length\n * @private\n */\nfunction getComplexSize(obj) {\n  return Array.isArray(obj) ? obj.length : getComplexKeys(obj).length;\n}\nexports.getComplexSize = getComplexSize;\n\n/**\n * Returns true if a where clause is empty, even with Symbols\n *\n * @param  {object} obj\n * @returns {boolean}\n * @private\n */\nfunction isWhereEmpty(obj) {\n  return !!obj && _.isEmpty(obj) && getOperators(obj).length === 0;\n}\nexports.isWhereEmpty = isWhereEmpty;\n\n/**\n * Returns ENUM name by joining table and column name\n *\n * @param {string} tableName\n * @param {string} columnName\n * @returns {string}\n * @private\n */\nfunction generateEnumName(tableName, columnName) {\n  return `enum_${tableName}_${columnName}`;\n}\nexports.generateEnumName = generateEnumName;\n\n/**\n * Returns an new Object which keys are camelized\n *\n * @param {object} obj\n * @returns {string}\n * @private\n */\nfunction camelizeObjectKeys(obj) {\n  const newObj = new Object();\n  Object.keys(obj).forEach(key => {\n    newObj[camelize(key)] = obj[key];\n  });\n  return newObj;\n}\nexports.camelizeObjectKeys = camelizeObjectKeys;\n\n/**\n * Assigns own and inherited enumerable string and symbol keyed properties of source\n * objects to the destination object.\n *\n * https://lodash.com/docs/4.17.4#defaults\n *\n * **Note:** This method mutates `object`.\n *\n * @param {object} object The destination object.\n * @param {...object} [sources] The source objects.\n * @returns {object} Returns `object`.\n * @private\n */\nfunction defaults(object, ...sources) {\n  object = Object(object);\n\n  sources.forEach(source => {\n    if (source) {\n      source = Object(source);\n\n      getComplexKeys(source).forEach(key => {\n        const value = object[key];\n        if (\n          value === undefined ||\n            _.eq(value, Object.prototype[key]) &&\n            !Object.prototype.hasOwnProperty.call(object, key)\n\n        ) {\n          object[key] = source[key];\n        }\n      });\n    }\n  });\n\n  return object;\n}\nexports.defaults = defaults;\n\n/**\n *\n * @param {object} index\n * @param {Array}  index.fields\n * @param {string} [index.name]\n * @param {string|object} tableName\n *\n * @returns {object}\n * @private\n */\nfunction nameIndex(index, tableName) {\n  if (tableName.tableName) tableName = tableName.tableName;\n\n  if (!Object.prototype.hasOwnProperty.call(index, 'name')) {\n    const fields = index.fields.map(\n      field => typeof field === 'string' ? field : field.name || field.attribute\n    );\n    index.name = underscore(`${tableName}_${fields.join('_')}`);\n  }\n\n  return index;\n}\nexports.nameIndex = nameIndex;\n\n/**\n * Checks if 2 arrays intersect.\n *\n * @param {Array} arr1\n * @param {Array} arr2\n * @private\n */\nfunction intersects(arr1, arr2) {\n  return arr1.some(v => arr2.includes(v));\n}\nexports.intersects = intersects;\n\n/**\n * Stringify a value as JSON with some differences:\n * - bigints are stringified as a json string. (`safeStringifyJson({ val: 1n })` outputs `'{ \"val\": \"1\" }'`).\n *   This is because of a decision by TC39 to not support bigint in JSON.stringify https://github.com/tc39/proposal-bigint/issues/24\n *\n * @param {any} value the value to stringify.\n * @returns {string} the resulting json.\n */\nfunction safeStringifyJson(value /* : any */) /* : string */ {\n  return JSON.stringify(value, (key, value) => {\n    if (typeof value === 'bigint') {\n      return String(value);\n    }\n\n    return value;\n  });\n}\n\nexports.safeStringifyJson = safeStringifyJson;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}