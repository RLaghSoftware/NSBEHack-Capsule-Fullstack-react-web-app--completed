{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __markAsModule = target => __defProp(target, \"__esModule\", {\n  value: true\n});\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n__export(exports, {\n  OracleQueryGenerator: () => OracleQueryGenerator\n});\nconst Utils = require(\"../../utils\");\nconst DataTypes = require(\"../../data-types\");\nconst AbstractQueryGenerator = require(\"../abstract/query-generator\");\nconst _ = require(\"lodash\");\nconst util = require(\"util\");\nconst Transaction = require(\"../../transaction\");\nconst ORACLE_RESERVED_WORDS = [\"ACCESS\", \"ADD\", \"ALL\", \"ALTER\", \"AND\", \"ANY\", \"ARRAYLEN\", \"AS\", \"ASC\", \"AUDIT\", \"BETWEEN\", \"BY\", \"CHAR\", \"CHECK\", \"CLUSTER\", \"COLUMN\", \"COMMENT\", \"COMPRESS\", \"CONNECT\", \"CREATE\", \"CURRENT\", \"DATE\", \"DECIMAL\", \"DEFAULT\", \"DELETE\", \"DESC\", \"DISTINCT\", \"DROP\", \"ELSE\", \"EXCLUSIVE\", \"EXISTS\", \"FILE\", \"FLOAT\", \"FOR\", \"FROM\", \"GRANT\", \"GROUP\", \"HAVING\", \"IDENTIFIED\", \"IMMEDIATE\", \"IN\", \"INCREMENT\", \"INDEX\", \"INITIAL\", \"INSERT\", \"INTEGER\", \"INTERSECT\", \"INTO\", \"IS\", \"LEVEL\", \"LIKE\", \"LOCK\", \"LONG\", \"MAXEXTENTS\", \"MINUS\", \"MODE\", \"MODIFY\", \"NOAUDIT\", \"NOCOMPRESS\", \"NOT\", \"NOTFOUND\", \"NOWAIT\", \"NULL\", \"NUMBER\", \"OF\", \"OFFLINE\", \"ON\", \"ONLINE\", \"OPTION\", \"OR\", \"ORDER\", \"PCTFREE\", \"PRIOR\", \"PRIVILEGES\", \"PUBLIC\", \"RAW\", \"RENAME\", \"RESOURCE\", \"REVOKE\", \"ROW\", \"ROWID\", \"ROWLABEL\", \"ROWNUM\", \"ROWS\", \"SELECT\", \"SESSION\", \"SET\", \"SHARE\", \"SIZE\", \"SMALLINT\", \"SQLBUF\", \"START\", \"SUCCESSFUL\", \"SYNONYM\", \"SYSDATE\", \"TABLE\", \"THEN\", \"TO\", \"TRIGGER\", \"UID\", \"UNION\", \"UNIQUE\", \"UPDATE\", \"USER\", \"VALIDATE\", \"VALUES\", \"VARCHAR\", \"VARCHAR2\", \"VIEW\", \"WHENEVER\", \"WHERE\", \"WITH\"];\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nclass OracleQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n  }\n  getCatalogName(value) {\n    if (value) {\n      if (this.options.quoteIdentifiers === false) {\n        const quotedValue = this.quoteIdentifier(value);\n        if (quotedValue === value) {\n          value = value.toUpperCase();\n        }\n      }\n    }\n    return value;\n  }\n  getSchemaNameAndTableName(table) {\n    const tableName = this.getCatalogName(table.tableName || table);\n    const schemaName = this.getCatalogName(table.schema);\n    return [tableName, schemaName];\n  }\n  createSchema(schema) {\n    const quotedSchema = this.quoteIdentifier(schema);\n    return [\"DECLARE\", \"USER_FOUND BOOLEAN := FALSE;\", \"BEGIN\", \" BEGIN\", \"   EXECUTE IMMEDIATE \", this.escape(`CREATE USER ${quotedSchema} IDENTIFIED BY 12345 DEFAULT TABLESPACE USERS`), \";\", \"   EXCEPTION WHEN OTHERS THEN\", \"     IF SQLCODE != -1920 THEN\", \"       RAISE;\", \"     ELSE\", \"       USER_FOUND := TRUE;\", \"     END IF;\", \" END;\", \" IF NOT USER_FOUND THEN\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT \"CONNECT\" TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT CREATE TABLE TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT CREATE VIEW TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT CREATE ANY TRIGGER TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT CREATE ANY PROCEDURE TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT CREATE SEQUENCE TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`GRANT CREATE SYNONYM TO ${quotedSchema}`), \";\", \"    EXECUTE IMMEDIATE \", this.escape(`ALTER USER ${quotedSchema} QUOTA UNLIMITED ON USERS`), \";\", \" END IF;\", \"END;\"].join(\" \");\n  }\n  showSchemasQuery() {\n    return `SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE COMMON = ('NO') AND USERNAME != user`;\n  }\n  dropSchema(schema) {\n    return [\"BEGIN\", \"EXECUTE IMMEDIATE \", this.escape(`DROP USER ${this.quoteTable(schema)} CASCADE`), \";\", \"EXCEPTION WHEN OTHERS THEN\", \"  IF SQLCODE != -1918 THEN\", \"    RAISE;\", \"  END IF;\", \"END;\"].join(\" \");\n  }\n  versionQuery() {\n    return \"SELECT VERSION_FULL FROM PRODUCT_COMPONENT_VERSION WHERE PRODUCT LIKE 'Oracle%'\";\n  }\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [],\n      foreignKeys = Object.create(null),\n      attrStr = [],\n      checkStr = [];\n    const values = {\n      table: this.quoteTable(tableName)\n    };\n    for (let attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      attr = this.quoteIdentifier(attr);\n      if (dataType.includes(\"PRIMARY KEY\")) {\n        primaryKeys.push(attr);\n        if (dataType.includes(\"REFERENCES\")) {\n          const match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${attr} ${match[1].replace(/PRIMARY KEY/, \"\")}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${attr} ${dataType.replace(/PRIMARY KEY/, \"\").trim()}`);\n        }\n      } else if (dataType.includes(\"REFERENCES\")) {\n        const match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${attr} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${attr} ${dataType}`);\n      }\n    }\n    values[\"attributes\"] = attrStr.join(\", \");\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(\", \");\n    if (pkString.length > 0) {\n      values.attributes += `,PRIMARY KEY (${pkString})`;\n    }\n    for (const fkey in foreignKeys) {\n      if (!Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) continue;\n      if (foreignKeys[fkey].indexOf(\"ON DELETE NO ACTION\") > -1) {\n        foreignKeys[fkey] = foreignKeys[fkey].replace(\"ON DELETE NO ACTION\", \"\");\n      }\n      values.attributes += `,FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n    }\n    if (checkStr.length > 0) {\n      values.attributes += `, ${checkStr.join(\", \")}`;\n    }\n    if (options && options.indexes && options.indexes.length > 0) {\n      const idxToDelete = [];\n      options.indexes.forEach((index, idx) => {\n        if (\"unique\" in index && (index.unique === true || index.unique.length > 0 && index.unique !== false)) {\n          const fields = index.fields.map(field => {\n            if (typeof field === \"string\") {\n              return field;\n            }\n            return field.attribute;\n          });\n          let canContinue = true;\n          if (options.uniqueKeys) {\n            const keys = Object.keys(options.uniqueKeys);\n            for (let fieldIdx = 0; fieldIdx < keys.length; fieldIdx++) {\n              const currUnique = options.uniqueKeys[keys[fieldIdx]];\n              if (currUnique.fields.length === fields.length) {\n                for (let i = 0; i < currUnique.fields.length; i++) {\n                  const field = currUnique.fields[i];\n                  if (_.includes(fields, field)) {\n                    canContinue = false;\n                  } else {\n                    canContinue = true;\n                    break;\n                  }\n                }\n              }\n            }\n            if (canContinue) {\n              const indexName = \"name\" in index ? index.name : \"\";\n              const constraintToAdd = {\n                name: indexName,\n                fields\n              };\n              if (!(\"uniqueKeys\" in options)) {\n                options.uniqueKeys = {};\n              }\n              options.uniqueKeys[indexName] = constraintToAdd;\n              idxToDelete.push(idx);\n            } else {\n              idxToDelete.push(idx);\n            }\n          }\n        }\n      });\n      idxToDelete.forEach(idx => {\n        options.indexes.splice(idx, 1);\n      });\n    }\n    if (options && !!options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        let canBeUniq = false;\n        primaryKeys.forEach(primaryKey => {\n          primaryKey = primaryKey.replace(/\"/g, \"\");\n          if (!_.includes(columns.fields, primaryKey)) {\n            canBeUniq = true;\n          }\n        });\n        columns.fields.forEach(field => {\n          let currField = \"\";\n          if (!_.isString(field)) {\n            currField = field.attribute.replace(/[.,\"\\s]/g, \"\");\n          } else {\n            currField = field.replace(/[.,\"\\s]/g, \"\");\n          }\n          if (currField in attributes) {\n            if (attributes[currField].toUpperCase().indexOf(\"UNIQUE\") > -1 && canBeUniq) {\n              const attrToReplace = attributes[currField].replace(\"UNIQUE\", \"\");\n              values.attributes = values.attributes.replace(attributes[currField], attrToReplace);\n            }\n          }\n        });\n        if (canBeUniq) {\n          const index = options.uniqueKeys[columns.name];\n          delete options.uniqueKeys[columns.name];\n          indexName = indexName.replace(/[.,\\s]/g, \"\");\n          columns.name = indexName;\n          options.uniqueKeys[indexName] = index;\n          if (indexName.length === 0) {\n            values.attributes += `,UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(\", \")})`;\n          } else {\n            values.attributes += `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(\", \")})`;\n          }\n        }\n      });\n    }\n    const query = Utils.joinSQLFragments([\"CREATE TABLE\", values.table, `(${values.attributes})`]);\n    return Utils.joinSQLFragments([\"BEGIN\", \"EXECUTE IMMEDIATE\", `${this.escape(query)};`, \"EXCEPTION WHEN OTHERS THEN\", \"IF SQLCODE != -955 THEN\", \"RAISE;\", \"END IF;\", \"END;\"]);\n  }\n  tableExistsQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    return `SELECT TABLE_NAME FROM ALL_TABLES WHERE TABLE_NAME = ${this.escape(tableName)} AND OWNER = ${table.schema ? this.escape(schemaName) : \"USER\"}`;\n  }\n  describeTableQuery(tableName, schema) {\n    const currTableName = this.getCatalogName(tableName.tableName || tableName);\n    schema = this.getCatalogName(schema);\n    return [\"SELECT atc.COLUMN_NAME, atc.DATA_TYPE, atc.DATA_LENGTH, atc.CHAR_LENGTH, atc.DEFAULT_LENGTH, atc.NULLABLE, ucc.constraint_type \", \"FROM all_tab_columns atc \", \"LEFT OUTER JOIN \", \"(SELECT acc.column_name, acc.table_name, ac.constraint_type FROM all_cons_columns acc INNER JOIN all_constraints ac ON acc.constraint_name = ac.constraint_name) ucc \", \"ON (atc.table_name = ucc.table_name AND atc.COLUMN_NAME = ucc.COLUMN_NAME) \", schema ? `WHERE (atc.OWNER = ${this.escape(schema)}) ` : \"WHERE atc.OWNER = USER \", `AND (atc.TABLE_NAME = ${this.escape(currTableName)})`, \"ORDER BY atc.COLUMN_NAME, CONSTRAINT_TYPE DESC\"].join(\"\");\n  }\n  renameTableQuery(before, after) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(before), \"RENAME TO\", this.quoteTable(after)]);\n  }\n  showConstraintsQuery(table) {\n    const tableName = this.getCatalogName(table.tableName || table);\n    return `SELECT CONSTRAINT_NAME constraint_name FROM user_cons_columns WHERE table_name = ${this.escape(tableName)}`;\n  }\n  showTablesQuery() {\n    return `SELECT owner as table_schema, table_name, 0 as lvl FROM all_tables where OWNER IN(SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE ORACLE_MAINTAINED = 'N')`;\n  }\n  dropTableQuery(tableName) {\n    return Utils.joinSQLFragments([\"BEGIN \", \"EXECUTE IMMEDIATE 'DROP TABLE\", this.quoteTable(tableName), \"CASCADE CONSTRAINTS PURGE';\", \"EXCEPTION WHEN OTHERS THEN\", \" IF SQLCODE != -942 THEN\", \"   RAISE;\", \" END IF;\", \"END;\"]);\n  }\n  addIndexQuery(tableName, attributes, options, rawTablename) {\n    if (typeof tableName !== \"string\" && attributes.name) {\n      attributes.name = `${tableName.schema}.${attributes.name}`;\n    }\n    return super.addIndexQuery(tableName, attributes, options, rawTablename);\n  }\n  addConstraintQuery(tableName, options) {\n    options = options || {};\n    const constraintSnippet = this.getConstraintSnippet(tableName, options);\n    tableName = this.quoteTable(tableName);\n    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;\n  }\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n    const attribute = Utils.joinSQLFragments([this.quoteIdentifier(key), this.attributeToSQL(dataType, {\n      attributeName: key,\n      context: \"addColumn\"\n    })]);\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(table), \"ADD\", attribute]);\n  }\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(tableName), \"DROP COLUMN\", this.quoteIdentifier(attributeName), \";\"]);\n  }\n  _alterForeignKeyConstraint(definition, table, attributeName) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const attributeNameConstant = this.escape(this.getCatalogName(attributeName));\n    const schemaNameConstant = table.schema ? this.escape(this.getCatalogName(schemaName)) : \"USER\";\n    const tableNameConstant = this.escape(this.getCatalogName(tableName));\n    const getConsNameQuery = [\"SELECT constraint_name INTO cons_name\", \"FROM (\", \"  SELECT DISTINCT cc.owner, cc.table_name, cc.constraint_name, cc.column_name AS cons_columns\", \"  FROM all_cons_columns cc, all_constraints c\", \"  WHERE cc.owner = c.owner\", \"  AND cc.table_name = c.table_name\", \"  AND cc.constraint_name = c.constraint_name\", \"  AND c.constraint_type = 'R'\", \"  GROUP BY cc.owner, cc.table_name, cc.constraint_name, cc.column_name\", \")\", \"WHERE owner =\", schemaNameConstant, \"AND table_name =\", tableNameConstant, \"AND cons_columns =\", attributeNameConstant, \";\"].join(\" \");\n    const secondQuery = Utils.joinSQLFragments([`ALTER TABLE ${this.quoteIdentifier(tableName)}`, \"ADD FOREIGN KEY\", `(${this.quoteIdentifier(attributeName)})`, definition.replace(/.+?(?=REFERENCES)/, \"\")]);\n    return [\"BEGIN\", getConsNameQuery, \"EXCEPTION\", \"WHEN NO_DATA_FOUND THEN\", \" CONS_NAME := NULL;\", \"END;\", \"IF CONS_NAME IS NOT NULL THEN\", ` EXECUTE IMMEDIATE 'ALTER TABLE ${this.quoteTable(table)} DROP CONSTRAINT \"'||CONS_NAME||'\"';`, \"END IF;\", `EXECUTE IMMEDIATE ${this.escape(secondQuery)};`].join(\" \");\n  }\n  _modifyQuery(definition, table, attributeName) {\n    const query = Utils.joinSQLFragments([\"ALTER TABLE\", this.quoteTable(table), \"MODIFY\", this.quoteIdentifier(attributeName), definition]);\n    const secondQuery = query.replace(\"NOT NULL\", \"\").replace(\"NULL\", \"\");\n    return [\"BEGIN\", `EXECUTE IMMEDIATE ${this.escape(query)};`, \"EXCEPTION\", \"WHEN OTHERS THEN\", \" IF SQLCODE = -1442 OR SQLCODE = -1451 THEN\", `   EXECUTE IMMEDIATE ${this.escape(secondQuery)};`, \" ELSE\", \"   RAISE;\", \" END IF;\", \"END;\"].join(\" \");\n  }\n  changeColumnQuery(table, attributes) {\n    const sql = [\"DECLARE\", \"CONS_NAME VARCHAR2(200);\", \"BEGIN\"];\n    for (const attributeName in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attributeName)) continue;\n      const definition = attributes[attributeName];\n      if (definition.match(/REFERENCES/)) {\n        sql.push(this._alterForeignKeyConstraint(definition, table, attributeName));\n      } else {\n        sql.push(this._modifyQuery(definition, table, attributeName));\n      }\n    }\n    sql.push(\"END;\");\n    return sql.join(\" \");\n  }\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(newName)}`;\n  }\n  populateInsertQueryReturnIntoBinds(returningModelAttributes, returnTypes, inbindLength, returnAttributes, options) {\n    const oracledb = this.sequelize.connectionManager.lib;\n    const outBindAttributes = Object.create(null);\n    const outbind = [];\n    const outbindParam = this.bindParam(outbind, inbindLength);\n    returningModelAttributes.forEach((element, index) => {\n      if (element.startsWith('\"')) {\n        element = element.substring(1, element.length - 1);\n      }\n      outBindAttributes[element] = Object.assign(returnTypes[index]._getBindDef(oracledb), {\n        dir: oracledb.BIND_OUT\n      });\n      const returnAttribute = `${this.format(void 0, void 0, {\n        context: \"INSERT\"\n      }, outbindParam)}`;\n      returnAttributes.push(returnAttribute);\n    });\n    options.outBindAttributes = outBindAttributes;\n  }\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    const rawAttributes = model.rawAttributes;\n    const updateQuery = this.updateQuery(tableName, updateValues, where, options, rawAttributes);\n    options.bind = updateQuery.bind;\n    const insertQuery = this.insertQuery(tableName, insertValues, rawAttributes, options);\n    const sql = [\"DECLARE \", \"BEGIN \", updateQuery.query ? [updateQuery.query, \"; \", \" IF ( SQL%ROWCOUNT = 0 ) THEN \", insertQuery.query, \" :isUpdate := 0; \", \"ELSE \", \" :isUpdate := 1; \", \" END IF; \"].join(\"\") : [insertQuery.query, \" :isUpdate := 0; \", \"EXCEPTION WHEN OTHERS THEN\", \" IF SQLCODE != -1 THEN\", \"   RAISE;\", \" END IF;\"].join(\"\"), \"END;\"];\n    const query = sql.join(\"\");\n    const result = {\n      query\n    };\n    if (options.bindParam !== false) {\n      result.bind = updateQuery.bind || insertQuery.bind;\n    }\n    return result;\n  }\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n    options = options || {};\n    options.executeMany = true;\n    fieldMappedAttributes = fieldMappedAttributes || {};\n    const tuples = [];\n    const allColumns = {};\n    const inBindBindDefMap = {};\n    const outBindBindDefMap = {};\n    const oracledb = this.sequelize.connectionManager.lib;\n    for (const fieldValueHash of fieldValueHashes) {\n      _.forOwn(fieldValueHash, (value, key) => {\n        allColumns[key] = fieldMappedAttributes[key] && fieldMappedAttributes[key].autoIncrement === true && value === null;\n      });\n    }\n    let inBindPosition;\n    for (const fieldValueHash of fieldValueHashes) {\n      const tuple = [];\n      const inbindParam = options.bindParam === void 0 ? this.bindParam(tuple) : options.bindParam;\n      const tempBindPositions = Object.keys(allColumns).map(key => {\n        if (allColumns[key] === true) {\n          if (fieldValueHash[key] !== null) {\n            throw Error(\"For an auto-increment column either all row must be null or non-null, a mix of null and non-null is not allowed!\");\n          }\n          return \"DEFAULT\";\n        }\n        return this.format(fieldValueHash[key], fieldMappedAttributes[key], {\n          context: \"INSERT\"\n        }, inbindParam);\n      });\n      if (!inBindPosition) {\n        inBindPosition = tempBindPositions;\n      }\n      tuples.push(tuple);\n    }\n    const returnColumn = [];\n    const returnColumnBindPositions = [];\n    const insertColumns = [];\n    for (const key of Object.keys(allColumns)) {\n      if (fieldMappedAttributes[key]) {\n        const bindDef = fieldMappedAttributes[key].type._getBindDef(oracledb);\n        if (allColumns[key]) {\n          bindDef.dir = oracledb.BIND_OUT;\n          outBindBindDefMap[key] = bindDef;\n          returnColumn.push(this.quoteIdentifier(key));\n          returnColumnBindPositions.push(`:${tuples[0].length + returnColumn.length}`);\n        } else {\n          bindDef.dir = oracledb.BIND_IN;\n          inBindBindDefMap[key] = bindDef;\n        }\n      }\n      insertColumns.push(this.quoteIdentifier(key));\n    }\n    let query = Utils.joinSQLFragments([\"INSERT\", \"INTO\", this.quoteTable(tableName), `(${insertColumns.join(\",\")})`, \"VALUES\", `(${inBindPosition})`]);\n    if (returnColumn.length > 0) {\n      options.outBindAttributes = outBindBindDefMap;\n      query = Utils.joinSQLFragments([query, \"RETURNING\", `${returnColumn.join(\",\")}`, \"INTO\", `${returnColumnBindPositions}`]);\n    }\n    const result = {\n      query\n    };\n    result.bind = tuples;\n    options.inbindAttributes = inBindBindDefMap;\n    return result;\n  }\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n  deleteQuery(tableName, where, options, model) {\n    options = options || {};\n    const table = tableName;\n    where = this.getWhereConditions(where, null, model, options);\n    let queryTmpl;\n    if (options.limit) {\n      const whereTmpl = where ? ` AND ${where}` : \"\";\n      queryTmpl = `DELETE FROM ${this.quoteTable(table)} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(table)} WHERE rownum <= ${this.escape(options.limit)}${whereTmpl})`;\n    } else {\n      const whereTmpl = where ? ` WHERE ${where}` : \"\";\n      queryTmpl = `DELETE FROM ${this.quoteTable(table)}${whereTmpl}`;\n    }\n    return queryTmpl;\n  }\n  showIndexesQuery(table) {\n    const [tableName, owner] = this.getSchemaNameAndTableName(table);\n    const sql = [\"SELECT i.index_name,i.table_name, i.column_name, u.uniqueness, i.descend, c.constraint_type \", \"FROM all_ind_columns i \", \"INNER JOIN all_indexes u \", \"ON (u.table_name = i.table_name AND u.index_name = i.index_name) \", \"LEFT OUTER JOIN all_constraints c \", \"ON (c.table_name = i.table_name AND c.index_name = i.index_name) \", `WHERE i.table_name = ${this.escape(tableName)}`, \" AND u.table_owner = \", owner ? this.escape(owner) : \"USER\", \" ORDER BY index_name, column_position\"];\n    return sql.join(\"\");\n  }\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n    if (typeof indexName !== \"string\") {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join(\"_\")}`);\n    }\n    return `DROP INDEX ${this.quoteIdentifier(indexName)}`;\n  }\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n    attribute.onUpdate = \"\";\n    if (attribute.references) {\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log(\"Oracle does not support self referencial constraints, we will remove it but we recommend restructuring your query\");\n        attribute.onDelete = \"\";\n      }\n    }\n    let template;\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IN(${_.map(attribute.values, value => {\n        return this.escape(value);\n      }).join(\", \")}))`;\n      return template;\n    }\n    if (attribute.type instanceof DataTypes.JSON) {\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IS JSON)`;\n      return template;\n    }\n    if (attribute.type instanceof DataTypes.BOOLEAN) {\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IN('1', '0'))`;\n      return template;\n    }\n    if (attribute.autoIncrement) {\n      template = \" NUMBER(*,0) GENERATED BY DEFAULT ON NULL AS IDENTITY\";\n    } else if (attribute.type && attribute.type.key === DataTypes.DOUBLE.key) {\n      template = attribute.type.toSql();\n    } else if (attribute.type) {\n      let unsignedTemplate = \"\";\n      if (attribute.type._unsigned) {\n        attribute.type._unsigned = false;\n        unsignedTemplate += ` check(${this.quoteIdentifier(attribute.field)} >= 0)`;\n      }\n      template = attribute.type.toString();\n      template += unsignedTemplate;\n    } else {\n      template = \"\";\n    }\n    if (attribute.type && attribute.type !== \"TEXT\" && attribute.type._binary !== true && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n    if (!attribute.autoIncrement) {\n      if (attribute.allowNull === false) {\n        template += \" NOT NULL\";\n      } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n        template += \" NULL\";\n      }\n    }\n    if (attribute.unique === true && !attribute.primaryKey) {\n      template += \" UNIQUE\";\n    }\n    if (attribute.primaryKey) {\n      template += \" PRIMARY KEY\";\n    }\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier(\"id\")})`;\n      }\n      if (attribute.onDelete && attribute.onDelete.toUpperCase() !== \"NO ACTION\") {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n    }\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {};\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      const attributeName = attribute.field || key;\n      result[attributeName] = this.attributeToSQL(attribute, __spreadValues({\n        attributeName\n      }, options));\n    }\n    return result;\n  }\n  createTrigger() {\n    throwMethodUndefined(\"createTrigger\");\n  }\n  dropTrigger() {\n    throwMethodUndefined(\"dropTrigger\");\n  }\n  renameTrigger() {\n    throwMethodUndefined(\"renameTrigger\");\n  }\n  createFunction() {\n    throwMethodUndefined(\"createFunction\");\n  }\n  dropFunction() {\n    throwMethodUndefined(\"dropFunction\");\n  }\n  renameFunction() {\n    throwMethodUndefined(\"renameFunction\");\n  }\n  getConstraintsOnColumn(table, column) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    column = this.getCatalogName(column);\n    const sql = [\"SELECT CONSTRAINT_NAME FROM user_cons_columns WHERE TABLE_NAME = \", this.escape(tableName), \" and OWNER = \", table.schema ? this.escape(schemaName) : \"USER\", \" and COLUMN_NAME = \", this.escape(column), \" AND POSITION IS NOT NULL ORDER BY POSITION\"].join(\"\");\n    return sql;\n  }\n  getForeignKeysQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const sql = ['SELECT DISTINCT  a.table_name \"tableName\", a.constraint_name \"constraintName\", a.owner \"owner\",  a.column_name \"columnName\",', ' b.table_name \"referencedTableName\", b.column_name \"referencedColumnName\"', \" FROM all_cons_columns a\", \" JOIN all_constraints c ON a.owner = c.owner AND a.constraint_name = c.constraint_name\", \" JOIN all_cons_columns b ON c.owner = b.owner AND c.r_constraint_name = b.constraint_name\", \" WHERE c.constraint_type  = 'R'\", \" AND a.table_name = \", this.escape(tableName), \" AND a.owner = \", table.schema ? this.escape(schemaName) : \"USER\", \" ORDER BY a.table_name, a.constraint_name\"].join(\"\");\n    return sql;\n  }\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return this.dropConstraintQuery(tableName, foreignKey);\n  }\n  getPrimaryKeyConstraintQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const sql = [\"SELECT cols.column_name, atc.identity_column \", \"FROM all_constraints cons, all_cons_columns cols \", \"INNER JOIN all_tab_columns atc ON(atc.table_name = cols.table_name AND atc.COLUMN_NAME = cols.COLUMN_NAME )\", \"WHERE cols.table_name = \", this.escape(tableName), \"AND cols.owner = \", table.schema ? this.escape(schemaName) : \"USER \", \"AND cons.constraint_type = 'P' \", \"AND cons.constraint_name = cols.constraint_name \", \"AND cons.owner = cols.owner \", \"ORDER BY cols.table_name, cols.position\"].join(\"\");\n    return sql;\n  }\n  dropConstraintQuery(tableName, constraintName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${constraintName}`;\n  }\n  setIsolationLevelQuery(value, options) {\n    if (options.parent) {\n      return;\n    }\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return \"SET TRANSACTION ISOLATION LEVEL READ COMMITTED;\";\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return \"SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;\";\n      default:\n        throw new Error(`isolation level \"${value}\" is not supported`);\n    }\n  }\n  getAliasToken() {\n    return \"\";\n  }\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;\n    }\n    return \"BEGIN TRANSACTION\";\n  }\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n    return \"COMMIT TRANSACTION\";\n  }\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TO SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;\n    }\n    return \"ROLLBACK TRANSACTION\";\n  }\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    let str;\n    if (smth instanceof Utils.Json) {\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(\" AND \");\n      }\n      if (smth.path) {\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n        if (smth.value) {\n          str += util.format(\" = %s\", this.escape(smth.value));\n        }\n        return str;\n      }\n    }\n    if (smth instanceof Utils.Cast) {\n      if (smth.val instanceof Utils.SequelizeMethod) {\n        str = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n        if (smth.type === \"boolean\") {\n          str = `(CASE WHEN ${str}='true' THEN 1 ELSE 0 END)`;\n          return `CAST(${str} AS NUMBER)`;\n        }\n        if (smth.type === \"timestamptz\" && /json_value\\(/.test(str)) {\n          str = str.slice(0, -1);\n          return `${str} RETURNING TIMESTAMP WITH TIME ZONE)`;\n        }\n      }\n    }\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== \"string\") {\n      return false;\n    }\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf(\"(\");\n        hasJsonFunction = true;\n        continue;\n      }\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === \"(\") {\n          openingBrackets++;\n        } else if (capturedToken === \")\") {\n          closingBrackets++;\n        } else if (capturedToken === \";\") {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n      break;\n    }\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n    return hasJsonFunction;\n  }\n  jsonPathExtractionQuery(column, path) {\n    let paths = _.toPath(path);\n    const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n    paths = paths.map(subPath => {\n      return /\\D/.test(subPath) ? Utils.addTicks(subPath, '\"') : subPath;\n    });\n    const pathStr = this.escape([\"$\"].concat(paths).join(\".\").replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (__, digit) => `[${digit}]`));\n    return `json_value(${quotedColumn},${pathStr})`;\n  }\n  addLimitAndOffset(options, model) {\n    let fragment = \"\";\n    const offset = options.offset || 0,\n      isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n    let orders = {};\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n    if (options.limit || options.offset) {\n      if (!orders.mainQueryOrder || !orders.mainQueryOrder.length || isSubQuery && (!orders.subQueryOrder || !orders.subQueryOrder.length)) {\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(model.primaryKeyField)}`;\n        fragment += ` ORDER BY ${tablePkFragment}`;\n      }\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n    return fragment;\n  }\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n  quoteIdentifier(identifier) {\n    let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const optForceQuote = force;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n    const regExp = /^(([\\w][\\w\\d_]*))$/g;\n    if (optForceQuote !== true && optQuoteIdentifiers === false && regExp.test(rawIdentifier) && !ORACLE_RESERVED_WORDS.includes(rawIdentifier.toUpperCase())) {\n      return rawIdentifier;\n    }\n    return Utils.addTicks(rawIdentifier, '\"');\n  }\n  bindParam(bind) {\n    let posOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return value => {\n      bind.push(value);\n      return `:${bind.length + posOffset}`;\n    };\n  }\n  authTestQuery() {\n    return \"SELECT 1+1 AS result FROM DUAL\";\n  }\n}\nfunction throwMethodUndefined(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n}","map":{"version":3,"mappings":"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","names":["__export","OracleQueryGenerator","Utils","require","DataTypes","AbstractQueryGenerator","_","util","Transaction","ORACLE_RESERVED_WORDS","JSON_FUNCTION_REGEX","JSON_OPERATOR_REGEX","TOKEN_CAPTURE_REGEX","constructor","options","getCatalogName","value","quoteIdentifiers","quotedValue","quoteIdentifier","toUpperCase","getSchemaNameAndTableName","table","tableName","schemaName","schema","createSchema","quotedSchema","escape","join","showSchemasQuery","dropSchema","quoteTable","versionQuery","createTableQuery","attributes","primaryKeys","foreignKeys","Object","create","attrStr","checkStr","values","attr","prototype","hasOwnProperty","call","dataType","includes","push","match","replace","trim","pkString","map","pk","length","fkey","indexOf","indexes","idxToDelete","forEach","index","idx","unique","fields","field","attribute","canContinue","uniqueKeys","keys","fieldIdx","currUnique","i","indexName","name","constraintToAdd","splice","each","columns","canBeUniq","primaryKey","currField","isString","attrToReplace","query","joinSQLFragments","tableExistsQuery","describeTableQuery","currTableName","renameTableQuery","before","after","showConstraintsQuery","showTablesQuery","dropTableQuery","addIndexQuery","rawTablename","addConstraintQuery","constraintSnippet","getConstraintSnippet","addColumnQuery","key","attributeToSQL","attributeName","context","removeColumnQuery","_alterForeignKeyConstraint","definition","attributeNameConstant","schemaNameConstant","tableNameConstant","getConsNameQuery","secondQuery","_modifyQuery","changeColumnQuery","sql","renameColumnQuery","attrBefore","newName","populateInsertQueryReturnIntoBinds","returningModelAttributes","returnTypes","inbindLength","returnAttributes","oracledb","sequelize","connectionManager","lib","outBindAttributes","outbind","outbindParam","bindParam","element","startsWith","substring","assign","_getBindDef","dir","BIND_OUT","returnAttribute","format","upsertQuery","insertValues","updateValues","where","model","rawAttributes","updateQuery","bind","insertQuery","result","bulkInsertQuery","fieldValueHashes","fieldMappedAttributes","executeMany","tuples","allColumns","inBindBindDefMap","outBindBindDefMap","fieldValueHash","forOwn","autoIncrement","inBindPosition","tuple","inbindParam","tempBindPositions","Error","returnColumn","returnColumnBindPositions","insertColumns","bindDef","type","BIND_IN","inbindAttributes","truncateTableQuery","deleteQuery","getWhereConditions","queryTmpl","limit","whereTmpl","showIndexesQuery","owner","removeIndexQuery","indexNameOrAttributes","underscore","isPlainObject","onUpdate","references","Model","log","onDelete","template","ENUM","toSql","JSON","BOOLEAN","DOUBLE","unsignedTemplate","_unsigned","toString","_binary","defaultValueSchemable","defaultValue","allowNull","withoutForeignKeyConstraints","attributesToSQL","__spreadValues","createTrigger","throwMethodUndefined","dropTrigger","renameTrigger","createFunction","dropFunction","renameFunction","getConstraintsOnColumn","column","getForeignKeysQuery","dropForeignKeyQuery","foreignKey","dropConstraintQuery","getPrimaryKeyConstraintQuery","constraintName","setIsolationLevelQuery","parent","ISOLATION_LEVELS","READ_UNCOMMITTED","READ_COMMITTED","REPEATABLE_READ","getAliasToken","startTransactionQuery","transaction","commitTransactionQuery","rollbackTransactionQuery","handleSequelizeMethod","smth","factory","prepend","str","Json","conditions","parseConditionObject","condition","jsonPathExtractionQuery","path","tail","_checkValidJsonStatement","paths","toPath","shift","Cast","val","SequelizeMethod","test","slice","stmt","currentIndex","openingBrackets","closingBrackets","hasJsonFunction","hasInvalidToken","string","substr","functionMatches","exec","operatorMatches","tokenMatches","capturedToken","quotedColumn","isIdentifierQuoted","subPath","addTicks","pathStr","concat","__","digit","addLimitAndOffset","fragment","offset","isSubQuery","hasIncludeWhere","hasIncludeRequired","hasMultiAssociation","orders","order","getQueryOrders","mainQueryOrder","subQueryOrder","tablePkFragment","tableAs","primaryKeyField","booleanValue","identifier","force","optForceQuote","optQuoteIdentifiers","rawIdentifier","removeTicks","regExp","posOffset","authTestQuery","methodName"],"sources":["C:\\Users\\rizla\\projects\\react\\NSBEHack-main\\nsbeapp\\node_modules\\sequelize\\src\\dialects\\oracle\\query-generator.js"],"sourcesContent":["// Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved\n\n'use strict';\n\nconst Utils = require('../../utils');\nconst DataTypes = require('../../data-types');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst _ = require('lodash');\nconst util = require('util');\nconst Transaction = require('../../transaction');\n\n/**\n * list of reserved words in Oracle DB 21c\n * source: https://www.oracle.com/pls/topic/lookup?ctx=dblatest&id=GUID-7B72E154-677A-4342-A1EA-C74C1EA928E6\n *\n * @private\n */\nconst ORACLE_RESERVED_WORDS = ['ACCESS', 'ADD', 'ALL', 'ALTER', 'AND', 'ANY', 'ARRAYLEN', 'AS', 'ASC', 'AUDIT', 'BETWEEN', 'BY', 'CHAR', 'CHECK', 'CLUSTER', 'COLUMN', 'COMMENT', 'COMPRESS', 'CONNECT', 'CREATE', 'CURRENT', 'DATE', 'DECIMAL', 'DEFAULT', 'DELETE', 'DESC', 'DISTINCT', 'DROP', 'ELSE', 'EXCLUSIVE', 'EXISTS', 'FILE', 'FLOAT', 'FOR', 'FROM', 'GRANT', 'GROUP', 'HAVING', 'IDENTIFIED', 'IMMEDIATE', 'IN', 'INCREMENT', 'INDEX', 'INITIAL', 'INSERT', 'INTEGER', 'INTERSECT', 'INTO', 'IS', 'LEVEL', 'LIKE', 'LOCK', 'LONG', 'MAXEXTENTS', 'MINUS', 'MODE', 'MODIFY', 'NOAUDIT', 'NOCOMPRESS', 'NOT', 'NOTFOUND', 'NOWAIT', 'NULL', 'NUMBER', 'OF', 'OFFLINE', 'ON', 'ONLINE', 'OPTION', 'OR', 'ORDER', 'PCTFREE', 'PRIOR', 'PRIVILEGES', 'PUBLIC', 'RAW', 'RENAME', 'RESOURCE', 'REVOKE', 'ROW', 'ROWID', 'ROWLABEL', 'ROWNUM', 'ROWS', 'SELECT', 'SESSION', 'SET', 'SHARE', 'SIZE', 'SMALLINT', 'SQLBUF', 'START', 'SUCCESSFUL', 'SYNONYM', 'SYSDATE', 'TABLE', 'THEN', 'TO', 'TRIGGER', 'UID', 'UNION', 'UNIQUE', 'UPDATE', 'USER', 'VALIDATE', 'VALUES', 'VARCHAR', 'VARCHAR2', 'VIEW', 'WHENEVER', 'WHERE', 'WITH'];\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\nexport class OracleQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n  }\n\n  /**\n   * Returns the value as it is stored in the Oracle DB\n   *\n   * @param {string} value\n   */\n  getCatalogName(value) {\n    if (value) {\n      if (this.options.quoteIdentifiers === false) {\n        const quotedValue = this.quoteIdentifier(value);\n        if (quotedValue === value) {\n          value = value.toUpperCase();\n        }\n      }\n    }\n    return value;\n  }\n\n  /**\n   * Returns the tableName and schemaName as it is stored the Oracle DB\n   *\n   * @param {object|string} table\n   */\n  getSchemaNameAndTableName(table) {\n    const tableName = this.getCatalogName(table.tableName || table);\n    const schemaName = this.getCatalogName(table.schema);\n    return [tableName, schemaName];\n  }\n\n  createSchema(schema) {\n    const quotedSchema = this.quoteIdentifier(schema);\n    return [\n      'DECLARE',\n      'USER_FOUND BOOLEAN := FALSE;',\n      'BEGIN',\n      ' BEGIN',\n      '   EXECUTE IMMEDIATE ',\n      this.escape(`CREATE USER ${quotedSchema} IDENTIFIED BY 12345 DEFAULT TABLESPACE USERS`),\n      ';',\n      '   EXCEPTION WHEN OTHERS THEN',\n      '     IF SQLCODE != -1920 THEN',\n      '       RAISE;',\n      '     ELSE',\n      '       USER_FOUND := TRUE;',\n      '     END IF;',\n      ' END;',\n      ' IF NOT USER_FOUND THEN',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT \"CONNECT\" TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE TABLE TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE VIEW TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE ANY TRIGGER TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE ANY PROCEDURE TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE SEQUENCE TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`GRANT CREATE SYNONYM TO ${quotedSchema}`),\n      ';',\n      '    EXECUTE IMMEDIATE ',\n      this.escape(`ALTER USER ${quotedSchema} QUOTA UNLIMITED ON USERS`),\n      ';',\n      ' END IF;',\n      'END;'\n    ].join(' ');\n  }\n\n  showSchemasQuery() {\n    return 'SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE COMMON = (\\'NO\\') AND USERNAME != user';\n  }\n\n  dropSchema(schema) {\n    return [\n      'BEGIN',\n      'EXECUTE IMMEDIATE ',\n      this.escape(`DROP USER ${this.quoteTable(schema)} CASCADE`),\n      ';',\n      'EXCEPTION WHEN OTHERS THEN',\n      '  IF SQLCODE != -1918 THEN',\n      '    RAISE;',\n      '  END IF;',\n      'END;'\n    ].join(' ');\n  }\n\n  versionQuery() {\n    return \"SELECT VERSION_FULL FROM PRODUCT_COMPONENT_VERSION WHERE PRODUCT LIKE 'Oracle%'\";\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [],\n      foreignKeys = Object.create(null),\n      attrStr = [],\n      checkStr = [];\n\n    const values = {\n      table: this.quoteTable(tableName)\n    };\n\n    // Starting by dealing with all attributes\n    for (let attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      attr = this.quoteIdentifier(attr);\n\n      // ORACLE doesn't support inline REFERENCES declarations: move to the end\n      if (dataType.includes('PRIMARY KEY')) {\n        // Primary key\n        primaryKeys.push(attr);\n        if (dataType.includes('REFERENCES')) {\n          const match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${attr} ${match[1].replace(/PRIMARY KEY/, '')}`);\n\n          // match[2] already has foreignKeys in correct format so we don't need to replace\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${attr} ${dataType.replace(/PRIMARY KEY/, '').trim()}`);\n        }\n      } else if (dataType.includes('REFERENCES')) {\n        // Foreign key\n        const match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${attr} ${match[1]}`);\n\n        // match[2] already has foreignKeys in correct format so we don't need to replace\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${attr} ${dataType}`);\n      }\n    }\n\n    values['attributes'] = attrStr.join(', ');\n\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (pkString.length > 0) {\n      values.attributes += `,PRIMARY KEY (${pkString})`;\n    }\n\n    // Dealing with FKs\n    for (const fkey in foreignKeys) {\n      if (!Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) continue; \n      // Oracle default response for FK, doesn't support if defined\n      if (foreignKeys[fkey].indexOf('ON DELETE NO ACTION') > -1) {\n        foreignKeys[fkey] = foreignKeys[fkey].replace('ON DELETE NO ACTION', '');\n      }\n      values.attributes += `,FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n    }\n\n    if (checkStr.length > 0) {\n      values.attributes += `, ${checkStr.join(', ')}`;\n    }\n\n    // Specific case for unique indexes with Oracle, we have to set the constraint on the column, if not, no FK will be possible (ORA-02270: no matching unique or primary key for this column-list)\n    if (options && options.indexes && options.indexes.length > 0) {\n      const idxToDelete = [];\n      options.indexes.forEach((index, idx) => {\n        if ('unique' in index && (index.unique === true || index.unique.length > 0 && index.unique !== false)) {\n          // If unique index, transform to unique constraint on column\n          const fields = index.fields.map(field => {\n            if (typeof field === 'string') {\n              return field;\n            } \n            return field.attribute;\n            \n          });\n\n          // Now we have to be sure that the constraint isn't already declared in uniqueKeys\n          let canContinue = true;\n          if (options.uniqueKeys) {\n            const keys = Object.keys(options.uniqueKeys);\n\n            for (let fieldIdx = 0; fieldIdx < keys.length; fieldIdx++) {\n              const currUnique = options.uniqueKeys[keys[fieldIdx]];\n\n              if (currUnique.fields.length === fields.length) {\n                // lengths are the same, possible same constraint\n                for (let i = 0; i < currUnique.fields.length; i++) {\n                  const field = currUnique.fields[i];\n\n                  if (_.includes(fields, field)) {\n                    canContinue = false;\n                  } else {\n                    // We have at least one different column, even if we found the same columns previously, we let the constraint be created\n                    canContinue = true;\n                    break;\n                  }\n                }\n              }\n            }\n\n            if (canContinue) {\n              const indexName = 'name' in index ? index.name : '';\n              const constraintToAdd = {\n                name: indexName,\n                fields\n              };\n              if (!('uniqueKeys' in options)) {\n                options.uniqueKeys = {};\n              }\n\n              options.uniqueKeys[indexName] = constraintToAdd;\n              idxToDelete.push(idx);\n            } else {\n              // The constraint already exists, we remove it from the list\n              idxToDelete.push(idx);\n            }\n          }\n        }\n      });\n      idxToDelete.forEach(idx => {\n        options.indexes.splice(idx, 1);\n      });\n    }\n\n    if (options && !!options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        let canBeUniq = false;\n\n        // Check if we can create the unique key\n        primaryKeys.forEach(primaryKey => {\n          // We can create an unique constraint if it's not on the primary key AND if it doesn't have unique in its definition\n          // We replace quotes in primary key with ''\n          // Primary key would be a list with double quotes in it so we remove the double quotes\n          primaryKey = primaryKey.replace(/\"/g, '');\n\n          // We check if the unique indexes are already a part of primary key or not\n          // If it is not then we set canbeuniq to true and add a unique constraint to these fields.\n          // Else we can ignore unique constraint on these\n          if (!_.includes(columns.fields, primaryKey)) {\n            canBeUniq = true;\n          }\n        });\n\n        columns.fields.forEach(field => {\n          let currField = '';\n          if (!_.isString(field)) {\n            currField = field.attribute.replace(/[.,\"\\s]/g, '');\n          } else {\n            currField = field.replace(/[.,\"\\s]/g, '');\n          }\n          if (currField in attributes) {\n            // If canBeUniq is false we need not replace the UNIQUE for the attribute\n            // So we replace UNIQUE with '' only if there exists a primary key\n            if (attributes[currField].toUpperCase().indexOf('UNIQUE') > -1 && canBeUniq) {\n              // We generate the attribute without UNIQUE\n              const attrToReplace = attributes[currField].replace('UNIQUE', '');\n              // We replace in the final string\n              values.attributes = values.attributes.replace(attributes[currField], attrToReplace);\n            }\n          }\n        });\n\n        // Oracle cannot have an unique AND a primary key on the same fields, prior to the primary key\n        if (canBeUniq) {\n          const index = options.uniqueKeys[columns.name];\n          delete options.uniqueKeys[columns.name];\n          indexName = indexName.replace(/[.,\\s]/g, '');\n          columns.name = indexName;\n          options.uniqueKeys[indexName] = index;\n\n          // Autogenerate Constraint name, if no indexName is given\n          if (indexName.length === 0) {\n            values.attributes += `,UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ') })`;\n          } else {\n            values.attributes +=\n              `, CONSTRAINT ${this.quoteIdentifier(indexName)} UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ') })`;\n          }\n        }\n      });\n    }\n\n    // we replace single quotes by two quotes in order for the execute statement to work\n    const query = Utils.joinSQLFragments([\n      'CREATE TABLE',\n      values.table,\n      `(${values.attributes})`\n    ]);\n\n    return Utils.joinSQLFragments([\n      'BEGIN',\n      'EXECUTE IMMEDIATE',\n      `${this.escape(query)};`,\n      'EXCEPTION WHEN OTHERS THEN',\n      'IF SQLCODE != -955 THEN',\n      'RAISE;',\n      'END IF;',\n      'END;'\n    ]);\n  }\n\n  tableExistsQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    return `SELECT TABLE_NAME FROM ALL_TABLES WHERE TABLE_NAME = ${this.escape(tableName)} AND OWNER = ${table.schema ? this.escape(schemaName) : 'USER'}`;\n  }\n  \n  describeTableQuery(tableName, schema) {\n    const currTableName = this.getCatalogName(tableName.tableName || tableName);\n    schema = this.getCatalogName(schema);\n    // name, type, datalength (except number / nvarchar), datalength varchar, datalength number, nullable, default value, primary ?\n    return [\n      'SELECT atc.COLUMN_NAME, atc.DATA_TYPE, atc.DATA_LENGTH, atc.CHAR_LENGTH, atc.DEFAULT_LENGTH, atc.NULLABLE, ucc.constraint_type ',\n      'FROM all_tab_columns atc ',\n      'LEFT OUTER JOIN ',\n      '(SELECT acc.column_name, acc.table_name, ac.constraint_type FROM all_cons_columns acc INNER JOIN all_constraints ac ON acc.constraint_name = ac.constraint_name) ucc ',\n      'ON (atc.table_name = ucc.table_name AND atc.COLUMN_NAME = ucc.COLUMN_NAME) ',\n      schema\n        ? `WHERE (atc.OWNER = ${this.escape(schema)}) `\n        : 'WHERE atc.OWNER = USER ',\n      `AND (atc.TABLE_NAME = ${this.escape(currTableName)})`,\n      'ORDER BY atc.COLUMN_NAME, CONSTRAINT_TYPE DESC'\n    ].join('');\n  }\n\n  renameTableQuery(before, after) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(before),\n      'RENAME TO',\n      this.quoteTable(after)\n    ]);\n  }\n\n  showConstraintsQuery(table) {\n    const tableName = this.getCatalogName(table.tableName || table);\n    return `SELECT CONSTRAINT_NAME constraint_name FROM user_cons_columns WHERE table_name = ${this.escape(tableName)}`;\n  }\n\n  showTablesQuery() {\n    return 'SELECT owner as table_schema, table_name, 0 as lvl FROM all_tables where OWNER IN(SELECT USERNAME AS \"schema_name\" FROM ALL_USERS WHERE ORACLE_MAINTAINED = \\'N\\')';\n  }\n\n  dropTableQuery(tableName) {\n    return Utils.joinSQLFragments([\n      'BEGIN ',\n      'EXECUTE IMMEDIATE \\'DROP TABLE',\n      this.quoteTable(tableName),\n      'CASCADE CONSTRAINTS PURGE\\';',\n      'EXCEPTION WHEN OTHERS THEN',\n      ' IF SQLCODE != -942 THEN',\n      '   RAISE;',\n      ' END IF;',\n      'END;'\n    ]);\n  }\n\n  /*\n    Modifying the indexname so that it is prefixed with the schema name\n    otherwise Oracle tries to add the index to the USER schema\n   @overide\n  */\n  addIndexQuery(tableName, attributes, options, rawTablename) {\n    if (typeof tableName !== 'string' && attributes.name) {\n      attributes.name = `${tableName.schema}.${attributes.name}`;\n    }\n    return super.addIndexQuery(tableName, attributes, options, rawTablename);\n  }\n\n  addConstraintQuery(tableName, options) {\n    options = options || {};\n\n    const constraintSnippet = this.getConstraintSnippet(tableName, options);\n\n    tableName = this.quoteTable(tableName);\n    return `ALTER TABLE ${tableName} ADD ${constraintSnippet};`;\n  }\n\n  addColumnQuery(table, key, dataType) {\n    dataType.field = key;\n\n    const attribute = Utils.joinSQLFragments([\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        attributeName: key,\n        context: 'addColumn'\n      })\n    ]);\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'ADD',\n      attribute\n    ]);\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP COLUMN',\n      this.quoteIdentifier(attributeName),\n      ';'\n    ]);\n  }\n\n  /**\n   * Function to add new foreign key to the attribute \n   * Block for add and drop foreign key constraint query\n   * taking the assumption that there is a single column foreign key reference always\n   * i.e. we always do - FOREIGN KEY (a) reference B(a) during createTable queryGenerator\n   * so there would be one and only one match for a constraint name for each column\n   * and every foreign keyed column would have a different constraint name\n   * Since sequelize doesn't support multiple column foreign key, added complexity to\n   * add the feature isn't needed\n   *\n   * @param {string} definition The operation that needs to be performed on the attribute\n   * @param {string|object} table The table that needs to be altered\n   * @param {string} attributeName The name of the attribute which would get altered\n   */\n  _alterForeignKeyConstraint(definition, table, attributeName) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const attributeNameConstant = this.escape(this.getCatalogName(attributeName));\n    const schemaNameConstant = table.schema ? this.escape(this.getCatalogName(schemaName)) : 'USER';\n    const tableNameConstant = this.escape(this.getCatalogName(tableName));\n    const getConsNameQuery = [\n      'SELECT constraint_name INTO cons_name',\n      'FROM (',\n      '  SELECT DISTINCT cc.owner, cc.table_name, cc.constraint_name, cc.column_name AS cons_columns',\n      '  FROM all_cons_columns cc, all_constraints c',\n      '  WHERE cc.owner = c.owner',\n      '  AND cc.table_name = c.table_name',\n      '  AND cc.constraint_name = c.constraint_name',\n      '  AND c.constraint_type = \\'R\\'',\n      '  GROUP BY cc.owner, cc.table_name, cc.constraint_name, cc.column_name',\n      ')',\n      'WHERE owner =',\n      schemaNameConstant,\n      'AND table_name =',\n      tableNameConstant,\n      'AND cons_columns =',\n      attributeNameConstant,\n      ';'\n    ].join(' ');\n    const secondQuery = Utils.joinSQLFragments([\n      `ALTER TABLE ${this.quoteIdentifier(tableName)}`,\n      'ADD FOREIGN KEY',\n      `(${this.quoteIdentifier(attributeName)})`,\n      definition.replace(/.+?(?=REFERENCES)/, '')\n    ]);\n    return [\n      'BEGIN',\n      getConsNameQuery,\n      'EXCEPTION',\n      'WHEN NO_DATA_FOUND THEN',\n      ' CONS_NAME := NULL;',\n      'END;',\n      'IF CONS_NAME IS NOT NULL THEN',\n      ` EXECUTE IMMEDIATE 'ALTER TABLE ${this.quoteTable(table)} DROP CONSTRAINT \"'||CONS_NAME||'\"';`,\n      'END IF;',\n      `EXECUTE IMMEDIATE ${this.escape(secondQuery)};`\n    ].join(' ');\n  }\n\n  /**\n   * Function to alter table modify\n   *\n   * @param {string} definition The operation that needs to be performed on the attribute\n   * @param {object|string} table The table that needs to be altered\n   * @param {string} attributeName The name of the attribute which would get altered\n   */\n  _modifyQuery(definition, table, attributeName) {\n    const query = Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'MODIFY',\n      this.quoteIdentifier(attributeName),\n      definition\n    ]);\n    const secondQuery = query.replace('NOT NULL', '').replace('NULL', '');\n    return [\n      'BEGIN',\n      `EXECUTE IMMEDIATE ${this.escape(query)};`,\n      'EXCEPTION',\n      'WHEN OTHERS THEN',\n      ' IF SQLCODE = -1442 OR SQLCODE = -1451 THEN',\n      // We execute the statement without the NULL / NOT NULL clause if the first statement failed due to this\n      `   EXECUTE IMMEDIATE ${this.escape(secondQuery)};`,\n      ' ELSE',\n      '   RAISE;',\n      ' END IF;',\n      'END;'\n    ].join(' ');\n  }\n\n  changeColumnQuery(table, attributes) {\n    const sql = [\n      'DECLARE',\n      'CONS_NAME VARCHAR2(200);',\n      'BEGIN'\n    ];\n    for (const attributeName in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attributeName)) continue;\n      const definition = attributes[attributeName];\n      if (definition.match(/REFERENCES/)) {\n        sql.push(this._alterForeignKeyConstraint(definition, table, attributeName));\n      } else {\n        // Building the modify query\n        sql.push(this._modifyQuery(definition, table, attributeName));\n      }\n    }\n    sql.push('END;');\n    return sql.join(' ');\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(newName)}`;\n  }\n\n  /**\n   * Populates the returnAttributes array with outbind bindByPosition values\n   * and also the options.outBindAttributes map with bindDef for outbind of InsertQuery\n   *\n   * @param {Array} returningModelAttributes\n   * @param {Array} returnTypes\n   * @param {number} inbindLength\n   * @param {object} returnAttributes\n   * @param {object} options\n   *\n   * @private\n   */\n  populateInsertQueryReturnIntoBinds(returningModelAttributes, returnTypes, inbindLength, returnAttributes, options) {\n    const oracledb = this.sequelize.connectionManager.lib;\n    const outBindAttributes = Object.create(null);\n    const outbind = [];\n    const outbindParam = this.bindParam(outbind, inbindLength);\n    returningModelAttributes.forEach((element, index) => {\n      // generateReturnValues function quotes identifier based on the quoteIdentifier option\n      // If the identifier starts with a quote we remove it else we use it as is\n      if (element.startsWith('\"')) {\n        element = element.substring(1, element.length - 1);\n      }\n      outBindAttributes[element] = Object.assign(returnTypes[index]._getBindDef(oracledb), { dir: oracledb.BIND_OUT });\n      const returnAttribute = `${this.format(undefined, undefined, { context: 'INSERT' }, outbindParam)}`;\n      returnAttributes.push(returnAttribute);\n    });\n    options.outBindAttributes = outBindAttributes;\n  }\n\n  /**\n   * Override of upsertQuery, Oracle specific\n   * Using PL/SQL for finding the row\n   *\n   * @param {object|string} tableName\n   * @param {Array} insertValues\n   * @param {Array} updateValues\n   * @param {Array} where\n   * @param {object} model\n   * @param {object} options\n   */\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    const rawAttributes = model.rawAttributes;\n    const updateQuery = this.updateQuery(tableName, updateValues, where, options, rawAttributes);\n    // This bind is passed so that the insert query starts appending to this same bind array\n    options.bind = updateQuery.bind;\n    const insertQuery = this.insertQuery(tableName, insertValues, rawAttributes, options);\n\n    const sql = [\n      'DECLARE ',\n      'BEGIN ',\n      updateQuery.query ? [ \n        updateQuery.query,\n        '; ',\n        ' IF ( SQL%ROWCOUNT = 0 ) THEN ',\n        insertQuery.query,\n        ' :isUpdate := 0; ',\n        'ELSE ',\n        ' :isUpdate := 1; ',\n        ' END IF; '\n      ].join('') : [\n        insertQuery.query,\n        ' :isUpdate := 0; ',\n        // If there is a conflict on insert we ignore\n        'EXCEPTION WHEN OTHERS THEN',\n        ' IF SQLCODE != -1 THEN',\n        '   RAISE;',\n        ' END IF;'\n      ].join(''),\n      'END;'\n    ];\n\n    const query = sql.join('');\n    const result = { query };\n    \n    if (options.bindParam !== false) {\n      result.bind = updateQuery.bind || insertQuery.bind;\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns an insert into command for multiple values.\n   *\n   * @param {string} tableName\n   * @param {object} fieldValueHashes\n   * @param {object} options\n   * @param {object} fieldMappedAttributes\n   *\n   * @private\n   */\n  bulkInsertQuery(tableName, fieldValueHashes, options, fieldMappedAttributes) {\n    options = options || {};\n    options.executeMany = true;\n    fieldMappedAttributes = fieldMappedAttributes || {};\n\n    const tuples = [];\n    const allColumns = {};\n    const inBindBindDefMap = {};\n    const outBindBindDefMap = {};\n    const oracledb = this.sequelize.connectionManager.lib;\n\n    // Generating the allColumns map\n    // The data is provided as an array of objects. \n    // Each object may contain differing numbers of attributes. \n    // A set of the attribute names that are used in all objects must be determined. \n    // The allColumns map contains the column names and indicates whether the value is generated or not\n    // We set allColumns[key] to true if the field is an\n    // auto-increment field and the value given is null and fieldMappedAttributes[key]\n    // is valid for the specific column else it is set to false\n    for (const fieldValueHash of fieldValueHashes) {\n      _.forOwn(fieldValueHash, (value, key) => {\n        allColumns[key] = fieldMappedAttributes[key] && fieldMappedAttributes[key].autoIncrement === true && value === null;\n      });\n    }\n\n    // Building the inbind parameter\n    // A list that would have inbind positions like [:1, :2, :3...] to be used in generating sql string\n    let inBindPosition;\n    // Iterating over each row of the fieldValueHashes\n    for (const fieldValueHash of fieldValueHashes) {\n      // Has each column for a row after coverting it to appropriate format using this.format function\n      // like ['Mick', 'Broadstone', 2022-02-16T05:24:18.949Z, 2022-02-16T05:24:18.949Z],\n      const tuple = [];\n      // A function expression for this.bindParam/options.bindparam function\n      // This function is passed to this.format function which inserts column values to the tuple list\n      // using _bindParam/_stringify function in data-type.js file\n      const inbindParam = options.bindParam === undefined ? this.bindParam(tuple) : options.bindParam;\n      // We are iterating over each col\n      // and pushing the given values to tuple list using this.format function\n      // and also simultaneously generating the bindPosition\n      // tempBindPostions has the inbind positions\n      const tempBindPositions = Object.keys(allColumns).map(key => {\n        if (allColumns[key] === true) {\n          // We had set allAttributes[key] to true since at least one row for an auto increment column was null\n          // If we get any other row that has this specific column as non-null we must raise an error\n          // Since for an auto-increment column, either all row has to be null or all row has to be a non-null\n          if (fieldValueHash[key] !== null) {\n            throw Error('For an auto-increment column either all row must be null or non-null, a mix of null and non-null is not allowed!');\n          }\n          // Return DEFAULT for auto-increment column and if all values for the column is null in each row\n          return 'DEFAULT';\n        }\n        // Sanitizes the values given by the user and pushes it to the tuple list using inBindParam function and\n        // also generates the inbind position for the sql string for example (:1, :2, :3.....) which is a by product of the push\n        return this.format(fieldValueHash[key], fieldMappedAttributes[key], { context: 'INSERT' }, inbindParam);\n      });\n\n      // Even though the bind variable positions are calculated for each row we only retain the values for the first row \n      // since the values will be identical\n      if (!inBindPosition) {\n        inBindPosition = tempBindPositions;\n      }\n      // Adding the row to the array of rows that will be supplied to executeMany()\n      tuples.push(tuple);\n    }\n\n    // The columns that we are expecting to be returned from the DB like [\"id1\", \"id2\"...]\n    const returnColumn = [];\n    // The outbind positions for the returning columns like [:3, :4, :5....]\n    const returnColumnBindPositions = [];\n    // Has the columns name in which data would be inserted like [\"id\", \"name\".....]\n    const insertColumns = [];\n    // Iterating over the allColumns keys to get the bindDef for inbind and outbinds\n    // and also to get the list of insert and return column after applying this.quoteIdentifier\n    for (const key of Object.keys(allColumns)) {\n      // If fieldMappenAttributes[attr] is defined we generate the bindDef \n      // and return clause else we can skip it\n      if (fieldMappedAttributes[key]) {\n        // BindDef for the specific column\n        const bindDef = fieldMappedAttributes[key].type._getBindDef(oracledb);\n        if (allColumns[key]) {\n          // Binddef for outbinds\n          bindDef.dir = oracledb.BIND_OUT;\n          outBindBindDefMap[key] = bindDef;\n\n          // Building the outbind parameter list\n          // ReturnColumn has the column name for example \"id\", \"usedId\", quoting depends on quoteIdentifier option\n          returnColumn.push(this.quoteIdentifier(key));\n          // Pushing the outbind index to the returnColumnPositions to generate (:3, :4, :5)\n          // The start offset depend on the tuple length (bind array size of a particular row)\n          // the outbind position starts after the position where inbind position ends\n          returnColumnBindPositions.push(`:${tuples[0].length + returnColumn.length}`);\n        } else {\n          // Binddef for inbinds\n          bindDef.dir = oracledb.BIND_IN;\n          inBindBindDefMap[key] = bindDef;\n        }\n      }\n      // Quoting and pushing each insert column based on quoteIdentifier option\n      insertColumns.push(this.quoteIdentifier(key));\n    }\n   \n    // Generating the sql query\n    let query = Utils.joinSQLFragments([\n      'INSERT',\n      'INTO',\n      // Table name for the table in which data needs to inserted\n      this.quoteTable(tableName),\n      // Columns names for the columns of the table (example \"a\", \"b\", \"c\" - quoting depends on the quoteidentifier option)\n      `(${insertColumns.join(',')})`,\n      'VALUES',\n      // InBind position for the insert query (for example :1, :2, :3....)\n      `(${inBindPosition})`\n    ]);\n\n    // If returnColumn.length is > 0\n    // then the returning into clause is needed\n    if (returnColumn.length > 0) {\n      options.outBindAttributes = outBindBindDefMap;\n      query = Utils.joinSQLFragments([\n        query,\n        'RETURNING',\n        // List of return column (for example \"id\", \"userId\"....)\n        `${returnColumn.join(',')}`,\n        'INTO',\n        // List of outbindPosition (for example :4, :5, :6....)\n        // Start offset depends on where inbindPosition end\n        `${returnColumnBindPositions}`\n      ]);\n    }\n\n    // Binding the bind variable to result\n    const result = { query };\n    // Binding the bindParam to result\n    // Tuple has each row for the insert query\n    result.bind = tuples;\n    // Setting options.inbindAttribute\n    options.inbindAttributes = inBindBindDefMap;\n    return result;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options, model) {\n    options = options || {};\n\n    const table = tableName;\n\n    where = this.getWhereConditions(where, null, model, options);\n    let queryTmpl;\n    // delete with limit <l> and optional condition <e> on Oracle: DELETE FROM <t> WHERE rowid in (SELECT rowid FROM <t> WHERE <e> AND rownum <= <l>)\n    // Note that the condition <e> has to be in the subquery; otherwise, the subquery would select <l> arbitrary rows.\n    if (options.limit) {\n      const whereTmpl = where ? ` AND ${where}` : '';\n      queryTmpl =\n        `DELETE FROM ${this.quoteTable(table)} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(table)} WHERE rownum <= ${this.escape(options.limit)}${ \n          whereTmpl \n        })`;\n    } else {\n      const whereTmpl = where ? ` WHERE ${where}` : '';\n      queryTmpl = `DELETE FROM ${this.quoteTable(table)}${whereTmpl}`;\n    }\n    return queryTmpl;\n  }\n\n  showIndexesQuery(table) {\n    const [tableName, owner] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      'SELECT i.index_name,i.table_name, i.column_name, u.uniqueness, i.descend, c.constraint_type ',\n      'FROM all_ind_columns i ',\n      'INNER JOIN all_indexes u ',\n      'ON (u.table_name = i.table_name AND u.index_name = i.index_name) ',\n      'LEFT OUTER JOIN all_constraints c ',\n      'ON (c.table_name = i.table_name AND c.index_name = i.index_name) ',\n      `WHERE i.table_name = ${this.escape(tableName)}`,\n      ' AND u.table_owner = ',\n      owner ? this.escape(owner) : 'USER',\n      ' ORDER BY index_name, column_position'\n    ];\n\n    return sql.join('');\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName }_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX ${this.quoteIdentifier(indexName)}`;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    // TODO: Address on update cascade issue whether to throw error or ignore.\n    // Add this to documentation when merging to sequelize-main\n    // ON UPDATE CASCADE IS NOT SUPPORTED BY ORACLE.\n    attribute.onUpdate = '';\n\n    // handle self referential constraints\n    if (attribute.references) {\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log(\n          'Oracle does not support self referencial constraints, ' +\n            'we will remove it but we recommend restructuring your query'\n        );\n        attribute.onDelete = '';\n      }\n    }\n\n    let template;\n\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n\n      // enums are a special case\n      template = attribute.type.toSql();\n      template +=\n        ` CHECK (${this.quoteIdentifier(options.attributeName)} IN(${ \n          _.map(attribute.values, value => {\n            return this.escape(value);\n          }).join(', ') \n        }))`;\n      return template;\n    } \n    if (attribute.type instanceof DataTypes.JSON) {\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(options.attributeName)} IS JSON)`;\n      return template;\n    } \n    if (attribute.type instanceof DataTypes.BOOLEAN) {\n      template = attribute.type.toSql();\n      template +=\n        ` CHECK (${this.quoteIdentifier(options.attributeName)} IN('1', '0'))`;\n      return template;\n    } \n    if (attribute.autoIncrement) {\n      template = ' NUMBER(*,0) GENERATED BY DEFAULT ON NULL AS IDENTITY';\n    } else if (attribute.type && attribute.type.key === DataTypes.DOUBLE.key) {\n      template = attribute.type.toSql();\n    } else if (attribute.type) {\n      // setting it to false because oracle doesn't support unsigned int so put a check to make it behave like unsigned int\n      let unsignedTemplate = '';\n      if (attribute.type._unsigned) {\n        attribute.type._unsigned = false;\n        unsignedTemplate += ` check(${this.quoteIdentifier(attribute.field)} >= 0)`;\n      }\n      template = attribute.type.toString();\n      template += unsignedTemplate;\n    } else {\n      template = '';\n    }\n    \n\n    // Blobs/texts cannot have a defaultValue\n    if (\n      attribute.type &&\n      attribute.type !== 'TEXT' &&\n      attribute.type._binary !== true &&\n      Utils.defaultValueSchemable(attribute.defaultValue)\n    ) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (!attribute.autoIncrement) {\n      // If autoincrement, not null is setted automatically\n      if (attribute.allowNull === false) {\n        template += ' NOT NULL';\n      } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n        template += ' NULL';\n      }\n    }\n\n    if (attribute.unique === true && !attribute.primaryKey) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if ((!options || !options.withoutForeignKeyConstraints) && attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key) })`;\n      } else {\n        template += ` (${this.quoteIdentifier('id') })`;\n      }\n\n      if (attribute.onDelete && attribute.onDelete.toUpperCase() !== 'NO ACTION') {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      const attributeName = attribute.field || key;\n      result[attributeName] = this.attributeToSQL(attribute, { attributeName, ...options });\n    }\n\n    return result;\n  }\n\n  createTrigger() {\n    throwMethodUndefined('createTrigger');\n  }\n\n  dropTrigger() {\n    throwMethodUndefined('dropTrigger');\n  }\n\n  renameTrigger() {\n    throwMethodUndefined('renameTrigger');\n  }\n\n  createFunction() {\n    throwMethodUndefined('createFunction');\n  }\n\n  dropFunction() {\n    throwMethodUndefined('dropFunction');\n  }\n\n  renameFunction() {\n    throwMethodUndefined('renameFunction');\n  }\n\n  getConstraintsOnColumn(table, column) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    column = this.getCatalogName(column);\n    const sql = [\n      'SELECT CONSTRAINT_NAME FROM user_cons_columns WHERE TABLE_NAME = ',\n      this.escape(tableName),\n      ' and OWNER = ',\n      table.schema ? this.escape(schemaName) : 'USER',\n      ' and COLUMN_NAME = ',\n      this.escape(column),\n      ' AND POSITION IS NOT NULL ORDER BY POSITION'\n    ].join('');\n\n    return sql;\n  }\n\n  getForeignKeysQuery(table) {\n    // We don't call quoteTable as we don't want the schema in the table name, Oracle seperates it on another field\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      'SELECT DISTINCT  a.table_name \"tableName\", a.constraint_name \"constraintName\", a.owner \"owner\",  a.column_name \"columnName\",', \n      ' b.table_name \"referencedTableName\", b.column_name \"referencedColumnName\"',\n      ' FROM all_cons_columns a',\n      ' JOIN all_constraints c ON a.owner = c.owner AND a.constraint_name = c.constraint_name',\n      ' JOIN all_cons_columns b ON c.owner = b.owner AND c.r_constraint_name = b.constraint_name',\n      \" WHERE c.constraint_type  = 'R'\",\n      ' AND a.table_name = ',\n      this.escape(tableName),\n      ' AND a.owner = ',\n      table.schema ? this.escape(schemaName) : 'USER',\n      ' ORDER BY a.table_name, a.constraint_name'\n    ].join('');\n\n    return sql;\n  }\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return this.dropConstraintQuery(tableName, foreignKey);\n  }\n\n  getPrimaryKeyConstraintQuery(table) {\n    const [tableName, schemaName] = this.getSchemaNameAndTableName(table);\n    const sql = [\n      'SELECT cols.column_name, atc.identity_column ',\n      'FROM all_constraints cons, all_cons_columns cols ',\n      'INNER JOIN all_tab_columns atc ON(atc.table_name = cols.table_name AND atc.COLUMN_NAME = cols.COLUMN_NAME )',\n      'WHERE cols.table_name = ',\n      this.escape(tableName),\n      'AND cols.owner = ',\n      table.schema ? this.escape(schemaName) : 'USER ',\n      \"AND cons.constraint_type = 'P' \",\n      'AND cons.constraint_name = cols.constraint_name ',\n      'AND cons.owner = cols.owner ',\n      'ORDER BY cols.table_name, cols.position'\n    ].join('');\n\n    return sql;\n  }\n\n  dropConstraintQuery(tableName, constraintName) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${constraintName}`;\n  }\n\n  setIsolationLevelQuery(value, options) {\n    if (options.parent) {\n      return;\n    }\n\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return 'SET TRANSACTION ISOLATION LEVEL READ COMMITTED;';\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        // Serializable mode is equal to Snapshot Isolation (SI) \n        // defined in ANSI std.\n        return 'SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;';\n      default:\n        throw new Error(`isolation level \"${value}\" is not supported`);\n    }\n  }\n\n  getAliasToken() {\n    return '';\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;\n    }\n\n    return 'BEGIN TRANSACTION';\n  }\n\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return 'COMMIT TRANSACTION';\n  }\n\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TO SAVEPOINT ${this.quoteIdentifier(transaction.name)}`;\n    }\n\n    return 'ROLLBACK TRANSACTION';\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    let str;\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      }\n      if (smth.path) {\n\n        // Allow specifying conditions using the sqlite json functions\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    }\n    if (smth instanceof Utils.Cast) {\n      if (smth.val instanceof Utils.SequelizeMethod) {\n        str = this.handleSequelizeMethod(smth.val, tableName, factory, options, prepend);\n        if (smth.type === 'boolean') {\n          str = `(CASE WHEN ${str}='true' THEN 1 ELSE 0 END)`;\n          return `CAST(${str} AS NUMBER)`;\n        } if (smth.type === 'timestamptz' && /json_value\\(/.test(str)) {\n          str = str.slice(0, -1);\n          return `${str} RETURNING TIMESTAMP WITH TIME ZONE)`;\n        }\n      }\n    }\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  jsonPathExtractionQuery(column, path) {\n    let paths = _.toPath(path);\n    const quotedColumn = this.isIdentifierQuoted(column) ? column : this.quoteIdentifier(column);\n\n    paths = paths.map(subPath => {\n      return /\\D/.test(subPath) ? Utils.addTicks(subPath, '\"') : subPath;\n    });\n\n    const pathStr = this.escape(['$'].concat(paths).join('.').replace(/\\.(\\d+)(?:(?=\\.)|$)/g, (__, digit) => `[${digit}]`));\n\n    return `json_value(${quotedColumn},${pathStr})`;\n  }\n\n  addLimitAndOffset(options, model) {\n    let fragment = '';\n    const offset = options.offset || 0,\n      isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n\n    let orders = {};\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n\n    if (options.limit || options.offset) {\n      // Add needed order by clause only when it is not provided\n      if (!orders.mainQueryOrder || !orders.mainQueryOrder.length || isSubQuery && (!orders.subQueryOrder || !orders.subQueryOrder.length)) {\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(model.primaryKeyField)}`;\n        fragment += ` ORDER BY ${tablePkFragment}`;\n      }\n\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n\n    return fragment;\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  quoteIdentifier(identifier, force = false) {\n    const optForceQuote = force;\n    const optQuoteIdentifiers = this.options.quoteIdentifiers !== false;\n    const rawIdentifier = Utils.removeTicks(identifier, '\"');\n    const regExp = /^(([\\w][\\w\\d_]*))$/g;\n\n    if (\n      optForceQuote !== true &&\n      optQuoteIdentifiers === false &&\n      regExp.test(rawIdentifier) &&\n      !ORACLE_RESERVED_WORDS.includes(rawIdentifier.toUpperCase())\n    ) {\n      // In Oracle, if tables, attributes or alias are created double-quoted,\n      // they are always case sensitive. If they contain any lowercase\n      // characters, they must always be double-quoted otherwise it\n      // would get uppercased by the DB.\n      // Here, we strip quotes if we don't want case sensitivity.\n      return rawIdentifier;\n    }\n    return Utils.addTicks(rawIdentifier, '\"');\n  }\n\n  /**\n * It causes bindbyPosition like :1, :2, :3\n * We pass the val parameter so that the outBind indexes\n * starts after the inBind indexes end\n *\n * @param {Array} bind\n * @param {number} posOffset\n */\n  bindParam(bind, posOffset = 0) {\n    return value => {\n      bind.push(value);\n      return `:${bind.length + posOffset}`;\n    };\n  }\n\n  /**\n   * Returns the authenticate test query string\n   */\n  authTestQuery() {\n    return 'SELECT 1+1 AS result FROM DUAL';\n  }\n}\n\n/* istanbul ignore next */\nfunction throwMethodUndefined(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}