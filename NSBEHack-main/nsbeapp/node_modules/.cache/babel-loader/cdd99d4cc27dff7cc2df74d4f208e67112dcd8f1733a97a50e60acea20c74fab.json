{"ast":null,"code":"var net = require('net');\nvar util = require('util');\nvar assert = require('assert');\nvar Stream = require('stream');\nvar forge = require('node-forge');\n\n// Compatibility shim for the browser\nif (forge.forge) {\n  forge = forge.forge;\n}\nfunction TLSSocket(socket, options) {\n  if (!(this instanceof TLSSocket)) return new TLSSocket(socket, options);\n  var self = this;\n\n  // Disallow wrapping TLSSocket in TLSSocket\n  assert(!(socket instanceof TLSSocket));\n  net.Socket.call(this);\n  this._tlsOptions = options;\n  this._secureEstablished = false;\n  this._chunks = [];\n\n  // Just a documented property to make secure sockets\n  // distinguishable from regular ones.\n  this.encrypted = true;\n  if (!socket) {\n    // connect() will be called later\n    this.once('connect', function () {\n      self._init(null);\n    });\n  } else {\n    this._connecting = socket._connecting;\n    this._socket = socket;\n    this._init(socket);\n  }\n\n  // Make sure to setup all required properties like: `_connecting` before\n  // starting the flow of the data\n  this.readable = true;\n  this.writable = true;\n  this.read(0);\n}\nutil.inherits(TLSSocket, net.Socket);\nexports.TLSSocket = TLSSocket;\nTLSSocket.prototype.log = function (arguments) {\n  if (this._tlsOptions.debug) {\n    console.log.apply(console, Array.prototype.slice.call(arguments));\n  }\n};\nTLSSocket.prototype._init = function (socket) {\n  var self = this;\n  var options = this._tlsOptions;\n  this.ssl = forge.tls.createConnection({\n    server: false,\n    verify: function (connection, verified, depth, certs) {\n      if (!options.rejectUnauthorized || !options.servername) {\n        self.log('[tls] server certificate verification skipped');\n        return true;\n      }\n      self.log('[tls] skipping certificate trust verification');\n      verified = true;\n      if (depth === 0) {\n        var cn = certs[0].subject.getField('CN').value;\n        if (cn !== options.servername) {\n          verified = {\n            alert: forge.tls.Alert.Description.bad_certificate,\n            message: 'Certificate common name does not match hostname.'\n          };\n          console.warn('[tls] ' + cn + ' !== ' + options.servername);\n        }\n        self.log('[tls] server certificate verified');\n      }\n      return verified;\n    },\n    connected: function (connection) {\n      self.log('[tls] connected', self);\n      // prepare some data to send (note that the string is interpreted as\n      // 'binary' encoded, which works for HTTP which only uses ASCII, use\n      // forge.util.encodeUtf8(str) otherwise\n      //client.prepare('GET / HTTP/1.0\\r\\n\\r\\n');\n\n      self._secureEstablished = true;\n      self._writePending();\n      self.emit('secure');\n    },\n    tlsDataReady: function (connection) {\n      // encrypted data is ready to be sent to the server\n      var data = connection.tlsData.getBytes();\n      //self.log('[tls] sending encrypted: ', data, data.length);\n      //self._socket.write(data, 'binary'); // encoding should be 'binary'\n      net.Socket.prototype.write.call(self._socket, data, 'binary'); // encoding should be 'binary'\n    },\n\n    dataReady: function (connection) {\n      // clear data from the server is ready\n      var data = connection.data.getBytes(),\n        buffer = new Buffer(data, 'binary');\n      self.log('[tls] received: ', data);\n      self.push(buffer);\n    },\n    closed: function () {\n      self.log('[tls] disconnected');\n      self.end();\n    },\n    error: function (connection, error) {\n      self.log('[tls] error', error);\n      error.toString = function () {\n        return 'TLS error: ' + error.message;\n      };\n      self.emit('error', error);\n    }\n  });\n  this._socket.push = function (data) {\n    self.ssl.process(data.toString('binary')); // encoding should be 'binary'\n  };\n\n  // Socket already has some buffered data - emulate receiving it\n  if (socket && socket._readableState.length) {\n    var buf;\n    while ((buf = socket.read()) !== null) {\n      this.ssl.process(buf); // Do we need this?\n    }\n  }\n\n  this.log('[tls] init');\n\n  // Start handshaking if connected\n  if (this._socket.readyState != 'open') {\n    this._socket.once('connect', function () {\n      self.emit('connect');\n      self._start();\n    });\n  } else {\n    this._start();\n  }\n};\nTLSSocket.prototype._start = function () {\n  this.log('[tls] handshaking');\n  this.ssl.handshake();\n};\nTLSSocket.prototype._read = function () {};\nTLSSocket.prototype._writenow = function (data, encoding, cb) {\n  cb = cb || function () {};\n  this.log('[tls] sending: ', data.toString('utf8'));\n  var result = this.ssl.prepare(data.toString('binary'));\n  process.nextTick(function () {\n    var err = result !== false ? null : 'Error while packaging data into a TLS record';\n    cb(err);\n  });\n};\nTLSSocket.prototype._writePending = function () {\n  if (this._chunks.length > 0) {\n    for (var i in this._chunks) {\n      this._writenow(this._chunks[i][0], this._chunks[i][1], this._chunks[i][2]);\n    }\n    this._chunks = [];\n  }\n};\nTLSSocket.prototype._write = function (data, encoding, cb) {\n  if (!this._secureEstablished) {\n    this._chunks.push([data, encoding, cb]);\n  } else {\n    this._writePending();\n    this._writenow(data, encoding, cb);\n  }\n};\nTLSSocket.prototype.connect = function () {\n  var self = this;\n  self._connecting = true;\n  this._socket = new net.Socket();\n  this._socket.on('connect', function () {\n    self._connecting = false;\n    self._init(null);\n  });\n  this._socket.connect.apply(this._socket, arguments);\n  return this;\n};\nTLSSocket.prototype.push = function () {\n  net.Socket.prototype.push.apply(this, arguments);\n  net.Socket.prototype.push.apply(this._socket, arguments);\n};\nfunction normalizeConnectArgs(listArgs) {\n  var args = net._normalizeConnectArgs(listArgs);\n  var options = args[0];\n  var cb = args[1];\n  if (util.isObject(listArgs[1])) {\n    options = util._extend(options, listArgs[1]);\n  } else if (util.isObject(listArgs[2])) {\n    options = util._extend(options, listArgs[2]);\n  }\n  return cb ? [options, cb] : [options];\n}\nexports.connect = function /* [port, host], options, cb */\n() {\n  var args = normalizeConnectArgs(arguments);\n  var options = args[0];\n  var cb = args[1];\n  var defaults = {\n    rejectUnauthorized: '0' !== process.env.NODE_TLS_REJECT_UNAUTHORIZED,\n    ciphers: null //tls.DEFAULT_CIPHERS\n  };\n\n  options = util._extend(defaults, options || {});\n  var hostname = options.servername || options.host || options.socket && options.socket._host;\n  var socket = new TLSSocket(options.socket, {\n    rejectUnauthorized: options.rejectUnauthorized\n  });\n\n  // Not even started connecting yet (or probably resolving dns address),\n  // catch socket errors and assign handle.\n  if (options.socket) {\n    options.socket.once('connect', function () {\n      /*assert(options.socket._handle);\n      socket._handle = options.socket._handle;\n      socket._handle.owner = socket;\n      socket.emit('connect');*/\n    });\n  }\n  if (options.servername) {\n    //socket.setServername(options.servername);\n  }\n  if (cb) socket.once('secure', cb);\n  if (!options.socket) {\n    socket.connect({\n      host: options.host,\n      port: options.port\n    });\n  }\n  return socket;\n};","map":{"version":3,"names":["net","require","util","assert","Stream","forge","TLSSocket","socket","options","self","Socket","call","_tlsOptions","_secureEstablished","_chunks","encrypted","once","_init","_connecting","_socket","readable","writable","read","inherits","exports","prototype","log","arguments","debug","console","apply","Array","slice","ssl","tls","createConnection","server","verify","connection","verified","depth","certs","rejectUnauthorized","servername","cn","subject","getField","value","alert","Alert","Description","bad_certificate","message","warn","connected","_writePending","emit","tlsDataReady","data","tlsData","getBytes","write","dataReady","buffer","Buffer","push","closed","end","error","toString","process","_readableState","length","buf","readyState","_start","handshake","_read","_writenow","encoding","cb","result","prepare","nextTick","err","i","_write","connect","on","normalizeConnectArgs","listArgs","args","_normalizeConnectArgs","isObject","_extend","defaults","env","NODE_TLS_REJECT_UNAUTHORIZED","ciphers","hostname","host","_host","port"],"sources":["C:/Users/rizla/projects/react/NSBEHack-main/nsbeapp/node_modules/tls-browserify/index.js"],"sourcesContent":["var net = require('net');\nvar util = require('util');\nvar assert = require('assert');\nvar Stream = require('stream');\nvar forge = require('node-forge');\n\n// Compatibility shim for the browser\nif (forge.forge) {\n\tforge = forge.forge;\n}\n\nfunction TLSSocket(socket, options) {\n\tif (!(this instanceof TLSSocket)) return new TLSSocket(socket, options);\n\n\tvar self = this;\n\n\t// Disallow wrapping TLSSocket in TLSSocket\n\tassert(!(socket instanceof TLSSocket));\n\n\tnet.Socket.call(this);\n\n\tthis._tlsOptions = options;\n\tthis._secureEstablished = false;\n\tthis._chunks = [];\n\n\t// Just a documented property to make secure sockets\n\t// distinguishable from regular ones.\n\tthis.encrypted = true;\n\n\tif (!socket) { // connect() will be called later\n\t\tthis.once('connect', function() {\n\t\t\tself._init(null);\n\t\t});\n\t} else {\n\t\tthis._connecting = socket._connecting;\n\n\t\tthis._socket = socket;\n\t\tthis._init(socket);\n\t}\n\n\t// Make sure to setup all required properties like: `_connecting` before\n\t// starting the flow of the data\n\tthis.readable = true;\n\tthis.writable = true;\n\tthis.read(0);\n}\nutil.inherits(TLSSocket, net.Socket);\n\nexports.TLSSocket = TLSSocket;\n\nTLSSocket.prototype.log = function(arguments) {\n\tif (this._tlsOptions.debug) {\n\t\tconsole.log.apply(console, Array.prototype.slice.call(arguments));\n\t}\n}\n\nTLSSocket.prototype._init = function(socket) {\n\tvar self = this;\n\tvar options = this._tlsOptions;\n\n\tthis.ssl = forge.tls.createConnection({\n\t\tserver: false,\n\t\tverify: function(connection, verified, depth, certs) {\n\t\t\tif (!options.rejectUnauthorized || !options.servername) {\n\t\t\t\tself.log('[tls] server certificate verification skipped');\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tself.log('[tls] skipping certificate trust verification');\n\t\t\tverified = true;\n\n\t\t\tif (depth === 0) {\n\t\t\t\tvar cn = certs[0].subject.getField('CN').value;\n\t\t\t\tif (cn !== options.servername) {\n\t\t\t\t\tverified = {\n\t\t\t\t\t\talert: forge.tls.Alert.Description.bad_certificate,\n\t\t\t\t\t\tmessage: 'Certificate common name does not match hostname.'\n\t\t\t\t\t};\n\t\t\t\t\tconsole.warn('[tls] '+cn+' !== '+options.servername);\n\t\t\t\t}\n\t\t\t\tself.log('[tls] server certificate verified');\n\t\t\t}\n\n\t\t\treturn verified;\n\t\t},\n\t\tconnected: function(connection) {\n\t\t\tself.log('[tls] connected', self);\n\t\t\t// prepare some data to send (note that the string is interpreted as\n\t\t\t// 'binary' encoded, which works for HTTP which only uses ASCII, use\n\t\t\t// forge.util.encodeUtf8(str) otherwise\n\t\t\t//client.prepare('GET / HTTP/1.0\\r\\n\\r\\n');\n\n\t\t\tself._secureEstablished = true;\n\t\t\tself._writePending();\n\t\t\tself.emit('secure');\n\t\t},\n\t\ttlsDataReady: function(connection) {\n\t\t\t// encrypted data is ready to be sent to the server\n\t\t\tvar data = connection.tlsData.getBytes();\n\t\t\t//self.log('[tls] sending encrypted: ', data, data.length);\n\t\t\t//self._socket.write(data, 'binary'); // encoding should be 'binary'\n\t\t\tnet.Socket.prototype.write.call(self._socket, data, 'binary'); // encoding should be 'binary'\n\t\t},\n\t\tdataReady: function(connection) {\n\t\t\t// clear data from the server is ready\n\t\t\tvar data = connection.data.getBytes(),\n\t\t\t\tbuffer = new Buffer(data, 'binary');\n\n\t\t\tself.log('[tls] received: ', data);\n\t\t\tself.push(buffer);\n\t\t},\n\t\tclosed: function() {\n\t\t\tself.log('[tls] disconnected');\n\t\t\tself.end();\n\t\t},\n\t\terror: function(connection, error) {\n\t\t\tself.log('[tls] error', error);\n\t\t\terror.toString = function () {\n\t\t\t\treturn 'TLS error: '+error.message;\n\t\t\t};\n\t\t\tself.emit('error', error);\n\t\t}\n\t});\n\n\tthis._socket.push = function (data) {\n\t\tself.ssl.process(data.toString('binary')); // encoding should be 'binary'\n\t};\n\n\t// Socket already has some buffered data - emulate receiving it\n\tif (socket && socket._readableState.length) {\n\t\tvar buf;\n\t\twhile ((buf = socket.read()) !== null) {\n\t\t\tthis.ssl.process(buf); // Do we need this?\n\t\t}\n\t}\n\n\tthis.log('[tls] init');\n\n\t// Start handshaking if connected\n\tif (this._socket.readyState != 'open') {\n\t\tthis._socket.once('connect', function () {\n\t\t\tself.emit('connect');\n\t\t\tself._start();\n\t\t});\n\t} else {\n\t\tthis._start();\n\t}\n};\n\nTLSSocket.prototype._start = function () {\n\tthis.log('[tls] handshaking');\n\tthis.ssl.handshake();\n};\n\nTLSSocket.prototype._read = function () {};\n\nTLSSocket.prototype._writenow = function (data, encoding, cb) {\n\tcb = cb || function () {};\n\n\tthis.log('[tls] sending: ', data.toString('utf8'));\n\tvar result = this.ssl.prepare(data.toString('binary'));\n\n\tprocess.nextTick(function () {\n\t\tvar err = (result !== false) ? null : 'Error while packaging data into a TLS record';\n\t\tcb(err);\n\t});\n};\n\nTLSSocket.prototype._writePending = function() {\n\tif (this._chunks.length > 0) {\n\t\tfor (var i in this._chunks) {\n\t\t\tthis._writenow(this._chunks[i][0], this._chunks[i][1], this._chunks[i][2]);\n\t\t}\n\t\tthis._chunks = [];\n\t}\n};\n\nTLSSocket.prototype._write = function (data, encoding, cb) {\n\tif (!this._secureEstablished) {\n\t\tthis._chunks.push([data, encoding, cb]);\n\t} else {\n\t\tthis._writePending();\n\t\tthis._writenow(data, encoding, cb);\n\t}\n};\n\nTLSSocket.prototype.connect = function () {\n\tvar self = this;\n\n\tself._connecting = true;\n\n\tthis._socket = new net.Socket();\n\tthis._socket.on('connect', function () {\n\t\tself._connecting = false;\n\t\tself._init(null);\n\t});\n\tthis._socket.connect.apply(this._socket, arguments);\n\n\treturn this;\n};\n\nTLSSocket.prototype.push = function () {\n\tnet.Socket.prototype.push.apply(this, arguments);\n\tnet.Socket.prototype.push.apply(this._socket, arguments);\n};\n\nfunction normalizeConnectArgs(listArgs) {\n\tvar args = net._normalizeConnectArgs(listArgs);\n\tvar options = args[0];\n\tvar cb = args[1];\n\tif (util.isObject(listArgs[1])) {\n\t\toptions = util._extend(options, listArgs[1]);\n\t} else if (util.isObject(listArgs[2])) {\n\t\toptions = util._extend(options, listArgs[2]);\n\t}\n\treturn (cb) ? [options, cb] : [options];\n}\n\nexports.connect = function (/* [port, host], options, cb */) {\n\tvar args = normalizeConnectArgs(arguments);\n\tvar options = args[0];\n\tvar cb = args[1];\n\n\tvar defaults = {\n\t\trejectUnauthorized: '0' !== process.env.NODE_TLS_REJECT_UNAUTHORIZED,\n\t\tciphers: null //tls.DEFAULT_CIPHERS\n\t};\n\toptions = util._extend(defaults, options || {});\n\n\tvar hostname = options.servername ||\n\t\toptions.host ||\n\t\toptions.socket && options.socket._host;\n\n\tvar socket = new TLSSocket(options.socket, {\n\t\trejectUnauthorized: options.rejectUnauthorized\n\t});\n\n\t// Not even started connecting yet (or probably resolving dns address),\n\t// catch socket errors and assign handle.\n\tif (options.socket) {\n\t\toptions.socket.once('connect', function() {\n\t\t\t/*assert(options.socket._handle);\n\t\t\tsocket._handle = options.socket._handle;\n\t\t\tsocket._handle.owner = socket;\n\t\t\tsocket.emit('connect');*/\n\t\t});\n\t}\n\n\tif (options.servername) {\n\t\t//socket.setServername(options.servername);\n\t}\n\n\tif (cb)\n\t\tsocket.once('secure', cb);\n\n\tif (!options.socket) {\n\t\tsocket.connect({\n\t\t\thost: options.host,\n\t\t\tport: options.port\n\t\t});\n\t}\n\n\treturn socket;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}