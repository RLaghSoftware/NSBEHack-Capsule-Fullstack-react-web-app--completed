{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\nconst validator = _.cloneDeep(require(\"validator\"));\nconst moment = require(\"moment\");\nconst extensions = {\n  extend(name, fn) {\n    this[name] = fn;\n    return this;\n  },\n  notEmpty(str) {\n    return !str.match(/^[\\s\\t\\r\\n]*$/);\n  },\n  len(str, min, max) {\n    return this.isLength(str, min, max);\n  },\n  isUrl(str) {\n    return this.isURL(str);\n  },\n  isIPv6(str) {\n    return this.isIP(str, 6);\n  },\n  isIPv4(str) {\n    return this.isIP(str, 4);\n  },\n  notIn(str, values) {\n    return !this.isIn(str, values);\n  },\n  regex(str, pattern, modifiers) {\n    str += \"\";\n    if (Object.prototype.toString.call(pattern).slice(8, -1) !== \"RegExp\") {\n      pattern = new RegExp(pattern, modifiers);\n    }\n    return str.match(pattern);\n  },\n  notRegex(str, pattern, modifiers) {\n    return !this.regex(str, pattern, modifiers);\n  },\n  isDecimal(str) {\n    return str !== \"\" && !!str.match(/^(?:-?(?:[0-9]+))?(?:\\.[0-9]*)?(?:[eE][+-]?(?:[0-9]+))?$/);\n  },\n  min(str, val) {\n    const number = parseFloat(str);\n    return isNaN(number) || number >= val;\n  },\n  max(str, val) {\n    const number = parseFloat(str);\n    return isNaN(number) || number <= val;\n  },\n  not(str, pattern, modifiers) {\n    return this.notRegex(str, pattern, modifiers);\n  },\n  contains(str, elem) {\n    return !!elem && str.includes(elem);\n  },\n  notContains(str, elem) {\n    return !this.contains(str, elem);\n  },\n  is(str, pattern, modifiers) {\n    return this.regex(str, pattern, modifiers);\n  }\n};\nexports.extensions = extensions;\nvalidator.isImmutable = function (value, validatorArgs, field, modelInstance) {\n  return modelInstance.isNewRecord || modelInstance.dataValues[field] === modelInstance._previousDataValues[field];\n};\nvalidator.notNull = function (val) {\n  return val !== null && val !== void 0;\n};\n_.forEach(extensions, (extend, key) => {\n  validator[key] = extend;\n});\nvalidator.isNull = validator.isEmpty;\nvalidator.isDate = function (dateString) {\n  const parsed = Date.parse(dateString);\n  if (isNaN(parsed)) {\n    return false;\n  }\n  const date = new Date(parsed);\n  return moment(date.toISOString()).isValid();\n};\nexports.validator = validator;","map":{"version":3,"mappings":";;AAEA,MAAMA,IAAIC,QAAQ;AAClB,MAAMC,YAAYF,EAAEG,UAAUF,QAAQ;AACtC,MAAMG,SAASH,QAAQ;AAEvB,MAAMI,aAAa;EACjBC,OAAOC,MAAMC,IAAI;IACf,KAAKD,QAAQC;IAEb,OAAO;EAAA;EAETC,SAASC,KAAK;IACZ,OAAO,CAACA,IAAIC,MAAM;EAAA;EAEpBC,IAAIF,KAAKG,KAAKC,KAAK;IACjB,OAAO,KAAKC,SAASL,KAAKG,KAAKC;EAAA;EAEjCE,MAAMN,KAAK;IACT,OAAO,KAAKO,MAAMP;EAAA;EAEpBQ,OAAOR,KAAK;IACV,OAAO,KAAKS,KAAKT,KAAK;EAAA;EAExBU,OAAOV,KAAK;IACV,OAAO,KAAKS,KAAKT,KAAK;EAAA;EAExBW,MAAMX,KAAKY,QAAQ;IACjB,OAAO,CAAC,KAAKC,KAAKb,KAAKY;EAAA;EAEzBE,MAAMd,KAAKe,SAASC,WAAW;IAC7BhB,OAAO;IACP,IAAIiB,OAAOC,UAAUC,SAASC,KAAKL,SAASM,MAAM,GAAG,QAAQ,UAAU;MACrEN,UAAU,IAAIO,OAAOP,SAASC;IAAA;IAEhC,OAAOhB,IAAIC,MAAMc;EAAA;EAEnBQ,SAASvB,KAAKe,SAASC,WAAW;IAChC,OAAO,CAAC,KAAKF,MAAMd,KAAKe,SAASC;EAAA;EAEnCQ,UAAUxB,KAAK;IACb,OAAOA,QAAQ,MAAM,CAAC,CAACA,IAAIC,MAAM;EAAA;EAEnCE,IAAIH,KAAKyB,KAAK;IACZ,MAAMC,SAASC,WAAW3B;IAC1B,OAAO4B,MAAMF,WAAWA,UAAUD;EAAA;EAEpCrB,IAAIJ,KAAKyB,KAAK;IACZ,MAAMC,SAASC,WAAW3B;IAC1B,OAAO4B,MAAMF,WAAWA,UAAUD;EAAA;EAEpCI,IAAI7B,KAAKe,SAASC,WAAW;IAC3B,OAAO,KAAKO,SAASvB,KAAKe,SAASC;EAAA;EAErCc,SAAS9B,KAAK+B,MAAM;IAClB,OAAO,CAAC,CAACA,QAAQ/B,IAAIgC,SAASD;EAAA;EAEhCE,YAAYjC,KAAK+B,MAAM;IACrB,OAAO,CAAC,KAAKD,SAAS9B,KAAK+B;EAAA;EAE7BG,GAAGlC,KAAKe,SAASC,WAAW;IAC1B,OAAO,KAAKF,MAAMd,KAAKe,SAASC;EAAA;AAAA;AAGpCmB,QAAQxC,aAAaA;AAGrBH,UAAU4C,cAAc,UAASC,OAAOC,eAAeC,OAAOC,eAAe;EAC3E,OAAOA,cAAcC,eAAeD,cAAcE,WAAWH,WAAWC,cAAcG,oBAAoBJ;AAAA;AAI5G/C,UAAUoD,UAAU,UAASnB,KAAK;EAChC,OAAOA,QAAQ,QAAQA,QAAQ;AAAA;AAIjCnC,EAAEuD,QAAQlD,YAAY,CAACC,QAAQkD,QAAQ;EACrCtD,UAAUsD,OAAOlD;AAAA;AAKnBJ,UAAUuD,SAASvD,UAAUwD;AAI7BxD,UAAUyD,SAAS,UAASC,YAAY;EAGtC,MAAMC,SAASC,KAAKC,MAAMH;EAC1B,IAAItB,MAAMuB,SAAS;IAEjB,OAAO;EAAA;EAIT,MAAMG,OAAO,IAAIF,KAAKD;EACtB,OAAOzD,OAAO4D,KAAKC,eAAeC;AAAA;AAGpCrB,QAAQ3C,YAAYA","names":["_","require","validator","cloneDeep","moment","extensions","extend","name","fn","notEmpty","str","match","len","min","max","isLength","isUrl","isURL","isIPv6","isIP","isIPv4","notIn","values","isIn","regex","pattern","modifiers","Object","prototype","toString","call","slice","RegExp","notRegex","isDecimal","val","number","parseFloat","isNaN","not","contains","elem","includes","notContains","is","exports","isImmutable","value","validatorArgs","field","modelInstance","isNewRecord","dataValues","_previousDataValues","notNull","forEach","key","isNull","isEmpty","isDate","dateString","parsed","Date","parse","date","toISOString","isValid"],"sources":["C:\\Users\\rizla\\projects\\react\\NSBEHack-main\\nsbeapp\\node_modules\\sequelize\\src\\utils\\validator-extras.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst validator = _.cloneDeep(require('validator'));\nconst moment = require('moment');\n\nconst extensions = {\n  extend(name, fn) {\n    this[name] = fn;\n\n    return this;\n  },\n  notEmpty(str) {\n    return !str.match(/^[\\s\\t\\r\\n]*$/);\n  },\n  len(str, min, max) {\n    return this.isLength(str, min, max);\n  },\n  isUrl(str) {\n    return this.isURL(str);\n  },\n  isIPv6(str) {\n    return this.isIP(str, 6);\n  },\n  isIPv4(str) {\n    return this.isIP(str, 4);\n  },\n  notIn(str, values) {\n    return !this.isIn(str, values);\n  },\n  regex(str, pattern, modifiers) {\n    str += '';\n    if (Object.prototype.toString.call(pattern).slice(8, -1) !== 'RegExp') {\n      pattern = new RegExp(pattern, modifiers);\n    }\n    return str.match(pattern);\n  },\n  notRegex(str, pattern, modifiers) {\n    return !this.regex(str, pattern, modifiers);\n  },\n  isDecimal(str) {\n    return str !== '' && !!str.match(/^(?:-?(?:[0-9]+))?(?:\\.[0-9]*)?(?:[eE][+-]?(?:[0-9]+))?$/);\n  },\n  min(str, val) {\n    const number = parseFloat(str);\n    return isNaN(number) || number >= val;\n  },\n  max(str, val) {\n    const number = parseFloat(str);\n    return isNaN(number) || number <= val;\n  },\n  not(str, pattern, modifiers) {\n    return this.notRegex(str, pattern, modifiers);\n  },\n  contains(str, elem) {\n    return !!elem && str.includes(elem);\n  },\n  notContains(str, elem) {\n    return !this.contains(str, elem);\n  },\n  is(str, pattern, modifiers) {\n    return this.regex(str, pattern, modifiers);\n  }\n};\nexports.extensions = extensions;\n\n// instance based validators\nvalidator.isImmutable = function(value, validatorArgs, field, modelInstance) {\n  return modelInstance.isNewRecord || modelInstance.dataValues[field] === modelInstance._previousDataValues[field];\n};\n\n// extra validators\nvalidator.notNull = function(val) {\n  return val !== null && val !== undefined;\n};\n\n// https://github.com/chriso/validator.js/blob/6.2.0/validator.js\n_.forEach(extensions, (extend, key) => {\n  validator[key] = extend;\n});\n\n// map isNull to isEmpty\n// https://github.com/chriso/validator.js/commit/e33d38a26ee2f9666b319adb67c7fc0d3dea7125\nvalidator.isNull = validator.isEmpty;\n\n// isDate removed in 7.0.0\n// https://github.com/chriso/validator.js/commit/095509fc707a4dc0e99f85131df1176ad6389fc9\nvalidator.isDate = function(dateString) {\n  // avoid http://momentjs.com/guides/#/warnings/js-date/\n  // by doing a preliminary check on `dateString`\n  const parsed = Date.parse(dateString);\n  if (isNaN(parsed)) {\n    // fail if we can't parse it\n    return false;\n  }\n  // otherwise convert to ISO 8601 as moment prefers\n  // http://momentjs.com/docs/#/parsing/string/\n  const date = new Date(parsed);\n  return moment(date.toISOString()).isValid();\n};\n\nexports.validator = validator;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}