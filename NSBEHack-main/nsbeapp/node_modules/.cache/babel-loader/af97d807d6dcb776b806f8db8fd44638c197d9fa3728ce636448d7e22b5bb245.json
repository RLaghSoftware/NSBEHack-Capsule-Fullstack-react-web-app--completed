{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\nconst HasOne = require(\"./has-one\");\nconst HasMany = require(\"./has-many\");\nconst BelongsToMany = require(\"./belongs-to-many\");\nconst BelongsTo = require(\"./belongs-to\");\nfunction isModel(model, sequelize) {\n  return model && model.prototype && model.prototype instanceof sequelize.Sequelize.Model;\n}\nconst Mixin = {\n  hasMany(target) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(`${this.name}.hasMany called with something that's not a subclass of Sequelize.Model`);\n    }\n    const source = this;\n    options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    Object.assign(options, _.omit(source.options, [\"hooks\"]));\n    if (options.useHooks) {\n      this.runHooks(\"beforeAssociate\", {\n        source,\n        target,\n        type: HasMany\n      }, options);\n    }\n    const association = new HasMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n    association._injectAttributes();\n    association.mixin(source.prototype);\n    if (options.useHooks) {\n      this.runHooks(\"afterAssociate\", {\n        source,\n        target,\n        type: HasMany,\n        association\n      }, options);\n    }\n    return association;\n  },\n  belongsToMany(target) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(`${this.name}.belongsToMany called with something that's not a subclass of Sequelize.Model`);\n    }\n    const source = this;\n    options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    options.timestamps = options.timestamps === void 0 ? this.sequelize.options.timestamps : options.timestamps;\n    Object.assign(options, _.omit(source.options, [\"hooks\", \"timestamps\", \"scopes\", \"defaultScope\"]));\n    if (options.useHooks) {\n      this.runHooks(\"beforeAssociate\", {\n        source,\n        target,\n        type: BelongsToMany\n      }, options);\n    }\n    const association = new BelongsToMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n    association._injectAttributes();\n    association.mixin(source.prototype);\n    if (options.useHooks) {\n      this.runHooks(\"afterAssociate\", {\n        source,\n        target,\n        type: BelongsToMany,\n        association\n      }, options);\n    }\n    return association;\n  },\n  getAssociations(target) {\n    return Object.values(this.associations).filter(association => association.target.name === target.name);\n  },\n  getAssociationForAlias(target, alias) {\n    return this.getAssociations(target).find(association => association.verifyAssociationAlias(alias)) || null;\n  }\n};\nfunction singleLinked(Type) {\n  return function (target) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const source = this;\n    if (!isModel(target, source.sequelize)) {\n      throw new Error(`${source.name}.${_.lowerFirst(Type.name)} called with something that's not a subclass of Sequelize.Model`);\n    }\n    options.hooks = options.hooks === void 0 ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    if (options.useHooks) {\n      source.runHooks(\"beforeAssociate\", {\n        source,\n        target,\n        type: Type\n      }, options);\n    }\n    const association = new Type(source, target, Object.assign(options, source.options));\n    source.associations[association.associationAccessor] = association;\n    association._injectAttributes();\n    association.mixin(source.prototype);\n    if (options.useHooks) {\n      source.runHooks(\"afterAssociate\", {\n        source,\n        target,\n        type: Type,\n        association\n      }, options);\n    }\n    return association;\n  };\n}\nMixin.hasOne = singleLinked(HasOne);\nMixin.belongsTo = singleLinked(BelongsTo);\nmodule.exports = Mixin;\nmodule.exports.Mixin = Mixin;\nmodule.exports.default = Mixin;","map":{"version":3,"mappings":"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","names":["_","require","HasOne","HasMany","BelongsToMany","BelongsTo","model","sequelize","prototype","Sequelize","Model","Mixin","hasMany","target","options","isModel","Error","name","source","hooks","Boolean","useHooks","Object","assign","omit","runHooks","type","association","associations","associationAccessor","_injectAttributes","mixin","belongsToMany","timestamps","getAssociations","values","filter","getAssociationForAlias","alias","find","verifyAssociationAlias","Type","lowerFirst","hasOne","singleLinked","belongsTo","module","exports","default"],"sources":["C:\\Users\\rizla\\projects\\react\\NSBEHack-main\\nsbeapp\\node_modules\\sequelize\\src\\associations\\mixin.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst HasOne = require('./has-one');\nconst HasMany = require('./has-many');\nconst BelongsToMany = require('./belongs-to-many');\nconst BelongsTo = require('./belongs-to');\n\nfunction isModel(model, sequelize) {\n  return model\n    && model.prototype\n    && model.prototype instanceof sequelize.Sequelize.Model;\n}\n\nconst Mixin = {\n  hasMany(target, options = {}) {\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(`${this.name}.hasMany called with something that's not a subclass of Sequelize.Model`);\n    }\n\n    const source = this;\n\n    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n\n    Object.assign(options, _.omit(source.options, ['hooks']));\n\n    if (options.useHooks) {\n      this.runHooks('beforeAssociate', { source, target, type: HasMany }, options);\n    }\n\n    // the id is in the foreign table or in a connecting table\n    const association = new HasMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      this.runHooks('afterAssociate', { source, target, type: HasMany, association }, options);\n    }\n\n    return association;\n  },\n\n  belongsToMany(target, options = {}) {\n    if (!isModel(target, this.sequelize)) {\n      throw new Error(`${this.name}.belongsToMany called with something that's not a subclass of Sequelize.Model`);\n    }\n\n    const source = this;\n\n    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n    options.timestamps = options.timestamps === undefined ? this.sequelize.options.timestamps : options.timestamps;\n    Object.assign(options, _.omit(source.options, ['hooks', 'timestamps', 'scopes', 'defaultScope']));\n\n    if (options.useHooks) {\n      this.runHooks('beforeAssociate', { source, target, type: BelongsToMany }, options);\n    }\n    // the id is in the foreign table or in a connecting table\n    const association = new BelongsToMany(source, target, options);\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      this.runHooks('afterAssociate', { source, target, type: BelongsToMany, association }, options);\n    }\n\n    return association;\n  },\n\n  getAssociations(target) {\n    return Object.values(this.associations).filter(association => association.target.name === target.name);\n  },\n\n  getAssociationForAlias(target, alias) {\n    // Two associations cannot have the same alias, so we can use find instead of filter\n    return this.getAssociations(target).find(association => association.verifyAssociationAlias(alias)) || null;\n  }\n};\n\n// The logic for hasOne and belongsTo is exactly the same\nfunction singleLinked(Type) {\n  return function(target, options = {}) {\n    // eslint-disable-next-line no-invalid-this\n    const source = this;\n    if (!isModel(target, source.sequelize)) {\n      throw new Error(`${source.name}.${_.lowerFirst(Type.name)} called with something that's not a subclass of Sequelize.Model`);\n    }\n\n\n    // Since this is a mixin, we'll need a unique letiable name for hooks (since Model will override our hooks option)\n    options.hooks = options.hooks === undefined ? false : Boolean(options.hooks);\n    options.useHooks = options.hooks;\n\n    if (options.useHooks) {\n      source.runHooks('beforeAssociate', { source, target, type: Type }, options);\n    }\n    // the id is in the foreign table\n    const association = new Type(source, target, Object.assign(options, source.options));\n    source.associations[association.associationAccessor] = association;\n\n    association._injectAttributes();\n    association.mixin(source.prototype);\n\n    if (options.useHooks) {\n      source.runHooks('afterAssociate', { source, target, type: Type, association }, options);\n    }\n\n    return association;\n  };\n}\n\nMixin.hasOne = singleLinked(HasOne);\nMixin.belongsTo = singleLinked(BelongsTo);\n\nmodule.exports = Mixin;\nmodule.exports.Mixin = Mixin;\nmodule.exports.default = Mixin;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}