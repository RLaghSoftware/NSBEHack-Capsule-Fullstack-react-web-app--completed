{"ast":null,"code":"var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __markAsModule = target => __defProp(target, \"__esModule\", {\n  value: true\n});\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __reExport = (target, module2, desc) => {\n  if (module2 && typeof module2 === \"object\" || typeof module2 === \"function\") {\n    for (let key of __getOwnPropNames(module2)) if (!__hasOwnProp.call(target, key) && key !== \"default\") __defProp(target, key, {\n      get: () => module2[key],\n      enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable\n    });\n  }\n  return target;\n};\nvar __toModule = module2 => {\n  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, \"default\", module2 && module2.__esModule && \"default\" in module2 ? {\n    get: () => module2.default,\n    enumerable: true\n  } : {\n    value: module2,\n    enumerable: true\n  })), module2);\n};\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n__export(exports, {\n  AsyncQueueError: () => AsyncQueueError,\n  default: () => async_queue_default\n});\nvar import_base_error = __toModule(require(\"../../errors/base-error\"));\nvar import_connection_error = __toModule(require(\"../../errors/connection-error\"));\nclass AsyncQueueError extends import_base_error.default {\n  constructor(message) {\n    super(message);\n    this.name = \"SequelizeAsyncQueueError\";\n  }\n}\nclass AsyncQueue {\n  constructor() {\n    __publicField(this, \"previous\");\n    __publicField(this, \"closed\");\n    __publicField(this, \"rejectCurrent\");\n    this.previous = Promise.resolve();\n    this.closed = false;\n    this.rejectCurrent = () => {};\n  }\n  close() {\n    this.closed = true;\n    this.rejectCurrent(new import_connection_error.default(new AsyncQueueError(\"the connection was closed before this query could finish executing\")));\n  }\n  enqueue(asyncFunction) {\n    return new Promise((resolve, reject) => {\n      this.previous = this.previous.then(() => {\n        this.rejectCurrent = reject;\n        if (this.closed) {\n          return reject(new import_connection_error.default(new AsyncQueueError(\"the connection was closed before this query could be executed\")));\n        }\n        return asyncFunction().then(resolve, reject);\n      });\n    });\n  }\n}\nvar async_queue_default = AsyncQueue;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAAA;EAAAC;EAAAC;AAAA;AAAA,wBAAsBC;AACtB,8BAA4BA;AAKrB,8BAA8BC,0BAAU;EAC7CC,YAAYC,SAAiB;IAC3B,MAAMA;IACN,KAAKC,OAAO;EAAA;AAAA;AAIhB,iBAAiB;EAKfF,cAAc;IAJdG;IACAA;IACAA;IAGE,KAAKC,WAAWC,QAAQC;IACxB,KAAKC,SAAS;IACd,KAAKC,gBAAgB,MAAM;EAAA;EAK7BC,QAAQ;IACN,KAAKF,SAAS;IACd,KAAKC,cACH,IAAIE,gCACF,IAAId,gBACF;EAAA;EAMRe,QAAQC,eAAqD;IAI3D,OAAO,IAAIP,QAAQ,CAACC,SAASO,WAAW;MACtC,KAAKT,WAAW,KAAKA,SAASU,KAAK,MAAM;QACvC,KAAKN,gBAAgBK;QACrB,IAAI,KAAKN,QAAQ;UACf,OAAOM,OACL,IAAIH,gCACF,IAAId,gBACF;QAAA;QAKR,OAAOgB,gBAAgBE,KAAKR,SAASO;MAAA;IAAA;EAAA;AAAA;AAM7C,IAAOE,sBAAQC","names":["__export","AsyncQueueError","default","__toModule","import_base_error","constructor","message","name","__publicField","previous","Promise","resolve","closed","rejectCurrent","close","import_connection_error","enqueue","asyncFunction","reject","then","async_queue_default","AsyncQueue"],"sources":["C:\\Users\\rizla\\projects\\react\\NSBEHack-main\\nsbeapp\\node_modules\\sequelize\\src\\dialects\\mssql\\async-queue.ts"],"sourcesContent":["import BaseError from '../../errors/base-error';\nimport ConnectionError from '../../errors/connection-error';\n\n/**\n * Thrown when a connection to a database is closed while an operation is in progress\n */\nexport class AsyncQueueError extends BaseError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'SequelizeAsyncQueueError';\n  }\n}\n\nclass AsyncQueue {\n  previous: Promise<unknown>;\n  closed: boolean;\n  rejectCurrent: (reason?: any) => void;\n\n  constructor() {\n    this.previous = Promise.resolve();\n    this.closed = false;\n    this.rejectCurrent = () => {\n      /** do nothing */\n    };\n  }\n\n  close() {\n    this.closed = true;\n    this.rejectCurrent(\n      new ConnectionError(\n        new AsyncQueueError(\n          'the connection was closed before this query could finish executing'\n        )\n      )\n    );\n  }\n\n  enqueue(asyncFunction: (...args: any[]) => Promise<unknown>) {\n    // This outer promise might seems superflous since down below we return asyncFunction().then(resolve, reject).\n    // However, this ensures that this.previous will never be a rejected promise so the queue will\n    // always keep going, while still communicating rejection from asyncFunction to the user.\n    return new Promise((resolve, reject) => {\n      this.previous = this.previous.then(() => {\n        this.rejectCurrent = reject;\n        if (this.closed) {\n          return reject(\n            new ConnectionError(\n              new AsyncQueueError(\n                'the connection was closed before this query could be executed'\n              )\n            )\n          );\n        }\n        return asyncFunction().then(resolve, reject);\n      });\n    });\n  }\n}\n\nexport default AsyncQueue;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}