{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\nfunction stringifyRangeBound(bound) {\n  if (bound === null) {\n    return \"\";\n  }\n  if (bound === Infinity || bound === -Infinity) {\n    return bound.toString().toLowerCase();\n  }\n  return JSON.stringify(bound);\n}\nfunction parseRangeBound(bound, parseType) {\n  if (!bound) {\n    return null;\n  }\n  if (bound === \"infinity\") {\n    return Infinity;\n  }\n  if (bound === \"-infinity\") {\n    return -Infinity;\n  }\n  return parseType(bound);\n}\nfunction stringify(data) {\n  if (data === null) return null;\n  if (!Array.isArray(data)) throw new Error(\"range must be an array\");\n  if (!data.length) return \"empty\";\n  if (data.length !== 2) throw new Error(\"range array length must be 0 (empty) or 2 (lower and upper bounds)\");\n  if (Object.prototype.hasOwnProperty.call(data, \"inclusive\")) {\n    if (data.inclusive === false) data.inclusive = [false, false];else if (!data.inclusive) data.inclusive = [true, false];else if (data.inclusive === true) data.inclusive = [true, true];\n  } else {\n    data.inclusive = [true, false];\n  }\n  _.each(data, (value, index) => {\n    if (_.isObject(value)) {\n      if (Object.prototype.hasOwnProperty.call(value, \"inclusive\")) data.inclusive[index] = !!value.inclusive;\n      if (Object.prototype.hasOwnProperty.call(value, \"value\")) data[index] = value.value;\n    }\n  });\n  const lowerBound = stringifyRangeBound(data[0]);\n  const upperBound = stringifyRangeBound(data[1]);\n  return `${(data.inclusive[0] ? \"[\" : \"(\") + lowerBound},${upperBound}${data.inclusive[1] ? \"]\" : \")\"}`;\n}\nexports.stringify = stringify;\nfunction parse(value, parser) {\n  if (value === null) return null;\n  if (value === \"empty\") {\n    return [];\n  }\n  let result = value.substring(1, value.length - 1).split(\",\", 2);\n  if (result.length !== 2) return value;\n  result = result.map((item, index) => {\n    return {\n      value: parseRangeBound(item, parser),\n      inclusive: index === 0 ? value[0] === \"[\" : value[value.length - 1] === \"]\"\n    };\n  });\n  return result;\n}\nexports.parse = parse;","map":{"version":3,"mappings":";;AAEA,MAAMA,IAAIC,QAAQ;AAElB,6BAA6BC,OAAO;EAClC,IAAIA,UAAU,MAAM;IAClB,OAAO;EAAA;EAET,IAAIA,UAAUC,YAAYD,UAAU,WAAW;IAC7C,OAAOA,MAAME,WAAWC;EAAA;EAE1B,OAAOC,KAAKC,UAAUL;AAAA;AAGxB,yBAAyBA,OAAOM,WAAW;EACzC,IAAI,CAACN,OAAO;IACV,OAAO;EAAA;EAET,IAAIA,UAAU,YAAY;IACxB,OAAOC;EAAA;EAET,IAAID,UAAU,aAAa;IACzB,OAAO;EAAA;EAET,OAAOM,UAAUN;AAAA;AAInB,mBAAmBO,MAAM;EACvB,IAAIA,SAAS,MAAM,OAAO;EAE1B,IAAI,CAACC,MAAMC,QAAQF,OAAO,MAAM,IAAIG,MAAM;EAC1C,IAAI,CAACH,KAAKI,QAAQ,OAAO;EACzB,IAAIJ,KAAKI,WAAW,GAAG,MAAM,IAAID,MAAM;EAEvC,IAAIE,OAAOC,UAAUC,eAAeC,KAAKR,MAAM,cAAc;IAC3D,IAAIA,KAAKS,cAAc,OAAOT,KAAKS,YAAY,CAAC,OAAO,gBAC9C,CAACT,KAAKS,WAAWT,KAAKS,YAAY,CAAC,MAAM,gBACzCT,KAAKS,cAAc,MAAMT,KAAKS,YAAY,CAAC,MAAM;EAAA,OACrD;IACLT,KAAKS,YAAY,CAAC,MAAM;EAAA;EAG1BlB,EAAEmB,KAAKV,MAAM,CAACW,OAAOC,UAAU;IAC7B,IAAIrB,EAAEsB,SAASF,QAAQ;MACrB,IAAIN,OAAOC,UAAUC,eAAeC,KAAKG,OAAO,cAAcX,KAAKS,UAAUG,SAAS,CAAC,CAACD,MAAMF;MAC9F,IAAIJ,OAAOC,UAAUC,eAAeC,KAAKG,OAAO,UAAUX,KAAKY,SAASD,MAAMA;IAAA;EAAA;EAIlF,MAAMG,aAAaC,oBAAoBf,KAAK;EAC5C,MAAMgB,aAAaD,oBAAoBf,KAAK;EAE5C,OAAO,GAAI,MAAKS,UAAU,KAAK,MAAM,OAAOK,cAAcE,aAAahB,KAAKS,UAAU,KAAK,MAAM;AAAA;AAEnGQ,QAAQnB,YAAYA;AAEpB,eAAea,OAAOO,QAAQ;EAC5B,IAAIP,UAAU,MAAM,OAAO;EAC3B,IAAIA,UAAU,SAAS;IACrB,OAAO;EAAA;EAGT,IAAIQ,SAASR,MACVS,UAAU,GAAGT,MAAMP,SAAS,GAC5BiB,MAAM,KAAK;EAEd,IAAIF,OAAOf,WAAW,GAAG,OAAOO;EAEhCQ,SAASA,OAAOG,IAAI,CAACC,MAAMX,UAAU;IACnC,OAAO;MACLD,OAAOa,gBAAgBD,MAAML;MAC7BT,WAAWG,UAAU,IAAID,MAAM,OAAO,MAAMA,MAAMA,MAAMP,SAAS,OAAO;IAAA;EAAA;EAI5E,OAAOe;AAAA;AAETF,QAAQQ,QAAQA","names":["_","require","bound","Infinity","toString","toLowerCase","JSON","stringify","parseType","data","Array","isArray","Error","length","Object","prototype","hasOwnProperty","call","inclusive","each","value","index","isObject","lowerBound","stringifyRangeBound","upperBound","exports","parser","result","substring","split","map","item","parseRangeBound","parse"],"sources":["C:\\Users\\rizla\\projects\\react\\NSBEHack-main\\nsbeapp\\node_modules\\sequelize\\src\\dialects\\postgres\\range.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\n\nfunction stringifyRangeBound(bound) {\n  if (bound === null) {\n    return '' ;\n  }\n  if (bound === Infinity || bound === -Infinity) {\n    return bound.toString().toLowerCase();\n  }\n  return JSON.stringify(bound);\n}\n\nfunction parseRangeBound(bound, parseType) {\n  if (!bound) {\n    return null;\n  }\n  if (bound === 'infinity') {\n    return Infinity;\n  }\n  if (bound === '-infinity') {\n    return -Infinity;\n  }\n  return parseType(bound);\n\n}\n\nfunction stringify(data) {\n  if (data === null) return null;\n\n  if (!Array.isArray(data)) throw new Error('range must be an array');\n  if (!data.length) return 'empty';\n  if (data.length !== 2) throw new Error('range array length must be 0 (empty) or 2 (lower and upper bounds)');\n\n  if (Object.prototype.hasOwnProperty.call(data, 'inclusive')) {\n    if (data.inclusive === false) data.inclusive = [false, false];\n    else if (!data.inclusive) data.inclusive = [true, false];\n    else if (data.inclusive === true) data.inclusive = [true, true];\n  } else {\n    data.inclusive = [true, false];\n  }\n\n  _.each(data, (value, index) => {\n    if (_.isObject(value)) {\n      if (Object.prototype.hasOwnProperty.call(value, 'inclusive')) data.inclusive[index] = !!value.inclusive;\n      if (Object.prototype.hasOwnProperty.call(value, 'value')) data[index] = value.value;\n    }\n  });\n\n  const lowerBound = stringifyRangeBound(data[0]);\n  const upperBound = stringifyRangeBound(data[1]);\n\n  return `${(data.inclusive[0] ? '[' : '(') + lowerBound},${upperBound}${data.inclusive[1] ? ']' : ')'}`;\n}\nexports.stringify = stringify;\n\nfunction parse(value, parser) {\n  if (value === null) return null;\n  if (value === 'empty') {\n    return [];\n  }\n\n  let result = value\n    .substring(1, value.length - 1)\n    .split(',', 2);\n\n  if (result.length !== 2) return value;\n\n  result = result.map((item, index) => {\n    return {\n      value: parseRangeBound(item, parser),\n      inclusive: index === 0 ? value[0] === '[' : value[value.length - 1] === ']'\n    };\n  });\n\n  return result;\n}\nexports.parse = parse;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}