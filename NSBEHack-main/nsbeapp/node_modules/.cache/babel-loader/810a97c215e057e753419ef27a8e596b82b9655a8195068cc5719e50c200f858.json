{"ast":null,"code":"\"use strict\";\n\nconst wkx = require(\"wkx\");\nconst _ = require(\"lodash\");\nconst momentTz = require(\"moment-timezone\");\nconst moment = require(\"moment\");\nmodule.exports = BaseTypes => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = \"https://dev.mysql.com/doc/refman/5.7/en/data-types.html\";\n  BaseTypes.DATE.types.mysql = [\"DATETIME\"];\n  BaseTypes.STRING.types.mysql = [\"VAR_STRING\"];\n  BaseTypes.CHAR.types.mysql = [\"STRING\"];\n  BaseTypes.TEXT.types.mysql = [\"BLOB\"];\n  BaseTypes.TINYINT.types.mysql = [\"TINY\"];\n  BaseTypes.SMALLINT.types.mysql = [\"SHORT\"];\n  BaseTypes.MEDIUMINT.types.mysql = [\"INT24\"];\n  BaseTypes.INTEGER.types.mysql = [\"LONG\"];\n  BaseTypes.BIGINT.types.mysql = [\"LONGLONG\"];\n  BaseTypes.FLOAT.types.mysql = [\"FLOAT\"];\n  BaseTypes.TIME.types.mysql = [\"TIME\"];\n  BaseTypes.DATEONLY.types.mysql = [\"DATE\"];\n  BaseTypes.BOOLEAN.types.mysql = [\"TINY\"];\n  BaseTypes.BLOB.types.mysql = [\"TINYBLOB\", \"BLOB\", \"LONGBLOB\"];\n  BaseTypes.DECIMAL.types.mysql = [\"NEWDECIMAL\"];\n  BaseTypes.UUID.types.mysql = false;\n  BaseTypes.ENUM.types.mysql = false;\n  BaseTypes.REAL.types.mysql = [\"DOUBLE\"];\n  BaseTypes.DOUBLE.types.mysql = [\"DOUBLE\"];\n  BaseTypes.GEOMETRY.types.mysql = [\"GEOMETRY\"];\n  BaseTypes.JSON.types.mysql = [\"JSON\"];\n  class DECIMAL extends BaseTypes.DECIMAL {\n    toSql() {\n      let definition = super.toSql();\n      if (this._unsigned) {\n        definition += \" UNSIGNED\";\n      }\n      if (this._zerofill) {\n        definition += \" ZEROFILL\";\n      }\n      return definition;\n    }\n  }\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return this._length ? `DATETIME(${this._length})` : \"DATETIME\";\n    }\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n      if (this._length) {\n        return date.format(\"YYYY-MM-DD HH:mm:ss.SSS\");\n      }\n      return date.format(\"YYYY-MM-DD HH:mm:ss\");\n    }\n    static parse(value, options) {\n      value = value.string();\n      if (value === null) {\n        return value;\n      }\n      if (momentTz.tz.zone(options.timezone)) {\n        value = momentTz.tz(value, options.timezone).toDate();\n      } else {\n        value = new Date(`${value} ${options.timezone}`);\n      }\n      return value;\n    }\n  }\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return value.string();\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return \"CHAR(36) BINARY\";\n    }\n  }\n  const SUPPORTED_GEOMETRY_TYPES = [\"POINT\", \"LINESTRING\", \"POLYGON\"];\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    constructor(type, srid) {\n      super(type, srid);\n      if (_.isEmpty(this.type)) {\n        this.sqlType = this.key;\n        return;\n      }\n      if (SUPPORTED_GEOMETRY_TYPES.includes(this.type)) {\n        this.sqlType = this.type;\n        return;\n      }\n      throw new Error(`Supported geometry types are: ${SUPPORTED_GEOMETRY_TYPES.join(\", \")}`);\n    }\n    static parse(value) {\n      value = value.buffer();\n      if (!value || value.length === 0) {\n        return null;\n      }\n      value = value.slice(4);\n      return wkx.Geometry.parse(value).toGeoJSON({\n        shortCrs: true\n      });\n    }\n    toSql() {\n      return this.sqlType;\n    }\n  }\n  class ENUM extends BaseTypes.ENUM {\n    toSql(options) {\n      return `ENUM(${this.values.map(value => options.escape(value)).join(\", \")})`;\n    }\n  }\n  class JSONTYPE extends BaseTypes.JSON {\n    _stringify(value, options) {\n      return options.operation === \"where\" && typeof value === \"string\" ? value : JSON.stringify(value);\n    }\n  }\n  return {\n    ENUM,\n    DATE,\n    DATEONLY,\n    UUID,\n    GEOMETRY,\n    DECIMAL,\n    JSON: JSONTYPE\n  };\n};","map":{"version":3,"mappings":"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","names":["wkx","require","_","momentTz","moment","module","exports","BaseTypes","ABSTRACT","prototype","dialectTypes","DATE","types","mysql","STRING","CHAR","TEXT","TINYINT","SMALLINT","MEDIUMINT","INTEGER","BIGINT","FLOAT","TIME","DATEONLY","BOOLEAN","BLOB","DECIMAL","UUID","ENUM","REAL","DOUBLE","GEOMETRY","JSON","toSql","definition","_unsigned","_zerofill","_length","_stringify","date","options","isMoment","_applyTimezone","format","parse","value","string","tz","zone","timezone","toDate","Date","SUPPORTED_GEOMETRY_TYPES","constructor","type","srid","isEmpty","sqlType","key","includes","Error","join","buffer","length","slice","Geometry","toGeoJSON","shortCrs","values","map","escape","operation","stringify","JSONTYPE"],"sources":["C:\\Users\\rizla\\projects\\react\\NSBEHack-main\\nsbeapp\\node_modules\\sequelize\\src\\dialects\\mysql\\data-types.js"],"sourcesContent":["'use strict';\n\nconst wkx = require('wkx');\nconst _ = require('lodash');\nconst momentTz = require('moment-timezone');\nconst moment = require('moment');\n\nmodule.exports = BaseTypes => {\n  BaseTypes.ABSTRACT.prototype.dialectTypes = 'https://dev.mysql.com/doc/refman/5.7/en/data-types.html';\n\n  /**\n   * types: [buffer_type, ...]\n   *\n   * @see buffer_type here https://dev.mysql.com/doc/refman/5.7/en/c-api-prepared-statement-type-codes.html\n   * @see hex here https://github.com/sidorares/node-mysql2/blob/master/lib/constants/types.js\n   */\n\n  BaseTypes.DATE.types.mysql = ['DATETIME'];\n  BaseTypes.STRING.types.mysql = ['VAR_STRING'];\n  BaseTypes.CHAR.types.mysql = ['STRING'];\n  BaseTypes.TEXT.types.mysql = ['BLOB'];\n  BaseTypes.TINYINT.types.mysql = ['TINY'];\n  BaseTypes.SMALLINT.types.mysql = ['SHORT'];\n  BaseTypes.MEDIUMINT.types.mysql = ['INT24'];\n  BaseTypes.INTEGER.types.mysql = ['LONG'];\n  BaseTypes.BIGINT.types.mysql = ['LONGLONG'];\n  BaseTypes.FLOAT.types.mysql = ['FLOAT'];\n  BaseTypes.TIME.types.mysql = ['TIME'];\n  BaseTypes.DATEONLY.types.mysql = ['DATE'];\n  BaseTypes.BOOLEAN.types.mysql = ['TINY'];\n  BaseTypes.BLOB.types.mysql = ['TINYBLOB', 'BLOB', 'LONGBLOB'];\n  BaseTypes.DECIMAL.types.mysql = ['NEWDECIMAL'];\n  BaseTypes.UUID.types.mysql = false;\n  BaseTypes.ENUM.types.mysql = false;\n  BaseTypes.REAL.types.mysql = ['DOUBLE'];\n  BaseTypes.DOUBLE.types.mysql = ['DOUBLE'];\n  BaseTypes.GEOMETRY.types.mysql = ['GEOMETRY'];\n  BaseTypes.JSON.types.mysql = ['JSON'];\n\n  class DECIMAL extends BaseTypes.DECIMAL {\n    toSql() {\n      let definition = super.toSql();\n      if (this._unsigned) {\n        definition += ' UNSIGNED';\n      }\n      if (this._zerofill) {\n        definition += ' ZEROFILL';\n      }\n      return definition;\n    }\n  }\n\n  class DATE extends BaseTypes.DATE {\n    toSql() {\n      return this._length ? `DATETIME(${this._length})` : 'DATETIME';\n    }\n    _stringify(date, options) {\n      if (!moment.isMoment(date)) {\n        date = this._applyTimezone(date, options);\n      }\n      // Fractional DATETIMEs only supported on MySQL 5.6.4+\n      if (this._length) {\n        return date.format('YYYY-MM-DD HH:mm:ss.SSS');\n      }\n      return date.format('YYYY-MM-DD HH:mm:ss');\n    }\n    static parse(value, options) {\n      value = value.string();\n      if (value === null) {\n        return value;\n      }\n      if (momentTz.tz.zone(options.timezone)) {\n        value = momentTz.tz(value, options.timezone).toDate();\n      }\n      else {\n        value = new Date(`${value} ${options.timezone}`);\n      }\n      return value;\n    }\n  }\n\n  class DATEONLY extends BaseTypes.DATEONLY {\n    static parse(value) {\n      return value.string();\n    }\n  }\n  class UUID extends BaseTypes.UUID {\n    toSql() {\n      return 'CHAR(36) BINARY';\n    }\n  }\n\n  const SUPPORTED_GEOMETRY_TYPES = ['POINT', 'LINESTRING', 'POLYGON'];\n\n  class GEOMETRY extends BaseTypes.GEOMETRY {\n    constructor(type, srid) {\n      super(type, srid);\n      if (_.isEmpty(this.type)) {\n        this.sqlType = this.key;\n        return;\n      }\n      if (SUPPORTED_GEOMETRY_TYPES.includes(this.type)) {\n        this.sqlType = this.type;\n        return;\n      }\n      throw new Error(`Supported geometry types are: ${SUPPORTED_GEOMETRY_TYPES.join(', ')}`);\n    }\n    static parse(value) {\n      value = value.buffer();\n      // Empty buffer, MySQL doesn't support POINT EMPTY\n      // check, https://dev.mysql.com/worklog/task/?id=2381\n      if (!value || value.length === 0) {\n        return null;\n      }\n      // For some reason, discard the first 4 bytes\n      value = value.slice(4);\n      return wkx.Geometry.parse(value).toGeoJSON({ shortCrs: true });\n    }\n    toSql() {\n      return this.sqlType;\n    }\n  }\n\n  class ENUM extends BaseTypes.ENUM {\n    toSql(options) {\n      return `ENUM(${this.values.map(value => options.escape(value)).join(', ')})`;\n    }\n  }\n\n  class JSONTYPE extends BaseTypes.JSON {\n    _stringify(value, options) {\n      return options.operation === 'where' && typeof value === 'string' ? value : JSON.stringify(value);\n    }\n  }\n\n  return {\n    ENUM,\n    DATE,\n    DATEONLY,\n    UUID,\n    GEOMETRY,\n    DECIMAL,\n    JSON: JSONTYPE\n  };\n};\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}