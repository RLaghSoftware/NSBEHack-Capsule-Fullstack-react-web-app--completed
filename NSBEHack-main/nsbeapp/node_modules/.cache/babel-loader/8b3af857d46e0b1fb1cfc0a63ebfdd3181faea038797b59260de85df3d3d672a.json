{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = require(\"lodash\");\nconst Utils = require(\"../../utils\");\nconst DataTypes = require(\"../../data-types\");\nconst Transaction = require(\"../../transaction\");\nconst QueryTypes = require(\"../../query-types\");\nclass QueryInterface {\n  constructor(sequelize, queryGenerator) {\n    this.sequelize = sequelize;\n    this.queryGenerator = queryGenerator;\n  }\n  async createDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createDatabaseQuery(database, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async dropDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropDatabaseQuery(database);\n    return await this.sequelize.query(sql, options);\n  }\n  async createSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n  async dropSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n  async dropAllSchemas(options) {\n    options = options || {};\n    if (!this.queryGenerator._dialect.supports.schemas) {\n      return this.sequelize.drop(options);\n    }\n    const schemas = await this.showAllSchemas(options);\n    return Promise.all(schemas.map(schemaName => this.dropSchema(schemaName, options)));\n  }\n  async showAllSchemas(options) {\n    options = __spreadProps(__spreadValues({}, options), {\n      raw: true,\n      type: this.sequelize.QueryTypes.SELECT\n    });\n    const showSchemasSql = this.queryGenerator.showSchemasQuery(options);\n    const schemaNames = await this.sequelize.query(showSchemasSql, options);\n    return _.flatten(schemaNames.map(value => value.schema_name ? value.schema_name : value));\n  }\n  async databaseVersion(options) {\n    return await this.sequelize.query(this.queryGenerator.versionQuery(), __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.VERSION\n    }));\n  }\n  async createTable(tableName, attributes, options, model) {\n    let sql = \"\";\n    options = __spreadValues({}, options);\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, uniqueKey => {\n        if (uniqueKey.customIndex === void 0) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n    attributes = _.mapValues(attributes, attribute => this.sequelize.normalizeAttribute(attribute));\n    await this.ensureEnums(tableName, attributes, options, model);\n    if (!tableName.schema && (options.schema || !!model && model._schema)) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n    attributes = this.queryGenerator.attributesToSQL(attributes, {\n      table: tableName,\n      context: \"createTable\",\n      withoutForeignKeyConstraints: options.withoutForeignKeyConstraints\n    });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async tableExists(tableName, options) {\n    const sql = this.queryGenerator.tableExistsQuery(tableName);\n    const out = await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.SHOWTABLES\n    }));\n    return out.length === 1;\n  }\n  async dropTable(tableName, options) {\n    options = __spreadValues({}, options);\n    options.cascade = options.cascade || options.force || false;\n    const sql = this.queryGenerator.dropTableQuery(tableName, options);\n    await this.sequelize.query(sql, options);\n  }\n  async _dropAllTables(tableNames, skip, options) {\n    for (const tableName of tableNames) {\n      if (!skip.includes(tableName.tableName || tableName)) {\n        await this.dropTable(tableName, __spreadProps(__spreadValues({}, options), {\n          cascade: true\n        }));\n      }\n    }\n  }\n  async dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n    const tableNames = await this.showAllTables(options);\n    const foreignKeys = await this.getForeignKeysForTables(tableNames, options);\n    for (const tableName of tableNames) {\n      let normalizedTableName = tableName;\n      if (_.isObject(tableName)) {\n        normalizedTableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n      for (const foreignKey of foreignKeys[normalizedTableName]) {\n        await this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, foreignKey));\n      }\n    }\n    await this._dropAllTables(tableNames, skip, options);\n  }\n  async renameTable(before, after, options) {\n    options = options || {};\n    const sql = this.queryGenerator.renameTableQuery(before, after);\n    return await this.sequelize.query(sql, options);\n  }\n  async showAllTables(options) {\n    options = __spreadProps(__spreadValues({}, options), {\n      raw: true,\n      type: QueryTypes.SHOWTABLES\n    });\n    const showTablesSql = this.queryGenerator.showTablesQuery(this.sequelize.config.database);\n    const tableNames = await this.sequelize.query(showTablesSql, options);\n    return _.flatten(tableNames);\n  }\n  async describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n    if (typeof options === \"string\") {\n      schema = options;\n    } else if (typeof options === \"object\" && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n    if (typeof tableName === \"object\" && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.DESCRIBE\n    });\n    try {\n      const data = await this.sequelize.query(sql, options);\n      if (_.isEmpty(data)) {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n      return data;\n    } catch (e) {\n      if (e.original && e.original.code === \"ER_NO_SUCH_TABLE\") {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n      throw e;\n    }\n  }\n  async addColumn(table, key, attribute, options) {\n    if (!table || !key || !attribute) {\n      throw new Error(\"addColumn takes at least 3 arguments (table, attribute name, attribute definition)\");\n    }\n    options = options || {};\n    attribute = this.sequelize.normalizeAttribute(attribute);\n    return await this.sequelize.query(this.queryGenerator.addColumnQuery(table, key, attribute), options);\n  }\n  async removeColumn(tableName, attributeName, options) {\n    return this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, attributeName), options);\n  }\n  normalizeAttribute(dataTypeOrOptions) {\n    let attribute;\n    if (Object.values(DataTypes).includes(dataTypeOrOptions)) {\n      attribute = {\n        type: dataTypeOrOptions,\n        allowNull: true\n      };\n    } else {\n      attribute = dataTypeOrOptions;\n    }\n    return this.sequelize.normalizeAttribute(attribute);\n  }\n  quoteIdentifier(identifier2, force) {\n    return this.queryGenerator.quoteIdentifier(identifier2, force);\n  }\n  quoteIdentifiers(identifiers) {\n    return this.queryGenerator.quoteIdentifiers(identifiers);\n  }\n  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    options = options || {};\n    const query = this.queryGenerator.attributesToSQL({\n      [attributeName]: this.normalizeAttribute(dataTypeOrOptions)\n    }, {\n      context: \"changeColumn\",\n      table: tableName\n    });\n    const sql = this.queryGenerator.changeColumnQuery(tableName, query);\n    return this.sequelize.query(sql, options);\n  }\n  async assertTableHasColumn(tableName, columnName, options) {\n    const description = await this.describeTable(tableName, options);\n    if (description[columnName]) {\n      return description;\n    }\n    throw new Error(`Table ${tableName} doesn't have the column ${columnName}`);\n  }\n  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    const data = (await this.assertTableHasColumn(tableName, attrNameBefore, options))[attrNameBefore];\n    const _options = {};\n    _options[attrNameAfter] = {\n      attribute: attrNameAfter,\n      type: data.type,\n      allowNull: data.allowNull,\n      defaultValue: data.defaultValue\n    };\n    if (data.defaultValue === null && !data.allowNull) {\n      delete _options[attrNameAfter].defaultValue;\n    }\n    const sql = this.queryGenerator.renameColumnQuery(tableName, attrNameBefore, this.queryGenerator.attributesToSQL(_options));\n    return await this.sequelize.query(sql, options);\n  }\n  async addIndex(tableName, attributes, options, rawTablename) {\n    if (!Array.isArray(attributes)) {\n      rawTablename = options;\n      options = attributes;\n      attributes = options.fields;\n    }\n    if (!rawTablename) {\n      rawTablename = tableName;\n    }\n    options = Utils.cloneDeep(options);\n    options.fields = attributes;\n    const sql = this.queryGenerator.addIndexQuery(tableName, options, rawTablename);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      supportsSearchPath: false\n    }));\n  }\n  async showIndex(tableName, options) {\n    const sql = this.queryGenerator.showIndexesQuery(tableName, options);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.SHOWINDEXES\n    }));\n  }\n  async getForeignKeysForTables(tableNames, options) {\n    if (tableNames.length === 0) {\n      return {};\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n    const results = await Promise.all(tableNames.map(tableName => this.sequelize.query(this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database), options)));\n    const result = {};\n    tableNames.forEach((tableName, i) => {\n      if (_.isObject(tableName)) {\n        tableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n      result[tableName] = Array.isArray(results[i]) ? results[i].map(r => r.constraint_name) : [results[i] && results[i].constraint_name];\n      result[tableName] = result[tableName].filter(_.identity);\n    });\n    return result;\n  }\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database);\n    return this.sequelize.query(query, queryOptions);\n  }\n  async removeIndex(tableName, indexNameOrAttributes, options) {\n    options = options || {};\n    const sql = this.queryGenerator.removeIndexQuery(tableName, indexNameOrAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async addConstraint(tableName, options) {\n    if (!options.fields) {\n      throw new Error(\"Fields must be specified through options.fields\");\n    }\n    if (!options.type) {\n      throw new Error(\"Constraint type must be specified through options.type\");\n    }\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.addConstraintQuery(tableName, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async showConstraint(tableName, constraintName, options) {\n    const sql = this.queryGenerator.showConstraintsQuery(tableName, constraintName);\n    return await this.sequelize.query(sql, __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.SHOWCONSTRAINTS\n    }));\n  }\n  async removeConstraint(tableName, constraintName, options) {\n    return this.sequelize.query(this.queryGenerator.removeConstraintQuery(tableName, constraintName), options);\n  }\n  async insert(instance, tableName, values, options) {\n    options = Utils.cloneDeep(options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.queryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);\n    options.type = QueryTypes.INSERT;\n    options.instance = instance;\n    const results = await this.sequelize.query(sql, options);\n    if (instance) results[0].isNewRecord = false;\n    return results;\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = options.conflictFields || [];\n    if (options.upsertKeys.length === 0) {\n      const primaryKeys = Object.values(model.primaryKeys).map(item => item.field);\n      const uniqueKeys = Object.values(model.uniqueKeys).filter(c => c.fields.length > 0).map(c => c.fields);\n      const indexKeys = Object.values(model._indexes).filter(c => c.unique && c.fields.length > 0).map(c => c.fields);\n      for (const field of options.updateOnDuplicate) {\n        const uniqueKey = uniqueKeys.find(fields => fields.includes(field));\n        if (uniqueKey) {\n          options.upsertKeys = uniqueKey;\n          break;\n        }\n        const indexKey = indexKeys.find(fields => fields.includes(field));\n        if (indexKey) {\n          options.upsertKeys = indexKey;\n          break;\n        }\n      }\n      if (options.upsertKeys.length === 0 || _.intersection(options.updateOnDuplicate, primaryKeys).length) {\n        options.upsertKeys = primaryKeys;\n      }\n      options.upsertKeys = _.uniq(options.upsertKeys);\n    }\n    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n  async bulkInsert(tableName, records, options, attributes) {\n    options = __spreadValues({}, options);\n    options.type = QueryTypes.INSERT;\n    const results = await this.sequelize.query(this.queryGenerator.bulkInsertQuery(tableName, records, options, attributes), options);\n    return results[0];\n  }\n  async update(instance, tableName, values, identifier2, options) {\n    options = __spreadValues({}, options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier2, options, instance.constructor.rawAttributes);\n    options.type = QueryTypes.UPDATE;\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n  async bulkUpdate(tableName, values, identifier2, options, attributes) {\n    options = Utils.cloneDeep(options);\n    if (typeof identifier2 === \"object\") identifier2 = Utils.cloneDeep(identifier2);\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier2, options, attributes);\n    const table = _.isObject(tableName) ? tableName : {\n      tableName\n    };\n    const model = options.model ? options.model : _.find(this.sequelize.modelManager.models, {\n      tableName: table.tableName\n    });\n    options.type = QueryTypes.BULKUPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n  async delete(instance, tableName, identifier2, options) {\n    const cascades = [];\n    const sql = this.queryGenerator.deleteQuery(tableName, identifier2, {}, instance.constructor);\n    options = __spreadValues({}, options);\n    if (!!instance.constructor && !!instance.constructor.associations) {\n      const keys = Object.keys(instance.constructor.associations);\n      const length = keys.length;\n      let association;\n      for (let i = 0; i < length; i++) {\n        association = instance.constructor.associations[keys[i]];\n        if (association.options && association.options.onDelete && association.options.onDelete.toLowerCase() === \"cascade\" && association.options.useHooks === true) {\n          cascades.push(association.accessors.get);\n        }\n      }\n    }\n    for (const cascade of cascades) {\n      let instances = await instance[cascade](options);\n      if (!instances) continue;\n      if (!Array.isArray(instances)) instances = [instances];\n      for (const _instance of instances) await _instance.destroy(options);\n    }\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n  async bulkDelete(tableName, where, options, model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      limit: null\n    });\n    if (options.truncate === true) {\n      return this.sequelize.query(this.queryGenerator.truncateTableQuery(tableName, options), options);\n    }\n    if (typeof identifier === \"object\") where = Utils.cloneDeep(where);\n    return await this.sequelize.query(this.queryGenerator.deleteQuery(tableName, where, options, model), options);\n  }\n  async select(model, tableName, optionsArg) {\n    const options = __spreadProps(__spreadValues({}, optionsArg), {\n      type: QueryTypes.SELECT,\n      model\n    });\n    return await this.sequelize.query(this.queryGenerator.selectQuery(tableName, options, model), options);\n  }\n  async increment(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.arithmeticQuery(\"+\", tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n  async decrement(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n    const sql = this.queryGenerator.arithmeticQuery(\"-\", tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n  async rawSelect(tableName, options, attributeSelector, Model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      raw: true,\n      plain: true,\n      type: QueryTypes.SELECT\n    });\n    const sql = this.queryGenerator.selectQuery(tableName, options, Model);\n    if (attributeSelector === void 0) {\n      throw new Error(\"Please pass an attribute selector!\");\n    }\n    const data = await this.sequelize.query(sql, options);\n    if (!options.plain) {\n      return data;\n    }\n    const result = data ? data[attributeSelector] : null;\n    if (!options || !options.dataType) {\n      return result;\n    }\n    const dataType = options.dataType;\n    if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {\n      if (result !== null) {\n        return parseFloat(result);\n      }\n    }\n    if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {\n      if (result !== null) {\n        return parseInt(result, 10);\n      }\n    }\n    if (dataType instanceof DataTypes.DATE) {\n      if (result !== null && !(result instanceof Date)) {\n        return new Date(result);\n      }\n    }\n    return result;\n  }\n  async createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray, options) {\n    const sql = this.queryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async dropTrigger(tableName, triggerName, options) {\n    const sql = this.queryGenerator.dropTrigger(tableName, triggerName);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async renameTrigger(tableName, oldTriggerName, newTriggerName, options) {\n    const sql = this.queryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    const sql = this.queryGenerator.createFunction(functionName, params, returnType, language, body, optionsArray, options);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async dropFunction(functionName, params, options) {\n    const sql = this.queryGenerator.dropFunction(functionName, params);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async renameFunction(oldFunctionName, params, newFunctionName, options) {\n    const sql = this.queryGenerator.renameFunction(oldFunctionName, params, newFunctionName);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  ensureEnums() {}\n  async setIsolationLevel(transaction, value, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to set isolation level for a transaction without transaction object!\");\n    }\n    if (transaction.parent || !value) {\n      return;\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction\n    });\n    const sql = this.queryGenerator.setIsolationLevelQuery(value, {\n      parent: transaction.parent\n    });\n    if (!sql) return;\n    return await this.sequelize.query(sql, options);\n  }\n  async startTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to start a transaction without transaction object!\");\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction\n    });\n    options.transaction.name = transaction.parent ? transaction.name : void 0;\n    const sql = this.queryGenerator.startTransactionQuery(transaction);\n    return await this.sequelize.query(sql, options);\n  }\n  async deferConstraints(transaction, options) {\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction\n    });\n    const sql = this.queryGenerator.deferConstraintsQuery(options);\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n  async commitTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to commit a transaction without transaction object!\");\n    }\n    if (transaction.parent) {\n      return;\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    });\n    const sql = this.queryGenerator.commitTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n    transaction.finished = \"commit\";\n    return await promise;\n  }\n  async rollbackTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error(\"Unable to rollback a transaction without transaction object!\");\n    }\n    options = __spreadProps(__spreadValues({}, options), {\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    });\n    options.transaction.name = transaction.parent ? transaction.name : void 0;\n    const sql = this.queryGenerator.rollbackTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n    transaction.finished = \"rollback\";\n    return await promise;\n  }\n}\nexports.QueryInterface = QueryInterface;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;AAEA,MAAMA,IAAIC,QAAQ;AAElB,MAAMC,QAAQD,QAAQ;AACtB,MAAME,YAAYF,QAAQ;AAC1B,MAAMG,cAAcH,QAAQ;AAC5B,MAAMI,aAAaJ,QAAQ;AAK3B,qBAAqB;EACnBK,YAAYC,WAAWC,gBAAgB;IACrC,KAAKD,YAAYA;IACjB,KAAKC,iBAAiBA;EAAA;EAAA,MAgBlBC,eAAeC,UAAUC,SAAS;IACtCA,UAAUA,WAAW;IACrB,MAAMC,MAAM,KAAKJ,eAAeK,oBAAoBH,UAAUC;IAC9D,OAAO,MAAM,KAAKJ,UAAUO,MAAMF,KAAKD;EAAA;EAAA,MAWnCI,aAAaL,UAAUC,SAAS;IACpCA,UAAUA,WAAW;IACrB,MAAMC,MAAM,KAAKJ,eAAeQ,kBAAkBN;IAClD,OAAO,MAAM,KAAKH,UAAUO,MAAMF,KAAKD;EAAA;EAAA,MAWnCM,aAAaC,QAAQP,SAAS;IAClCA,UAAUA,WAAW;IACrB,MAAMC,MAAM,KAAKJ,eAAeS,aAAaC;IAC7C,OAAO,MAAM,KAAKX,UAAUO,MAAMF,KAAKD;EAAA;EAAA,MAWnCQ,WAAWD,QAAQP,SAAS;IAChCA,UAAUA,WAAW;IACrB,MAAMC,MAAM,KAAKJ,eAAeW,WAAWD;IAC3C,OAAO,MAAM,KAAKX,UAAUO,MAAMF,KAAKD;EAAA;EAAA,MAUnCS,eAAeT,SAAS;IAC5BA,UAAUA,WAAW;IAErB,IAAI,CAAC,KAAKH,eAAea,SAASC,SAASC,SAAS;MAClD,OAAO,KAAKhB,UAAUiB,KAAKb;IAAA;IAE7B,MAAMY,UAAU,MAAM,KAAKE,eAAed;IAC1C,OAAOe,QAAQC,IAAIJ,QAAQK,IAAIC,cAAc,KAAKV,WAAWU,YAAYlB;EAAA;EAAA,MAUrEc,eAAed,SAAS;IAC5BA,UAAUmB,iCACLnB,UADK;MAERoB,KAAK;MACLC,MAAM,KAAKzB,UAAUF,WAAW4B;IAAA;IAGlC,MAAMC,iBAAiB,KAAK1B,eAAe2B,iBAAiBxB;IAE5D,MAAMyB,cAAc,MAAM,KAAK7B,UAAUO,MAAMoB,gBAAgBvB;IAE/D,OAAOX,EAAEqC,QAAQD,YAAYR,IAAIU,SAASA,MAAMC,cAAcD,MAAMC,cAAcD;EAAA;EAAA,MAY9EE,gBAAgB7B,SAAS;IAC7B,OAAO,MAAM,KAAKJ,UAAUO,MAC1B,KAAKN,eAAeiC,gBACpBX,iCAAKnB,UAAL;MAAcqB,MAAM3B,WAAWqC;IAAA;EAAA;EAAA,MAyD7BC,YAAYC,WAAWC,YAAYlC,SAASmC,OAAO;IACvD,IAAIlC,MAAM;IAEVD,UAAUoC,mBAAKpC;IAEf,IAAIA,WAAWA,QAAQqC,YAAY;MACjChD,EAAEiD,OAAOtC,QAAQqC,YAAYE,aAAa;QACxC,IAAIA,UAAUC,gBAAgB,QAAW;UACvCD,UAAUC,cAAc;QAAA;MAAA;IAAA;IAK9B,IAAIL,OAAO;MACTnC,QAAQqC,aAAarC,QAAQqC,cAAcF,MAAME;IAAA;IAGnDH,aAAa7C,EAAEoD,UACbP,YACAQ,aAAa,KAAK9C,UAAU+C,mBAAmBD;IAIjD,MAAM,KAAKE,YAAYX,WAAWC,YAAYlC,SAASmC;IAEvD,IACE,CAACF,UAAU1B,WACVP,QAAQO,UAAU,CAAC,CAAC4B,SAASA,MAAMU,UACpC;MACAZ,YAAY,KAAKpC,eAAeiD,UAAU;QACxCb;QACAY,SAAS,CAAC,CAACV,SAASA,MAAMU,WAAW7C,QAAQO;MAAA;IAAA;IAIjD2B,aAAa,KAAKrC,eAAekD,gBAAgBb,YAAY;MAC3Dc,OAAOf;MACPgB,SAAS;MACTC,8BAA8BlD,QAAQkD;IAAA;IAExCjD,MAAM,KAAKJ,eAAesD,iBAAiBlB,WAAWC,YAAYlC;IAElE,OAAO,MAAM,KAAKJ,UAAUO,MAAMF,KAAKD;EAAA;EAAA,MAUnCoD,YAAYnB,WAAWjC,SAAS;IACpC,MAAMC,MAAM,KAAKJ,eAAewD,iBAAiBpB;IAEjD,MAAMqB,MAAM,MAAM,KAAK1D,UAAUO,MAAMF,KAAKkB,iCACvCnB,UADuC;MAE1CqB,MAAM3B,WAAW6D;IAAA;IAGnB,OAAOD,IAAIE,WAAW;EAAA;EAAA,MAWlBC,UAAUxB,WAAWjC,SAAS;IAElCA,UAAUoC,mBAAKpC;IACfA,QAAQ0D,UAAU1D,QAAQ0D,WAAW1D,QAAQ2D,SAAS;IAEtD,MAAM1D,MAAM,KAAKJ,eAAe+D,eAAe3B,WAAWjC;IAE1D,MAAM,KAAKJ,UAAUO,MAAMF,KAAKD;EAAA;EAAA,MAG5B6D,eAAeC,YAAYC,MAAM/D,SAAS;IAC9C,WAAWiC,aAAa6B,YAAY;MAElC,IAAI,CAACC,KAAKC,SAAS/B,UAAUA,aAAaA,YAAY;QACpD,MAAM,KAAKwB,UAAUxB,WAAWd,iCAAKnB,UAAL;UAAc0D,SAAS;QAAA;MAAA;IAAA;EAAA;EAAA,MAavDO,cAAcjE,SAAS;IAC3BA,UAAUA,WAAW;IACrB,MAAM+D,OAAO/D,QAAQ+D,QAAQ;IAE7B,MAAMD,aAAa,MAAM,KAAKI,cAAclE;IAC5C,MAAMmE,cAAc,MAAM,KAAKC,wBAAwBN,YAAY9D;IAEnE,WAAWiC,aAAa6B,YAAY;MAClC,IAAIO,sBAAsBpC;MAC1B,IAAI5C,EAAEiF,SAASrC,YAAY;QACzBoC,sBAAsB,GAAGpC,UAAU1B,UAAU0B,UAAUA;MAAA;MAGzD,WAAWsC,cAAcJ,YAAYE,sBAAsB;QACzD,MAAM,KAAKzE,UAAUO,MAAM,KAAKN,eAAe2E,oBAAoBvC,WAAWsC;MAAA;IAAA;IAGlF,MAAM,KAAKV,eAAeC,YAAYC,MAAM/D;EAAA;EAAA,MAYxCyE,YAAYC,QAAQC,OAAO3E,SAAS;IACxCA,UAAUA,WAAW;IACrB,MAAMC,MAAM,KAAKJ,eAAe+E,iBAAiBF,QAAQC;IACzD,OAAO,MAAM,KAAK/E,UAAUO,MAAMF,KAAKD;EAAA;EAAA,MAanCkE,cAAclE,SAAS;IAC3BA,UAAUmB,iCACLnB,UADK;MAERoB,KAAK;MACLC,MAAM3B,WAAW6D;IAAA;IAGnB,MAAMsB,gBAAgB,KAAKhF,eAAeiF,gBAAgB,KAAKlF,UAAUmF,OAAOhF;IAChF,MAAM+D,aAAa,MAAM,KAAKlE,UAAUO,MAAM0E,eAAe7E;IAC7D,OAAOX,EAAEqC,QAAQoC;EAAA;EAAA,MA4BbkB,cAAc/C,WAAWjC,SAAS;IACtC,IAAIO,SAAS;IACb,IAAI0E,kBAAkB;IAEtB,IAAI,OAAOjF,YAAY,UAAU;MAC/BO,SAASP;IAAA,WACA,OAAOA,YAAY,YAAYA,YAAY,MAAM;MAC1DO,SAASP,QAAQO,UAAU;MAC3B0E,kBAAkBjF,QAAQiF,mBAAmB;IAAA;IAG/C,IAAI,OAAOhD,cAAc,YAAYA,cAAc,MAAM;MACvD1B,SAAS0B,UAAU1B;MACnB0B,YAAYA,UAAUA;IAAA;IAGxB,MAAMhC,MAAM,KAAKJ,eAAeqF,mBAAmBjD,WAAW1B,QAAQ0E;IACtEjF,UAAUmB,iCAAKnB,UAAL;MAAcqB,MAAM3B,WAAWyF;IAAA;IAEzC,IAAI;MACF,MAAMC,OAAO,MAAM,KAAKxF,UAAUO,MAAMF,KAAKD;MAM7C,IAAIX,EAAEgG,QAAQD,OAAO;QACnB,MAAM,IAAIE,MAAM,6BAA6BrD;MAAA;MAG/C,OAAOmD;IAAA,SACAG,GAAP;MACA,IAAIA,EAAEC,YAAYD,EAAEC,SAASC,SAAS,oBAAoB;QACxD,MAAM,IAAIH,MAAM,6BAA6BrD;MAAA;MAG/C,MAAMsD;IAAA;EAAA;EAAA,MAoBJG,UAAU1C,OAAO2C,KAAKjD,WAAW1C,SAAS;IAC9C,IAAI,CAACgD,SAAS,CAAC2C,OAAO,CAACjD,WAAW;MAChC,MAAM,IAAI4C,MAAM;IAAA;IAGlBtF,UAAUA,WAAW;IACrB0C,YAAY,KAAK9C,UAAU+C,mBAAmBD;IAC9C,OAAO,MAAM,KAAK9C,UAAUO,MAAM,KAAKN,eAAe+F,eAAe5C,OAAO2C,KAAKjD,YAAY1C;EAAA;EAAA,MAUzF6F,aAAa5D,WAAW6D,eAAe9F,SAAS;IACpD,OAAO,KAAKJ,UAAUO,MAAM,KAAKN,eAAekG,kBAAkB9D,WAAW6D,gBAAgB9F;EAAA;EAG/F2C,mBAAmBqD,mBAAmB;IACpC,IAAItD;IACJ,IAAIuD,OAAOC,OAAO1G,WAAWwE,SAASgC,oBAAoB;MACxDtD,YAAY;QAAErB,MAAM2E;QAAmBG,WAAW;MAAA;IAAA,OAC7C;MACLzD,YAAYsD;IAAA;IAGd,OAAO,KAAKpG,UAAU+C,mBAAmBD;EAAA;EAW3C0D,gBAAgBC,aAAY1C,OAAO;IACjC,OAAO,KAAK9D,eAAeuG,gBAAgBC,aAAY1C;EAAA;EAUzD2C,iBAAiBC,aAAa;IAC5B,OAAO,KAAK1G,eAAeyG,iBAAiBC;EAAA;EAAA,MAWxCC,aAAavE,WAAW6D,eAAeE,mBAAmBhG,SAAS;IACvEA,UAAUA,WAAW;IAErB,MAAMG,QAAQ,KAAKN,eAAekD,gBAAgB;MAAA,CAC/C+C,gBAAgB,KAAKnD,mBAAmBqD;IAAA,GACxC;MACD/C,SAAS;MACTD,OAAOf;IAAA;IAET,MAAMhC,MAAM,KAAKJ,eAAe4G,kBAAkBxE,WAAW9B;IAE7D,OAAO,KAAKP,UAAUO,MAAMF,KAAKD;EAAA;EAAA,MAW7B0G,qBAAqBzE,WAAW0E,YAAY3G,SAAS;IACzD,MAAM4G,cAAc,MAAM,KAAK5B,cAAc/C,WAAWjC;IACxD,IAAI4G,YAAYD,aAAa;MAC3B,OAAOC;IAAA;IAET,MAAM,IAAItB,MAAM,SAASrD,qCAAqC0E;EAAA;EAAA,MAa1DE,aAAa5E,WAAW6E,gBAAgBC,eAAe/G,SAAS;IACpEA,UAAUA,WAAW;IACrB,MAAMoF,OAAQ,OAAM,KAAKsB,qBAAqBzE,WAAW6E,gBAAgB9G,UAAU8G;IAEnF,MAAME,WAAW;IAEjBA,SAASD,iBAAiB;MACxBrE,WAAWqE;MACX1F,MAAM+D,KAAK/D;MACX8E,WAAWf,KAAKe;MAChBc,cAAc7B,KAAK6B;IAAA;IAIrB,IAAI7B,KAAK6B,iBAAiB,QAAQ,CAAC7B,KAAKe,WAAW;MACjD,OAAOa,SAASD,eAAeE;IAAA;IAGjC,MAAMhH,MAAM,KAAKJ,eAAeqH,kBAC9BjF,WACA6E,gBACA,KAAKjH,eAAekD,gBAAgBiE;IAEtC,OAAO,MAAM,KAAKpH,UAAUO,MAAMF,KAAKD;EAAA;EAAA,MAqBnCmH,SAASlF,WAAWC,YAAYlC,SAASoH,cAAc;IAE3D,IAAI,CAACC,MAAMC,QAAQpF,aAAa;MAC9BkF,eAAepH;MACfA,UAAUkC;MACVA,aAAalC,QAAQuH;IAAA;IAGvB,IAAI,CAACH,cAAc;MAEjBA,eAAenF;IAAA;IAGjBjC,UAAUT,MAAMiI,UAAUxH;IAC1BA,QAAQuH,SAASrF;IACjB,MAAMjC,MAAM,KAAKJ,eAAe4H,cAAcxF,WAAWjC,SAASoH;IAClE,OAAO,MAAM,KAAKxH,UAAUO,MAAMF,KAAKkB,iCAAKnB,UAAL;MAAc0H,oBAAoB;IAAA;EAAA;EAAA,MAYrEC,UAAU1F,WAAWjC,SAAS;IAClC,MAAMC,MAAM,KAAKJ,eAAe+H,iBAAiB3F,WAAWjC;IAC5D,OAAO,MAAM,KAAKJ,UAAUO,MAAMF,KAAKkB,iCAAKnB,UAAL;MAAcqB,MAAM3B,WAAWmI;IAAA;EAAA;EAAA,MAYlEzD,wBAAwBN,YAAY9D,SAAS;IACjD,IAAI8D,WAAWN,WAAW,GAAG;MAC3B,OAAO;IAAA;IAGTxD,UAAUmB,iCAAKnB,UAAL;MAAcqB,MAAM3B,WAAWoI;IAAA;IAEzC,MAAMC,UAAU,MAAMhH,QAAQC,IAAI8C,WAAW7C,IAAIgB,aAC/C,KAAKrC,UAAUO,MAAM,KAAKN,eAAemI,oBAAoB/F,WAAW,KAAKrC,UAAUmF,OAAOhF,WAAWC;IAE3G,MAAMiI,SAAS;IAEfnE,WAAWoE,QAAQ,CAACjG,WAAWkG,MAAM;MACnC,IAAI9I,EAAEiF,SAASrC,YAAY;QACzBA,YAAY,GAAGA,UAAU1B,UAAU0B,UAAUA;MAAA;MAG/CgG,OAAOhG,aAAaoF,MAAMC,QAAQS,QAAQI,MACtCJ,QAAQI,GAAGlH,IAAImH,KAAKA,EAAEC,mBACtB,CAACN,QAAQI,MAAMJ,QAAQI,GAAGE;MAE9BJ,OAAOhG,aAAagG,OAAOhG,WAAWqG,OAAOjJ,EAAEkJ;IAAA;IAGjD,OAAON;EAAA;EAAA,MAcHO,gCAAgCvG,WAAWjC,SAAS;IACxD,MAAMyI,eAAetH,iCAChBnB,UADgB;MAEnBqB,MAAM3B,WAAWoI;IAAA;IAEnB,MAAM3H,QAAQ,KAAKN,eAAemI,oBAAoB/F,WAAW,KAAKrC,UAAUmF,OAAOhF;IACvF,OAAO,KAAKH,UAAUO,MAAMA,OAAOsI;EAAA;EAAA,MAa/BC,YAAYzG,WAAW0G,uBAAuB3I,SAAS;IAC3DA,UAAUA,WAAW;IACrB,MAAMC,MAAM,KAAKJ,eAAe+I,iBAAiB3G,WAAW0G,uBAAuB3I;IACnF,OAAO,MAAM,KAAKJ,UAAUO,MAAMF,KAAKD;EAAA;EAAA,MAoFnC6I,cAAc5G,WAAWjC,SAAS;IACtC,IAAI,CAACA,QAAQuH,QAAQ;MACnB,MAAM,IAAIjC,MAAM;IAAA;IAGlB,IAAI,CAACtF,QAAQqB,MAAM;MACjB,MAAM,IAAIiE,MAAM;IAAA;IAGlBtF,UAAUT,MAAMiI,UAAUxH;IAE1B,MAAMC,MAAM,KAAKJ,eAAeiJ,mBAAmB7G,WAAWjC;IAC9D,OAAO,MAAM,KAAKJ,UAAUO,MAAMF,KAAKD;EAAA;EAAA,MAGnC+I,eAAe9G,WAAW+G,gBAAgBhJ,SAAS;IACvD,MAAMC,MAAM,KAAKJ,eAAeoJ,qBAAqBhH,WAAW+G;IAChE,OAAO,MAAM,KAAKpJ,UAAUO,MAAMF,KAAKkB,iCAAKnB,UAAL;MAAcqB,MAAM3B,WAAWwJ;IAAA;EAAA;EAAA,MAUlEC,iBAAiBlH,WAAW+G,gBAAgBhJ,SAAS;IACzD,OAAO,KAAKJ,UAAUO,MAAM,KAAKN,eAAeuJ,sBAAsBnH,WAAW+G,iBAAiBhJ;EAAA;EAAA,MAG9FqJ,OAAOC,UAAUrH,WAAWiE,QAAQlG,SAAS;IACjDA,UAAUT,MAAMiI,UAAUxH;IAC1BA,QAAQuJ,aAAaD,YAAYA,SAAS3J,YAAYK,QAAQuJ;IAC9D,MAAMtJ,MAAM,KAAKJ,eAAe2J,YAAYvH,WAAWiE,QAAQoD,YAAYA,SAAS3J,YAAY8J,eAAezJ;IAE/GA,QAAQqB,OAAO3B,WAAWgK;IAC1B1J,QAAQsJ,WAAWA;IAEnB,MAAMvB,UAAU,MAAM,KAAKnI,UAAUO,MAAMF,KAAKD;IAChD,IAAIsJ,UAAUvB,QAAQ,GAAG4B,cAAc;IAEvC,OAAO5B;EAAA;EAAA,MAcH6B,OAAO3H,WAAW4H,cAAcC,cAAcC,OAAO/J,SAAS;IAClEA,UAAUoC,mBAAKpC;IAEf,MAAMmC,QAAQnC,QAAQmC;IAEtBnC,QAAQqB,OAAO3B,WAAWsK;IAC1BhK,QAAQiK,oBAAoBhE,OAAOiE,KAAKJ;IACxC9J,QAAQmK,aAAanK,QAAQoK,kBAAkB;IAE/C,IAAIpK,QAAQmK,WAAW3G,WAAW,GAAG;MACnC,MAAM6G,cAAcpE,OAAOC,OAAO/D,MAAMkI,aAAapJ,IAAIqJ,QAAQA,KAAKC;MACtE,MAAMlI,aAAa4D,OAAOC,OAAO/D,MAAME,YAAYiG,OAAOkC,KAAKA,EAAEjD,OAAO/D,SAAS,GAAGvC,IAAIuJ,KAAKA,EAAEjD;MAC/F,MAAMkD,YAAYxE,OAAOC,OAAO/D,MAAMuI,UAAUpC,OAAOkC,KAAKA,EAAEG,UAAUH,EAAEjD,OAAO/D,SAAS,GAAGvC,IAAIuJ,KAAKA,EAAEjD;MAGxG,WAAWgD,SAASvK,QAAQiK,mBAAmB;QAC7C,MAAM1H,YAAYF,WAAWuI,KAAKrD,UAAUA,OAAOvD,SAASuG;QAC5D,IAAIhI,WAAW;UACbvC,QAAQmK,aAAa5H;UACrB;QAAA;QAGF,MAAMsI,WAAWJ,UAAUG,KAAKrD,UAAUA,OAAOvD,SAASuG;QAC1D,IAAIM,UAAU;UACZ7K,QAAQmK,aAAaU;UACrB;QAAA;MAAA;MAKJ,IACE7K,QAAQmK,WAAW3G,WAAW,KAC3BnE,EAAEyL,aAAa9K,QAAQiK,mBAAmBI,aAAa7G,QAC1D;QACAxD,QAAQmK,aAAaE;MAAA;MAGvBrK,QAAQmK,aAAa9K,EAAE0L,KAAK/K,QAAQmK;IAAA;IAGtC,MAAMlK,MAAM,KAAKJ,eAAe2J,YAAYvH,WAAW4H,cAAc1H,MAAMsH,eAAezJ;IAC1F,OAAO,MAAM,KAAKJ,UAAUO,MAAMF,KAAKD;EAAA;EAAA,MAwBnCgL,WAAW/I,WAAWgJ,SAASjL,SAASkC,YAAY;IACxDlC,UAAUoC,mBAAKpC;IACfA,QAAQqB,OAAO3B,WAAWgK;IAE1B,MAAM3B,UAAU,MAAM,KAAKnI,UAAUO,MACnC,KAAKN,eAAeqL,gBAAgBjJ,WAAWgJ,SAASjL,SAASkC,aACjElC;IAGF,OAAO+H,QAAQ;EAAA;EAAA,MAGXoD,OAAO7B,UAAUrH,WAAWiE,QAAQG,aAAYrG,SAAS;IAC7DA,UAAUoC,mBAAKpC;IACfA,QAAQuJ,aAAaD,YAAYA,SAAS3J,YAAYK,QAAQuJ;IAE9D,MAAMtJ,MAAM,KAAKJ,eAAeuL,YAAYnJ,WAAWiE,QAAQG,aAAYrG,SAASsJ,SAAS3J,YAAY8J;IAEzGzJ,QAAQqB,OAAO3B,WAAW2L;IAE1BrL,QAAQsJ,WAAWA;IACnB,OAAO,MAAM,KAAK1J,UAAUO,MAAMF,KAAKD;EAAA;EAAA,MAsBnCsL,WAAWrJ,WAAWiE,QAAQG,aAAYrG,SAASkC,YAAY;IACnElC,UAAUT,MAAMiI,UAAUxH;IAC1B,IAAI,OAAOqG,gBAAe,UAAUA,cAAa9G,MAAMiI,UAAUnB;IAEjE,MAAMpG,MAAM,KAAKJ,eAAeuL,YAAYnJ,WAAWiE,QAAQG,aAAYrG,SAASkC;IACpF,MAAMc,QAAQ3D,EAAEiF,SAASrC,aAAaA,YAAY;MAAEA;IAAA;IACpD,MAAME,QAAQnC,QAAQmC,QAAQnC,QAAQmC,QAAQ9C,EAAEuL,KAAK,KAAKhL,UAAU2L,aAAaC,QAAQ;MAAEvJ,WAAWe,MAAMf;IAAA;IAE5GjC,QAAQqB,OAAO3B,WAAW+L;IAC1BzL,QAAQmC,QAAQA;IAChB,OAAO,MAAM,KAAKvC,UAAUO,MAAMF,KAAKD;EAAA;EAAA,MAGnC0L,OAAOpC,UAAUrH,WAAWoE,aAAYrG,SAAS;IACrD,MAAM2L,WAAW;IACjB,MAAM1L,MAAM,KAAKJ,eAAe+L,YAAY3J,WAAWoE,aAAY,IAAIiD,SAAS3J;IAEhFK,UAAUoC,mBAAKpC;IAGf,IAAI,CAAC,CAACsJ,SAAS3J,eAAe,CAAC,CAAC2J,SAAS3J,YAAYkM,cAAc;MACjE,MAAM3B,OAAOjE,OAAOiE,KAAKZ,SAAS3J,YAAYkM;MAC9C,MAAMrI,SAAS0G,KAAK1G;MACpB,IAAIsI;MAEJ,SAAS3D,IAAI,GAAGA,IAAI3E,QAAQ2E,KAAK;QAC/B2D,cAAcxC,SAAS3J,YAAYkM,aAAa3B,KAAK/B;QACrD,IAAI2D,YAAY9L,WAAW8L,YAAY9L,QAAQ+L,YAC7CD,YAAY9L,QAAQ+L,SAASC,kBAAkB,aAC/CF,YAAY9L,QAAQiM,aAAa,MAAM;UACvCN,SAASO,KAAKJ,YAAYK,UAAUC;QAAA;MAAA;IAAA;IAK1C,WAAW1I,WAAWiI,UAAU;MAC9B,IAAIU,YAAY,MAAM/C,SAAS5F,SAAS1D;MAExC,IAAI,CAACqM,WAAW;MAChB,IAAI,CAAChF,MAAMC,QAAQ+E,YAAYA,YAAY,CAACA;MAC5C,WAAWC,aAAaD,WAAW,MAAMC,UAAUC,QAAQvM;IAAA;IAE7DA,QAAQsJ,WAAWA;IACnB,OAAO,MAAM,KAAK1J,UAAUO,MAAMF,KAAKD;EAAA;EAAA,MAgBnCwM,WAAWvK,WAAW8H,OAAO/J,SAASmC,OAAO;IACjDnC,UAAUT,MAAMiI,UAAUxH;IAC1BA,UAAUX,EAAEoN,SAASzM,SAAS;MAAE0M,OAAO;IAAA;IAEvC,IAAI1M,QAAQ2M,aAAa,MAAM;MAC7B,OAAO,KAAK/M,UAAUO,MACpB,KAAKN,eAAe+M,mBAAmB3K,WAAWjC,UAClDA;IAAA;IAIJ,IAAI,OAAO6M,eAAe,UAAU9C,QAAQxK,MAAMiI,UAAUuC;IAE5D,OAAO,MAAM,KAAKnK,UAAUO,MAC1B,KAAKN,eAAe+L,YAAY3J,WAAW8H,OAAO/J,SAASmC,QAC3DnC;EAAA;EAAA,MAIE8M,OAAO3K,OAAOF,WAAW8K,YAAY;IACzC,MAAM/M,UAAUmB,iCAAK4L,aAAL;MAAiB1L,MAAM3B,WAAW4B;MAAQa;IAAA;IAE1D,OAAO,MAAM,KAAKvC,UAAUO,MAC1B,KAAKN,eAAemN,YAAY/K,WAAWjC,SAASmC,QACpDnC;EAAA;EAAA,MAIEiN,UAAU9K,OAAOF,WAAW8H,OAAOmD,yBAAyBC,4BAA4BnN,SAAS;IACrGA,UAAUT,MAAMiI,UAAUxH;IAE1B,MAAMC,MAAM,KAAKJ,eAAeuN,gBAAgB,KAAKnL,WAAW8H,OAAOmD,yBAAyBC,4BAA4BnN;IAE5HA,QAAQqB,OAAO3B,WAAW2L;IAC1BrL,QAAQmC,QAAQA;IAEhB,OAAO,MAAM,KAAKvC,UAAUO,MAAMF,KAAKD;EAAA;EAAA,MAGnCqN,UAAUlL,OAAOF,WAAW8H,OAAOmD,yBAAyBC,4BAA4BnN,SAAS;IACrGA,UAAUT,MAAMiI,UAAUxH;IAE1B,MAAMC,MAAM,KAAKJ,eAAeuN,gBAAgB,KAAKnL,WAAW8H,OAAOmD,yBAAyBC,4BAA4BnN;IAE5HA,QAAQqB,OAAO3B,WAAW2L;IAC1BrL,QAAQmC,QAAQA;IAEhB,OAAO,MAAM,KAAKvC,UAAUO,MAAMF,KAAKD;EAAA;EAAA,MAGnCsN,UAAUrL,WAAWjC,SAASuN,mBAAmBC,OAAO;IAC5DxN,UAAUT,MAAMiI,UAAUxH;IAC1BA,UAAUX,EAAEoN,SAASzM,SAAS;MAC5BoB,KAAK;MACLqM,OAAO;MACPpM,MAAM3B,WAAW4B;IAAA;IAGnB,MAAMrB,MAAM,KAAKJ,eAAemN,YAAY/K,WAAWjC,SAASwN;IAEhE,IAAID,sBAAsB,QAAW;MACnC,MAAM,IAAIjI,MAAM;IAAA;IAGlB,MAAMF,OAAO,MAAM,KAAKxF,UAAUO,MAAMF,KAAKD;IAC7C,IAAI,CAACA,QAAQyN,OAAO;MAClB,OAAOrI;IAAA;IAGT,MAAM6C,SAAS7C,OAAOA,KAAKmI,qBAAqB;IAEhD,IAAI,CAACvN,WAAW,CAACA,QAAQ0N,UAAU;MACjC,OAAOzF;IAAA;IAGT,MAAMyF,WAAW1N,QAAQ0N;IAEzB,IAAIA,oBAAoBlO,UAAUmO,WAAWD,oBAAoBlO,UAAUoO,OAAO;MAChF,IAAI3F,WAAW,MAAM;QACnB,OAAO4F,WAAW5F;MAAA;IAAA;IAGtB,IAAIyF,oBAAoBlO,UAAUsO,WAAWJ,oBAAoBlO,UAAUuO,QAAQ;MACjF,IAAI9F,WAAW,MAAM;QACnB,OAAO+F,SAAS/F,QAAQ;MAAA;IAAA;IAG5B,IAAIyF,oBAAoBlO,UAAUyO,MAAM;MACtC,IAAIhG,WAAW,QAAQ,EAAEA,kBAAkBiG,OAAO;QAChD,OAAO,IAAIA,KAAKjG;MAAA;IAAA;IAGpB,OAAOA;EAAA;EAAA,MAGHkG,cACJlM,WACAmM,aACAC,YACAC,aACAC,cACAC,gBACAC,cACAzO,SACA;IACA,MAAMC,MAAM,KAAKJ,eAAesO,cAAclM,WAAWmM,aAAaC,YAAYC,aAAaC,cAAcC,gBAAgBC;IAC7HzO,UAAUA,WAAW;IACrB,IAAIC,KAAK;MACP,OAAO,MAAM,KAAKL,UAAUO,MAAMF,KAAKD;IAAA;EAAA;EAAA,MAIrC0O,YAAYzM,WAAWmM,aAAapO,SAAS;IACjD,MAAMC,MAAM,KAAKJ,eAAe6O,YAAYzM,WAAWmM;IACvDpO,UAAUA,WAAW;IAErB,IAAIC,KAAK;MACP,OAAO,MAAM,KAAKL,UAAUO,MAAMF,KAAKD;IAAA;EAAA;EAAA,MAIrC2O,cAAc1M,WAAW2M,gBAAgBC,gBAAgB7O,SAAS;IACtE,MAAMC,MAAM,KAAKJ,eAAe8O,cAAc1M,WAAW2M,gBAAgBC;IACzE7O,UAAUA,WAAW;IAErB,IAAIC,KAAK;MACP,OAAO,MAAM,KAAKL,UAAUO,MAAMF,KAAKD;IAAA;EAAA;EAAA,MAyCrC8O,eAAeP,cAAcQ,QAAQC,YAAYC,UAAUC,MAAMT,cAAczO,SAAS;IAC5F,MAAMC,MAAM,KAAKJ,eAAeiP,eAAeP,cAAcQ,QAAQC,YAAYC,UAAUC,MAAMT,cAAczO;IAC/GA,UAAUA,WAAW;IAErB,IAAIC,KAAK;MACP,OAAO,MAAM,KAAKL,UAAUO,MAAMF,KAAKD;IAAA;EAAA;EAAA,MAsBrCmP,aAAaZ,cAAcQ,QAAQ/O,SAAS;IAChD,MAAMC,MAAM,KAAKJ,eAAesP,aAAaZ,cAAcQ;IAC3D/O,UAAUA,WAAW;IAErB,IAAIC,KAAK;MACP,OAAO,MAAM,KAAKL,UAAUO,MAAMF,KAAKD;IAAA;EAAA;EAAA,MAwBrCoP,eAAeC,iBAAiBN,QAAQO,iBAAiBtP,SAAS;IACtE,MAAMC,MAAM,KAAKJ,eAAeuP,eAAeC,iBAAiBN,QAAQO;IACxEtP,UAAUA,WAAW;IAErB,IAAIC,KAAK;MACP,OAAO,MAAM,KAAKL,UAAUO,MAAMF,KAAKD;IAAA;EAAA;EAS3C4C,cAAc;EAAA,MAIR2M,kBAAkBC,aAAa7N,OAAO3B,SAAS;IACnD,IAAI,CAACwP,eAAe,EAAEA,uBAAuB/P,cAAc;MACzD,MAAM,IAAI6F,MAAM;IAAA;IAGlB,IAAIkK,YAAYC,UAAU,CAAC9N,OAAO;MAEhC;IAAA;IAGF3B,UAAUmB,iCAAKnB,UAAL;MAAcwP,aAAaA,YAAYC,UAAUD;IAAA;IAE3D,MAAMvP,MAAM,KAAKJ,eAAe6P,uBAAuB/N,OAAO;MAC5D8N,QAAQD,YAAYC;IAAA;IAGtB,IAAI,CAACxP,KAAK;IAEV,OAAO,MAAM,KAAKL,UAAUO,MAAMF,KAAKD;EAAA;EAAA,MAGnC2P,iBAAiBH,aAAaxP,SAAS;IAC3C,IAAI,CAACwP,eAAe,EAAEA,uBAAuB/P,cAAc;MACzD,MAAM,IAAI6F,MAAM;IAAA;IAGlBtF,UAAUmB,iCAAKnB,UAAL;MAAcwP,aAAaA,YAAYC,UAAUD;IAAA;IAC3DxP,QAAQwP,YAAYI,OAAOJ,YAAYC,SAASD,YAAYI,OAAO;IACnE,MAAM3P,MAAM,KAAKJ,eAAegQ,sBAAsBL;IAEtD,OAAO,MAAM,KAAK5P,UAAUO,MAAMF,KAAKD;EAAA;EAAA,MAGnC8P,iBAAiBN,aAAaxP,SAAS;IAC3CA,UAAUmB,iCAAKnB,UAAL;MAAcwP,aAAaA,YAAYC,UAAUD;IAAA;IAE3D,MAAMvP,MAAM,KAAKJ,eAAekQ,sBAAsB/P;IAEtD,IAAIC,KAAK;MACP,OAAO,MAAM,KAAKL,UAAUO,MAAMF,KAAKD;IAAA;EAAA;EAAA,MAIrCgQ,kBAAkBR,aAAaxP,SAAS;IAC5C,IAAI,CAACwP,eAAe,EAAEA,uBAAuB/P,cAAc;MACzD,MAAM,IAAI6F,MAAM;IAAA;IAElB,IAAIkK,YAAYC,QAAQ;MAEtB;IAAA;IAGFzP,UAAUmB,iCACLnB,UADK;MAERwP,aAAaA,YAAYC,UAAUD;MACnC9H,oBAAoB;MACpBuI,sBAAsB;IAAA;IAGxB,MAAMhQ,MAAM,KAAKJ,eAAeqQ,uBAAuBV;IACvD,MAAMW,UAAU,KAAKvQ,UAAUO,MAAMF,KAAKD;IAE1CwP,YAAYY,WAAW;IAEvB,OAAO,MAAMD;EAAA;EAAA,MAGTE,oBAAoBb,aAAaxP,SAAS;IAC9C,IAAI,CAACwP,eAAe,EAAEA,uBAAuB/P,cAAc;MACzD,MAAM,IAAI6F,MAAM;IAAA;IAGlBtF,UAAUmB,iCACLnB,UADK;MAERwP,aAAaA,YAAYC,UAAUD;MACnC9H,oBAAoB;MACpBuI,sBAAsB;IAAA;IAExBjQ,QAAQwP,YAAYI,OAAOJ,YAAYC,SAASD,YAAYI,OAAO;IACnE,MAAM3P,MAAM,KAAKJ,eAAeyQ,yBAAyBd;IACzD,MAAMW,UAAU,KAAKvQ,UAAUO,MAAMF,KAAKD;IAE1CwP,YAAYY,WAAW;IAEvB,OAAO,MAAMD;EAAA;AAAA;AAIjBI,QAAQC,iBAAiBA","names":["_","require","Utils","DataTypes","Transaction","QueryTypes","constructor","sequelize","queryGenerator","createDatabase","database","options","sql","createDatabaseQuery","query","dropDatabase","dropDatabaseQuery","createSchema","schema","dropSchema","dropAllSchemas","_dialect","supports","schemas","drop","showAllSchemas","Promise","all","map","schemaName","__spreadProps","raw","type","SELECT","showSchemasSql","showSchemasQuery","schemaNames","flatten","value","schema_name","databaseVersion","versionQuery","VERSION","createTable","tableName","attributes","model","__spreadValues","uniqueKeys","forOwn","uniqueKey","customIndex","mapValues","attribute","normalizeAttribute","ensureEnums","_schema","addSchema","attributesToSQL","table","context","withoutForeignKeyConstraints","createTableQuery","tableExists","tableExistsQuery","out","SHOWTABLES","length","dropTable","cascade","force","dropTableQuery","_dropAllTables","tableNames","skip","includes","dropAllTables","showAllTables","foreignKeys","getForeignKeysForTables","normalizedTableName","isObject","foreignKey","dropForeignKeyQuery","renameTable","before","after","renameTableQuery","showTablesSql","showTablesQuery","config","describeTable","schemaDelimiter","describeTableQuery","DESCRIBE","data","isEmpty","Error","e","original","code","addColumn","key","addColumnQuery","removeColumn","attributeName","removeColumnQuery","dataTypeOrOptions","Object","values","allowNull","quoteIdentifier","identifier2","quoteIdentifiers","identifiers","changeColumn","changeColumnQuery","assertTableHasColumn","columnName","description","renameColumn","attrNameBefore","attrNameAfter","_options","defaultValue","renameColumnQuery","addIndex","rawTablename","Array","isArray","fields","cloneDeep","addIndexQuery","supportsSearchPath","showIndex","showIndexesQuery","SHOWINDEXES","FOREIGNKEYS","results","getForeignKeysQuery","result","forEach","i","r","constraint_name","filter","identity","getForeignKeyReferencesForTable","queryOptions","removeIndex","indexNameOrAttributes","removeIndexQuery","addConstraint","addConstraintQuery","showConstraint","constraintName","showConstraintsQuery","SHOWCONSTRAINTS","removeConstraint","removeConstraintQuery","insert","instance","hasTrigger","insertQuery","rawAttributes","INSERT","isNewRecord","upsert","insertValues","updateValues","where","UPSERT","updateOnDuplicate","keys","upsertKeys","conflictFields","primaryKeys","item","field","c","indexKeys","_indexes","unique","find","indexKey","intersection","uniq","bulkInsert","records","bulkInsertQuery","update","updateQuery","UPDATE","bulkUpdate","modelManager","models","BULKUPDATE","delete","cascades","deleteQuery","associations","association","onDelete","toLowerCase","useHooks","push","accessors","get","instances","_instance","destroy","bulkDelete","defaults","limit","truncate","truncateTableQuery","identifier","select","optionsArg","selectQuery","increment","incrementAmountsByField","extraAttributesToBeUpdated","arithmeticQuery","decrement","rawSelect","attributeSelector","Model","plain","dataType","DECIMAL","FLOAT","parseFloat","INTEGER","BIGINT","parseInt","DATE","Date","createTrigger","triggerName","timingType","fireOnArray","functionName","functionParams","optionsArray","dropTrigger","renameTrigger","oldTriggerName","newTriggerName","createFunction","params","returnType","language","body","dropFunction","renameFunction","oldFunctionName","newFunctionName","setIsolationLevel","transaction","parent","setIsolationLevelQuery","startTransaction","name","startTransactionQuery","deferConstraints","deferConstraintsQuery","commitTransaction","completesTransaction","commitTransactionQuery","promise","finished","rollbackTransaction","rollbackTransactionQuery","exports","QueryInterface"],"sources":["C:\\Users\\rizla\\projects\\react\\NSBEHack-main\\nsbeapp\\node_modules\\sequelize\\src\\dialects\\abstract\\query-interface.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\n\nconst Utils = require('../../utils');\nconst DataTypes = require('../../data-types');\nconst Transaction = require('../../transaction');\nconst QueryTypes = require('../../query-types');\n\n/**\n * The interface that Sequelize uses to talk to all databases\n */\nclass QueryInterface {\n  constructor(sequelize, queryGenerator) {\n    this.sequelize = sequelize;\n    this.queryGenerator = queryGenerator;\n  }\n\n  /**\n   * Create a database\n   *\n   * @param {string} database  Database name to create\n   * @param {object} [options] Query options\n   * @param {string} [options.charset] Database default character set, MYSQL only\n   * @param {string} [options.collate] Database default collation\n   * @param {string} [options.encoding] Database default character set, PostgreSQL only\n   * @param {string} [options.ctype] Database character classification, PostgreSQL only\n   * @param {string} [options.template] The name of the template from which to create the new database, PostgreSQL only\n   *\n   * @returns {Promise}\n   */\n  async createDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createDatabaseQuery(database, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Drop a database\n   *\n   * @param {string} database  Database name to drop\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async dropDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropDatabaseQuery(database);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Create a schema\n   *\n   * @param {string} schema    Schema name to create\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async createSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Drop a schema\n   *\n   * @param {string} schema    Schema name to drop\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async dropSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Drop all schemas\n   *\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async dropAllSchemas(options) {\n    options = options || {};\n\n    if (!this.queryGenerator._dialect.supports.schemas) {\n      return this.sequelize.drop(options);\n    }\n    const schemas = await this.showAllSchemas(options);\n    return Promise.all(schemas.map(schemaName => this.dropSchema(schemaName, options)));\n  }\n\n  /**\n   * Show all schemas\n   *\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise<Array>}\n   */\n  async showAllSchemas(options) {\n    options = {\n      ...options,\n      raw: true,\n      type: this.sequelize.QueryTypes.SELECT\n    };\n\n    const showSchemasSql = this.queryGenerator.showSchemasQuery(options);\n\n    const schemaNames = await this.sequelize.query(showSchemasSql, options);\n\n    return _.flatten(schemaNames.map(value => value.schema_name ? value.schema_name : value));\n  }\n\n  /**\n   * Return database version\n   *\n   * @param {object}    [options]      Query options\n   * @param {QueryType} [options.type] Query type\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async databaseVersion(options) {\n    return await this.sequelize.query(\n      this.queryGenerator.versionQuery(),\n      { ...options, type: QueryTypes.VERSION }\n    );\n  }\n\n  /**\n   * Create a table with given set of attributes\n   *\n   * ```js\n   * queryInterface.createTable(\n   *   'nameOfTheNewTable',\n   *   {\n   *     id: {\n   *       type: Sequelize.INTEGER,\n   *       primaryKey: true,\n   *       autoIncrement: true\n   *     },\n   *     createdAt: {\n   *       type: Sequelize.DATE\n   *     },\n   *     updatedAt: {\n   *       type: Sequelize.DATE\n   *     },\n   *     attr1: Sequelize.STRING,\n   *     attr2: Sequelize.INTEGER,\n   *     attr3: {\n   *       type: Sequelize.BOOLEAN,\n   *       defaultValue: false,\n   *       allowNull: false\n   *     },\n   *     //foreign key usage\n   *     attr4: {\n   *       type: Sequelize.INTEGER,\n   *       references: {\n   *         model: 'another_table_name',\n   *         key: 'id'\n   *       },\n   *       onUpdate: 'cascade',\n   *       onDelete: 'cascade'\n   *     }\n   *   },\n   *   {\n   *     engine: 'MYISAM',    // default: 'InnoDB'\n   *     charset: 'latin1',   // default: null\n   *     schema: 'public',    // default: public, PostgreSQL only.\n   *     comment: 'my table', // comment for table\n   *     collate: 'latin1_danish_ci' // collation, MYSQL only\n   *   }\n   * )\n   * ```\n   *\n   * @param {string} tableName  Name of table to create\n   * @param {object} attributes Object representing a list of table attributes to create\n   * @param {object} [options] create table and query options\n   * @param {Model}  [model] model class\n   *\n   * @returns {Promise}\n   */\n  async createTable(tableName, attributes, options, model) {\n    let sql = '';\n\n    options = { ...options };\n\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, uniqueKey => {\n        if (uniqueKey.customIndex === undefined) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n\n    attributes = _.mapValues(\n      attributes,\n      attribute => this.sequelize.normalizeAttribute(attribute)\n    );\n\n    // Postgres requires special SQL commands for ENUM/ENUM[]\n    await this.ensureEnums(tableName, attributes, options, model);\n\n    if (\n      !tableName.schema &&\n      (options.schema || !!model && model._schema)\n    ) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n\n    attributes = this.queryGenerator.attributesToSQL(attributes, {\n      table: tableName,\n      context: 'createTable',\n      withoutForeignKeyConstraints: options.withoutForeignKeyConstraints\n    });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Returns a promise that will resolve to true if the table exists in the database, false otherwise.\n   *\n   * @param {TableName} tableName - The name of the table\n   * @param {QueryOptions} options - Query options\n   * @returns {Promise<boolean>}\n   */\n  async tableExists(tableName, options) {\n    const sql = this.queryGenerator.tableExistsQuery(tableName);\n\n    const out = await this.sequelize.query(sql, {\n      ...options,\n      type: QueryTypes.SHOWTABLES\n    });\n\n    return out.length === 1;\n  }\n\n  /**\n   * Drop a table from database\n   *\n   * @param {string} tableName Table name to drop\n   * @param {object} options   Query options\n   *\n   * @returns {Promise}\n   */\n  async dropTable(tableName, options) {\n    // if we're forcing we should be cascading unless explicitly stated otherwise\n    options = { ...options };\n    options.cascade = options.cascade || options.force || false;\n\n    const sql = this.queryGenerator.dropTableQuery(tableName, options);\n\n    await this.sequelize.query(sql, options);\n  }\n\n  async _dropAllTables(tableNames, skip, options) {\n    for (const tableName of tableNames) {\n      // if tableName is not in the Array of tables names then don't drop it\n      if (!skip.includes(tableName.tableName || tableName)) {\n        await this.dropTable(tableName, { ...options, cascade: true } );\n      }\n    }\n  }\n\n  /**\n   * Drop all tables from database\n   *\n   * @param {object} [options] query options\n   * @param {Array}  [options.skip] List of table to skip\n   *\n   * @returns {Promise}\n   */\n  async dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n\n    const tableNames = await this.showAllTables(options);\n    const foreignKeys = await this.getForeignKeysForTables(tableNames, options);\n\n    for (const tableName of tableNames) {\n      let normalizedTableName = tableName;\n      if (_.isObject(tableName)) {\n        normalizedTableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n\n      for (const foreignKey of foreignKeys[normalizedTableName]) {\n        await this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, foreignKey));\n      }\n    }\n    await this._dropAllTables(tableNames, skip, options);\n  }\n\n  /**\n   * Rename a table\n   *\n   * @param {string} before    Current name of table\n   * @param {string} after     New name from table\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async renameTable(before, after, options) {\n    options = options || {};\n    const sql = this.queryGenerator.renameTableQuery(before, after);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Get all tables in current database\n   *\n   * @param {object}    [options] Query options\n   * @param {boolean}   [options.raw=true] Run query in raw mode\n   * @param {QueryType} [options.type=QueryType.SHOWTABLE] query type\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async showAllTables(options) {\n    options = {\n      ...options,\n      raw: true,\n      type: QueryTypes.SHOWTABLES\n    };\n\n    const showTablesSql = this.queryGenerator.showTablesQuery(this.sequelize.config.database);\n    const tableNames = await this.sequelize.query(showTablesSql, options);\n    return _.flatten(tableNames);\n  }\n\n  /**\n   * Describe a table structure\n   *\n   * This method returns an array of hashes containing information about all attributes in the table.\n   *\n   * ```js\n   * {\n   *    name: {\n   *      type:         'VARCHAR(255)', // this will be 'CHARACTER VARYING' for pg!\n   *      allowNull:    true,\n   *      defaultValue: null\n   *    },\n   *    isBetaMember: {\n   *      type:         'TINYINT(1)', // this will be 'BOOLEAN' for pg!\n   *      allowNull:    false,\n   *      defaultValue: false\n   *    }\n   * }\n   * ```\n   *\n   * @param {string} tableName table name\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise<object>}\n   */\n  async describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n\n    if (typeof options === 'string') {\n      schema = options;\n    } else if (typeof options === 'object' && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n\n    if (typeof tableName === 'object' && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n\n    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = { ...options, type: QueryTypes.DESCRIBE };\n\n    try {\n      const data = await this.sequelize.query(sql, options);\n      /*\n       * If no data is returned from the query, then the table name may be wrong.\n       * Query generators that use information_schema for retrieving table info will just return an empty result set,\n       * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).\n       */\n      if (_.isEmpty(data)) {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n\n      return data;\n    } catch (e) {\n      if (e.original && e.original.code === 'ER_NO_SUCH_TABLE') {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n\n      throw e;\n    }\n  }\n\n  /**\n   * Add a new column to a table\n   *\n   * ```js\n   * queryInterface.addColumn('tableA', 'columnC', Sequelize.STRING, {\n   *    after: 'columnB' // after option is only supported by MySQL\n   * });\n   * ```\n   *\n   * @param {string} table     Table to add column to\n   * @param {string} key       Column name\n   * @param {object} attribute Attribute definition\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async addColumn(table, key, attribute, options) {\n    if (!table || !key || !attribute) {\n      throw new Error('addColumn takes at least 3 arguments (table, attribute name, attribute definition)');\n    }\n\n    options = options || {};\n    attribute = this.sequelize.normalizeAttribute(attribute);\n    return await this.sequelize.query(this.queryGenerator.addColumnQuery(table, key, attribute), options);\n  }\n\n  /**\n   * Remove a column from a table\n   *\n   * @param {string} tableName      Table to remove column from\n   * @param {string} attributeName  Column name to remove\n   * @param {object} [options]      Query options\n   */\n  async removeColumn(tableName, attributeName, options) {\n    return this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, attributeName), options);\n  }\n\n  normalizeAttribute(dataTypeOrOptions) {\n    let attribute;\n    if (Object.values(DataTypes).includes(dataTypeOrOptions)) {\n      attribute = { type: dataTypeOrOptions, allowNull: true };\n    } else {\n      attribute = dataTypeOrOptions;\n    }\n\n    return this.sequelize.normalizeAttribute(attribute);\n  }\n\n  /**\n   * Split a list of identifiers by \".\" and quote each part\n   *\n   * @param {string} identifier\n   * @param {boolean} force\n   *\n   * @returns {string}\n   */\n  quoteIdentifier(identifier, force) {\n    return this.queryGenerator.quoteIdentifier(identifier, force);\n  }\n\n  /**\n   * Split a list of identifiers by \".\" and quote each part.\n   *\n   * @param {string} identifiers \n   * \n   * @returns {string}\n   */\n  quoteIdentifiers(identifiers) {\n    return this.queryGenerator.quoteIdentifiers(identifiers);\n  }\n\n  /**\n   * Change a column definition\n   *\n   * @param {string} tableName          Table name to change from\n   * @param {string} attributeName      Column name\n   * @param {object} dataTypeOrOptions  Attribute definition for new column\n   * @param {object} [options]          Query options\n   */\n  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    options = options || {};\n\n    const query = this.queryGenerator.attributesToSQL({\n      [attributeName]: this.normalizeAttribute(dataTypeOrOptions)\n    }, {\n      context: 'changeColumn',\n      table: tableName\n    });\n    const sql = this.queryGenerator.changeColumnQuery(tableName, query);\n\n    return this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Rejects if the table doesn't have the specified column, otherwise returns the column description.\n   *\n   * @param {string} tableName\n   * @param {string} columnName\n   * @param {object} options\n   * @private\n   */\n  async assertTableHasColumn(tableName, columnName, options) {\n    const description = await this.describeTable(tableName, options);\n    if (description[columnName]) {\n      return description;\n    }\n    throw new Error(`Table ${tableName} doesn't have the column ${columnName}`);\n  }\n\n  /**\n   * Rename a column\n   *\n   * @param {string} tableName        Table name whose column to rename\n   * @param {string} attrNameBefore   Current column name\n   * @param {string} attrNameAfter    New column name\n   * @param {object} [options]        Query option\n   *\n   * @returns {Promise}\n   */\n  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    const data = (await this.assertTableHasColumn(tableName, attrNameBefore, options))[attrNameBefore];\n\n    const _options = {};\n\n    _options[attrNameAfter] = {\n      attribute: attrNameAfter,\n      type: data.type,\n      allowNull: data.allowNull,\n      defaultValue: data.defaultValue\n    };\n\n    // fix: a not-null column cannot have null as default value\n    if (data.defaultValue === null && !data.allowNull) {\n      delete _options[attrNameAfter].defaultValue;\n    }\n\n    const sql = this.queryGenerator.renameColumnQuery(\n      tableName,\n      attrNameBefore,\n      this.queryGenerator.attributesToSQL(_options)\n    );\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Add an index to a column\n   *\n   * @param {string|object}  tableName Table name to add index on, can be a object with schema\n   * @param {Array}   [attributes]     Use options.fields instead, List of attributes to add index on\n   * @param {object}  options          indexes options\n   * @param {Array}   options.fields   List of attributes to add index on\n   * @param {boolean} [options.concurrently] Pass CONCURRENT so other operations run while the index is created\n   * @param {boolean} [options.unique] Create a unique index\n   * @param {string}  [options.using]  Useful for GIN indexes\n   * @param {string}  [options.operator] Index operator\n   * @param {string}  [options.type]   Type of index, available options are UNIQUE|FULLTEXT|SPATIAL\n   * @param {string}  [options.name]   Name of the index. Default is <table>_<attr1>_<attr2>\n   * @param {object}  [options.where]  Where condition on index, for partial indexes\n   * @param {string}  [rawTablename]   table name, this is just for backward compatibiity\n   *\n   * @returns {Promise}\n   */\n  async addIndex(tableName, attributes, options, rawTablename) {\n    // Support for passing tableName, attributes, options or tableName, options (with a fields param which is the attributes)\n    if (!Array.isArray(attributes)) {\n      rawTablename = options;\n      options = attributes;\n      attributes = options.fields;\n    }\n\n    if (!rawTablename) {\n      // Map for backwards compat\n      rawTablename = tableName;\n    }\n\n    options = Utils.cloneDeep(options);\n    options.fields = attributes;\n    const sql = this.queryGenerator.addIndexQuery(tableName, options, rawTablename);\n    return await this.sequelize.query(sql, { ...options, supportsSearchPath: false });\n  }\n\n  /**\n   * Show indexes on a table\n   *\n   * @param {string} tableName table name\n   * @param {object} [options]   Query options\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async showIndex(tableName, options) {\n    const sql = this.queryGenerator.showIndexesQuery(tableName, options);\n    return await this.sequelize.query(sql, { ...options, type: QueryTypes.SHOWINDEXES });\n  }\n\n\n  /**\n   * Returns all foreign key constraints of requested tables\n   *\n   * @param {string[]} tableNames table names\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async getForeignKeysForTables(tableNames, options) {\n    if (tableNames.length === 0) {\n      return {};\n    }\n\n    options = { ...options, type: QueryTypes.FOREIGNKEYS };\n\n    const results = await Promise.all(tableNames.map(tableName =>\n      this.sequelize.query(this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database), options)));\n\n    const result = {};\n\n    tableNames.forEach((tableName, i) => {\n      if (_.isObject(tableName)) {\n        tableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n\n      result[tableName] = Array.isArray(results[i])\n        ? results[i].map(r => r.constraint_name)\n        : [results[i] && results[i].constraint_name];\n\n      result[tableName] = result[tableName].filter(_.identity);\n    });\n\n    return result;\n  }\n\n  /**\n   * Get foreign key references details for the table\n   *\n   * Those details contains constraintSchema, constraintName, constraintCatalog\n   * tableCatalog, tableSchema, tableName, columnName,\n   * referencedTableCatalog, referencedTableCatalog, referencedTableSchema, referencedTableName, referencedColumnName.\n   * Remind: constraint informations won't return if it's sqlite.\n   *\n   * @param {string} tableName table name\n   * @param {object} [options]  Query options\n   */\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = {\n      ...options,\n      type: QueryTypes.FOREIGNKEYS\n    };\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database);\n    return this.sequelize.query(query, queryOptions);\n  }\n\n  /**\n   * Remove an already existing index from a table\n   *\n   * @param {string} tableName                    Table name to drop index from\n   * @param {string|string[]} indexNameOrAttributes  Index name or list of attributes that in the index\n   * @param {object} [options]                    Query options\n   * @param {boolean} [options.concurrently]      Pass CONCURRENTLY so other operations run while the index is created\n   *\n   * @returns {Promise}\n   */\n  async removeIndex(tableName, indexNameOrAttributes, options) {\n    options = options || {};\n    const sql = this.queryGenerator.removeIndexQuery(tableName, indexNameOrAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Add a constraint to a table\n   *\n   * Available constraints:\n   * - UNIQUE\n   * - DEFAULT (MSSQL only)\n   * - CHECK (MySQL - Ignored by the database engine )\n   * - FOREIGN KEY\n   * - PRIMARY KEY\n   *\n   * @example <caption>UNIQUE</caption>\n   * queryInterface.addConstraint('Users', {\n   *   fields: ['email'],\n   *   type: 'unique',\n   *   name: 'custom_unique_constraint_name'\n   * });\n   *\n   * @example <caption>CHECK</caption>\n   * queryInterface.addConstraint('Users', {\n   *   fields: ['roles'],\n   *   type: 'check',\n   *   where: {\n   *      roles: ['user', 'admin', 'moderator', 'guest']\n   *   }\n   * });\n   *\n   * @example <caption>Default - MSSQL only</caption>\n   * queryInterface.addConstraint('Users', {\n   *    fields: ['roles'],\n   *    type: 'default',\n   *    defaultValue: 'guest'\n   * });\n   *\n   * @example <caption>Primary Key</caption>\n   * queryInterface.addConstraint('Users', {\n   *    fields: ['username'],\n   *    type: 'primary key',\n   *    name: 'custom_primary_constraint_name'\n   * });\n   *\n   * @example <caption>Foreign Key</caption>\n   * queryInterface.addConstraint('Posts', {\n   *   fields: ['username'],\n   *   type: 'foreign key',\n   *   name: 'custom_fkey_constraint_name',\n   *   references: { //Required field\n   *     table: 'target_table_name',\n   *     field: 'target_column_name'\n   *   },\n   *   onDelete: 'cascade',\n   *   onUpdate: 'cascade'\n   * });\n   *\n   * @example <caption>Composite Foreign Key</caption>\n   * queryInterface.addConstraint('TableName', {\n   *   fields: ['source_column_name', 'other_source_column_name'],\n   *   type: 'foreign key',\n   *   name: 'custom_fkey_constraint_name',\n   *   references: { //Required field\n   *     table: 'target_table_name',\n   *     fields: ['target_column_name', 'other_target_column_name']\n   *   },\n   *   onDelete: 'cascade',\n   *   onUpdate: 'cascade'\n   * });\n   *\n   * @param {string} tableName                   Table name where you want to add a constraint\n   * @param {object} options                     An object to define the constraint name, type etc\n   * @param {string} options.type                Type of constraint. One of the values in available constraints(case insensitive)\n   * @param {Array}  options.fields              Array of column names to apply the constraint over\n   * @param {string} [options.name]              Name of the constraint. If not specified, sequelize automatically creates a named constraint based on constraint type, table & column names\n   * @param {string} [options.defaultValue]      The value for the default constraint\n   * @param {object} [options.where]             Where clause/expression for the CHECK constraint\n   * @param {object} [options.references]        Object specifying target table, column name to create foreign key constraint\n   * @param {string} [options.references.table]  Target table name\n   * @param {string} [options.references.field]  Target column name\n   * @param {string} [options.references.fields] Target column names for a composite primary key. Must match the order of fields in options.fields.\n   * @param {string} [options.deferrable]        Sets the constraint to be deferred or immediately checked. See Sequelize.Deferrable. PostgreSQL Only\n   *\n   * @returns {Promise}\n   */\n  async addConstraint(tableName, options) {\n    if (!options.fields) {\n      throw new Error('Fields must be specified through options.fields');\n    }\n\n    if (!options.type) {\n      throw new Error('Constraint type must be specified through options.type');\n    }\n\n    options = Utils.cloneDeep(options);\n\n    const sql = this.queryGenerator.addConstraintQuery(tableName, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n  async showConstraint(tableName, constraintName, options) {\n    const sql = this.queryGenerator.showConstraintsQuery(tableName, constraintName);\n    return await this.sequelize.query(sql, { ...options, type: QueryTypes.SHOWCONSTRAINTS });\n  }\n\n  /**\n   * Remove a constraint from a table\n   *\n   * @param {string} tableName       Table name to drop constraint from\n   * @param {string} constraintName  Constraint name\n   * @param {object} options         Query options\n   */\n  async removeConstraint(tableName, constraintName, options) {\n    return this.sequelize.query(this.queryGenerator.removeConstraintQuery(tableName, constraintName), options);\n  }\n\n  async insert(instance, tableName, values, options) {\n    options = Utils.cloneDeep(options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.queryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);\n\n    options.type = QueryTypes.INSERT;\n    options.instance = instance;\n\n    const results = await this.sequelize.query(sql, options);\n    if (instance) results[0].isNewRecord = false;\n\n    return results;\n  }\n\n  /**\n   * Upsert\n   *\n   * @param {string} tableName    table to upsert on\n   * @param {object} insertValues values to be inserted, mapped to field name\n   * @param {object} updateValues values to be updated, mapped to field name\n   * @param {object} where        where conditions, which can be used for UPDATE part when INSERT fails\n   * @param {object} options      query options\n   *\n   * @returns {Promise<boolean,?number>} Resolves an array with <created, primaryKey>\n   */\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = { ...options };\n\n    const model = options.model;\n\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = options.conflictFields || [];\n\n    if (options.upsertKeys.length === 0) {\n      const primaryKeys = Object.values(model.primaryKeys).map(item => item.field);\n      const uniqueKeys = Object.values(model.uniqueKeys).filter(c => c.fields.length > 0).map(c => c.fields);\n      const indexKeys = Object.values(model._indexes).filter(c => c.unique && c.fields.length > 0).map(c => c.fields);\n      // For fields in updateValues, try to find a constraint or unique index\n      // that includes given field. Only first matching upsert key is used.\n      for (const field of options.updateOnDuplicate) {\n        const uniqueKey = uniqueKeys.find(fields => fields.includes(field));\n        if (uniqueKey) {\n          options.upsertKeys = uniqueKey;\n          break;\n        }\n\n        const indexKey = indexKeys.find(fields => fields.includes(field));\n        if (indexKey) {\n          options.upsertKeys = indexKey;\n          break;\n        }\n      }\n\n      // Always use PK, if no constraint available OR update data contains PK\n      if (\n        options.upsertKeys.length === 0\n        || _.intersection(options.updateOnDuplicate, primaryKeys).length\n      ) {\n        options.upsertKeys = primaryKeys;\n      }\n\n      options.upsertKeys = _.uniq(options.upsertKeys);\n    }\n\n    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Insert multiple records into a table\n   *\n   * @example\n   * queryInterface.bulkInsert('roles', [{\n   *    label: 'user',\n   *    createdAt: new Date(),\n   *    updatedAt: new Date()\n   *  }, {\n   *    label: 'admin',\n   *    createdAt: new Date(),\n   *    updatedAt: new Date()\n   *  }]);\n   *\n   * @param {string} tableName   Table name to insert record to\n   * @param {Array}  records     List of records to insert\n   * @param {object} options     Various options, please see Model.bulkCreate options\n   * @param {object} attributes  Various attributes mapped by field name\n   *\n   * @returns {Promise}\n   */\n  async bulkInsert(tableName, records, options, attributes) {\n    options = { ...options };\n    options.type = QueryTypes.INSERT;\n\n    const results = await this.sequelize.query(\n      this.queryGenerator.bulkInsertQuery(tableName, records, options, attributes),\n      options\n    );\n\n    return results[0];\n  }\n\n  async update(instance, tableName, values, identifier, options) {\n    options = { ...options };\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier, options, instance.constructor.rawAttributes);\n\n    options.type = QueryTypes.UPDATE;\n\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Update multiple records of a table\n   *\n   * @example\n   * queryInterface.bulkUpdate('roles', {\n   *     label: 'admin',\n   *   }, {\n   *     userType: 3,\n   *   },\n   * );\n   *\n   * @param {string} tableName     Table name to update\n   * @param {object} values        Values to be inserted, mapped to field name\n   * @param {object} identifier    A hash with conditions OR an ID as integer OR a string with conditions\n   * @param {object} [options]     Various options, please see Model.bulkCreate options\n   * @param {object} [attributes]  Attributes on return objects if supported by SQL dialect\n   *\n   * @returns {Promise}\n   */\n  async bulkUpdate(tableName, values, identifier, options, attributes) {\n    options = Utils.cloneDeep(options);\n    if (typeof identifier === 'object') identifier = Utils.cloneDeep(identifier);\n\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier, options, attributes);\n    const table = _.isObject(tableName) ? tableName : { tableName };\n    const model = options.model ? options.model : _.find(this.sequelize.modelManager.models, { tableName: table.tableName });\n\n    options.type = QueryTypes.BULKUPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n\n  async delete(instance, tableName, identifier, options) {\n    const cascades = [];\n    const sql = this.queryGenerator.deleteQuery(tableName, identifier, {}, instance.constructor);\n\n    options = { ...options };\n\n    // Check for a restrict field\n    if (!!instance.constructor && !!instance.constructor.associations) {\n      const keys = Object.keys(instance.constructor.associations);\n      const length = keys.length;\n      let association;\n\n      for (let i = 0; i < length; i++) {\n        association = instance.constructor.associations[keys[i]];\n        if (association.options && association.options.onDelete &&\n          association.options.onDelete.toLowerCase() === 'cascade' &&\n          association.options.useHooks === true) {\n          cascades.push(association.accessors.get);\n        }\n      }\n    }\n\n    for (const cascade of cascades) {\n      let instances = await instance[cascade](options);\n      // Check for hasOne relationship with non-existing associate (\"has zero\")\n      if (!instances) continue;\n      if (!Array.isArray(instances)) instances = [instances];\n      for (const _instance of instances) await _instance.destroy(options);\n    }\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Delete multiple records from a table\n   *\n   * @param {string}  tableName            table name from where to delete records\n   * @param {object}  where                where conditions to find records to delete\n   * @param {object}  [options]            options\n   * @param {boolean} [options.truncate]   Use truncate table command\n   * @param {boolean} [options.cascade=false]         Only used in conjunction with TRUNCATE. Truncates  all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.\n   * @param {boolean} [options.restartIdentity=false] Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table.\n   * @param {Model}   [model]              Model\n   *\n   * @returns {Promise}\n   */\n  async bulkDelete(tableName, where, options, model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, { limit: null });\n\n    if (options.truncate === true) {\n      return this.sequelize.query(\n        this.queryGenerator.truncateTableQuery(tableName, options),\n        options\n      );\n    }\n\n    if (typeof identifier === 'object') where = Utils.cloneDeep(where);\n\n    return await this.sequelize.query(\n      this.queryGenerator.deleteQuery(tableName, where, options, model),\n      options\n    );\n  }\n\n  async select(model, tableName, optionsArg) {\n    const options = { ...optionsArg, type: QueryTypes.SELECT, model };\n\n    return await this.sequelize.query(\n      this.queryGenerator.selectQuery(tableName, options, model),\n      options\n    );\n  }\n\n  async increment(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n\n    const sql = this.queryGenerator.arithmeticQuery('+', tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n\n    return await this.sequelize.query(sql, options);\n  }\n\n  async decrement(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n\n    const sql = this.queryGenerator.arithmeticQuery('-', tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n\n    return await this.sequelize.query(sql, options);\n  }\n\n  async rawSelect(tableName, options, attributeSelector, Model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      raw: true,\n      plain: true,\n      type: QueryTypes.SELECT\n    });\n\n    const sql = this.queryGenerator.selectQuery(tableName, options, Model);\n\n    if (attributeSelector === undefined) {\n      throw new Error('Please pass an attribute selector!');\n    }\n\n    const data = await this.sequelize.query(sql, options);\n    if (!options.plain) {\n      return data;\n    }\n\n    const result = data ? data[attributeSelector] : null;\n\n    if (!options || !options.dataType) {\n      return result;\n    }\n\n    const dataType = options.dataType;\n\n    if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {\n      if (result !== null) {\n        return parseFloat(result);\n      }\n    }\n    if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {\n      if (result !== null) {\n        return parseInt(result, 10);\n      }\n    }\n    if (dataType instanceof DataTypes.DATE) {\n      if (result !== null && !(result instanceof Date)) {\n        return new Date(result);\n      }\n    }\n    return result;\n  }\n\n  async createTrigger(\n    tableName,\n    triggerName,\n    timingType,\n    fireOnArray,\n    functionName,\n    functionParams,\n    optionsArray,\n    options\n  ) {\n    const sql = this.queryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  async dropTrigger(tableName, triggerName, options) {\n    const sql = this.queryGenerator.dropTrigger(tableName, triggerName);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  async renameTrigger(tableName, oldTriggerName, newTriggerName, options) {\n    const sql = this.queryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  /**\n   * Create an SQL function\n   *\n   * @example\n   * queryInterface.createFunction(\n   *   'someFunction',\n   *   [\n   *     {type: 'integer', name: 'param', direction: 'IN'}\n   *   ],\n   *   'integer',\n   *   'plpgsql',\n   *   'RETURN param + 1;',\n   *   [\n   *     'IMMUTABLE',\n   *     'LEAKPROOF'\n   *   ],\n   *   {\n   *    variables:\n   *      [\n   *        {type: 'integer', name: 'myVar', default: 100}\n   *      ],\n   *      force: true\n   *   };\n   * );\n   *\n   * @param {string}  functionName  Name of SQL function to create\n   * @param {Array}   params        List of parameters declared for SQL function\n   * @param {string}  returnType    SQL type of function returned value\n   * @param {string}  language      The name of the language that the function is implemented in\n   * @param {string}  body          Source code of function\n   * @param {Array}   optionsArray  Extra-options for creation\n   * @param {object}  [options]     query options\n   * @param {boolean} options.force If force is true, any existing functions with the same parameters will be replaced. For postgres, this means using `CREATE OR REPLACE FUNCTION` instead of `CREATE FUNCTION`. Default is false\n   * @param {Array<object>}   options.variables List of declared variables. Each variable should be an object with string fields `type` and `name`, and optionally having a `default` field as well.\n   *\n   * @returns {Promise}\n   */\n  async createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    const sql = this.queryGenerator.createFunction(functionName, params, returnType, language, body, optionsArray, options);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  /**\n   * Drop an SQL function\n   *\n   * @example\n   * queryInterface.dropFunction(\n   *   'someFunction',\n   *   [\n   *     {type: 'varchar', name: 'param1', direction: 'IN'},\n   *     {type: 'integer', name: 'param2', direction: 'INOUT'}\n   *   ]\n   * );\n   *\n   * @param {string} functionName Name of SQL function to drop\n   * @param {Array}  params       List of parameters declared for SQL function\n   * @param {object} [options]    query options\n   *\n   * @returns {Promise}\n   */\n  async dropFunction(functionName, params, options) {\n    const sql = this.queryGenerator.dropFunction(functionName, params);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  /**\n   * Rename an SQL function\n   *\n   * @example\n   * queryInterface.renameFunction(\n   *   'fooFunction',\n   *   [\n   *     {type: 'varchar', name: 'param1', direction: 'IN'},\n   *     {type: 'integer', name: 'param2', direction: 'INOUT'}\n   *   ],\n   *   'barFunction'\n   * );\n   *\n   * @param {string} oldFunctionName  Current name of function\n   * @param {Array}  params           List of parameters declared for SQL function\n   * @param {string} newFunctionName  New name of function\n   * @param {object} [options]        query options\n   *\n   * @returns {Promise}\n   */\n  async renameFunction(oldFunctionName, params, newFunctionName, options) {\n    const sql = this.queryGenerator.renameFunction(oldFunctionName, params, newFunctionName);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  // Helper methods useful for querying\n\n  /**\n   * @private\n   */\n  ensureEnums() {\n    // noop by default\n  }\n\n  async setIsolationLevel(transaction, value, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to set isolation level for a transaction without transaction object!');\n    }\n\n    if (transaction.parent || !value) {\n      // Not possible to set a separate isolation level for savepoints\n      return;\n    }\n\n    options = { ...options, transaction: transaction.parent || transaction };\n\n    const sql = this.queryGenerator.setIsolationLevelQuery(value, {\n      parent: transaction.parent\n    });\n\n    if (!sql) return;\n\n    return await this.sequelize.query(sql, options);\n  }\n\n  async startTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to start a transaction without transaction object!');\n    }\n\n    options = { ...options, transaction: transaction.parent || transaction };\n    options.transaction.name = transaction.parent ? transaction.name : undefined;\n    const sql = this.queryGenerator.startTransactionQuery(transaction);\n\n    return await this.sequelize.query(sql, options);\n  }\n\n  async deferConstraints(transaction, options) {\n    options = { ...options, transaction: transaction.parent || transaction };\n\n    const sql = this.queryGenerator.deferConstraintsQuery(options);\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  async commitTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to commit a transaction without transaction object!');\n    }\n    if (transaction.parent) {\n      // Savepoints cannot be committed\n      return;\n    }\n\n    options = {\n      ...options,\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    };\n\n    const sql = this.queryGenerator.commitTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n\n    transaction.finished = 'commit';\n\n    return await promise;\n  }\n\n  async rollbackTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to rollback a transaction without transaction object!');\n    }\n\n    options = {\n      ...options,\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    };\n    options.transaction.name = transaction.parent ? transaction.name : undefined;\n    const sql = this.queryGenerator.rollbackTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n\n    transaction.finished = 'rollback';\n\n    return await promise;\n  }\n}\n\nexports.QueryInterface = QueryInterface;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}