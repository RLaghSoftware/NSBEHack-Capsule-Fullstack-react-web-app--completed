{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __markAsModule = target => __defProp(target, \"__esModule\", {\n  value: true\n});\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n__export(exports, {\n  OracleQuery: () => OracleQuery\n});\nconst AbstractQuery = require(\"../abstract/query\");\nconst SequelizeErrors = require(\"../../errors\");\nconst parserStore = require(\"../parserStore\")(\"oracle\");\nconst _ = require(\"lodash\");\nconst Utils = require(\"../../utils\");\nconst {\n  logger\n} = require(\"../../utils/logger\");\nconst debug = logger.debugContext(\"sql:oracle\");\nclass OracleQuery extends AbstractQuery {\n  constructor(connection, sequelize, options) {\n    super(connection, sequelize, options);\n    this.options = _.extend({\n      logging: console.log,\n      plain: false,\n      raw: false\n    }, options || {});\n    this.checkLoggingOption();\n    this.outFormat = options.outFormat || this.sequelize.connectionManager.lib.OBJECT;\n  }\n  getInsertIdField() {\n    return \"id\";\n  }\n  getExecOptions() {\n    const execOpts = {\n      outFormat: this.outFormat,\n      autoCommit: this.autoCommit\n    };\n    const oracledb = this.sequelize.connectionManager.lib;\n    if (this.model && this.isSelectQuery()) {\n      const fInfo = {};\n      const keys = Object.keys(this.model.tableAttributes);\n      for (const key of keys) {\n        const keyValue = this.model.tableAttributes[key];\n        if (keyValue.type.key === \"DECIMAL\") {\n          fInfo[key] = {\n            type: oracledb.STRING\n          };\n        }\n        if (keyValue.type.key === \"BIGINT\") {\n          fInfo[key] = {\n            type: oracledb.STRING\n          };\n        }\n      }\n      if (fInfo) {\n        execOpts.fetchInfo = fInfo;\n      }\n    }\n    return execOpts;\n  }\n  _convertBindAttributes(bindingDictionary, oracledb) {\n    if (this.model && this.options[bindingDictionary]) {\n      const keys = Object.keys(this.model.tableAttributes);\n      for (const key of keys) {\n        const keyValue = this.model.tableAttributes[key];\n        if (keyValue.type.key === \"BIGINT\") {\n          const oldBinding = this.options[bindingDictionary][key];\n          if (oldBinding) {\n            this.options[bindingDictionary][key] = __spreadProps(__spreadValues({}, oldBinding), {\n              type: oracledb.STRING,\n              maxSize: 1e7\n            });\n          }\n        }\n      }\n    }\n  }\n  async run(sql, parameters) {\n    const oracledb = this.sequelize.connectionManager.lib;\n    const complete = this._logQuery(sql, debug, parameters);\n    const outParameters = [];\n    const bindParameters = [];\n    const bindDef = [];\n    if (!sql.match(/END;$/)) {\n      this.sql = sql.replace(/; *$/, \"\");\n    } else {\n      this.sql = sql;\n    }\n    if (this.options.outBindAttributes && (Array.isArray(parameters) || _.isPlainObject(parameters))) {\n      this._convertBindAttributes(\"outBindAttributes\", oracledb);\n      outParameters.push(...Object.values(this.options.outBindAttributes));\n      if (this.isUpsertQuery()) {\n        outParameters.push({\n          dir: oracledb.BIND_OUT\n        });\n      }\n    }\n    this.bindParameters = outParameters;\n    if (Array.isArray(parameters) || _.isPlainObject(parameters)) {\n      if (this.options.executeMany) {\n        this._convertBindAttributes(\"inbindAttributes\", oracledb);\n        bindDef.push(...Object.values(this.options.inbindAttributes));\n        bindDef.push(...outParameters);\n        this.bindParameters = parameters;\n      } else {\n        Object.values(parameters).forEach(value => {\n          bindParameters.push(value);\n        });\n        bindParameters.push(...outParameters);\n        Object.assign(this.bindParameters, bindParameters);\n      }\n    }\n    if (this.sql.startsWith(\"BEGIN TRANSACTION\")) {\n      this.autocommit = false;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith(\"SET AUTOCOMMIT ON\")) {\n      this.autocommit = true;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith(\"SET AUTOCOMMIT OFF\")) {\n      this.autocommit = false;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith(\"DECLARE x NUMBER\")) {\n      if (this.autoCommit === void 0) {\n        if (this.connection.uuid) {\n          this.autoCommit = false;\n        } else {\n          this.autoCommit = true;\n        }\n      }\n      try {\n        await this.connection.execute(this.sql, this.bindParameters, {\n          autoCommit: this.autoCommit\n        });\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith(\"BEGIN\")) {\n      if (this.autoCommit === void 0) {\n        if (this.connection.uuid) {\n          this.autoCommit = false;\n        } else {\n          this.autoCommit = true;\n        }\n      }\n      try {\n        const result = await this.connection.execute(this.sql, this.bindParameters, {\n          outFormat: this.outFormat,\n          autoCommit: this.autoCommit\n        });\n        if (!Array.isArray(result.outBinds)) {\n          return [result.outBinds];\n        }\n        return result.outBinds;\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith(\"COMMIT TRANSACTION\")) {\n      try {\n        await this.connection.commit();\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith(\"ROLLBACK TRANSACTION\")) {\n      try {\n        await this.connection.rollback();\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith(\"SET TRANSACTION\")) {\n      try {\n        await this.connection.execute(this.sql, [], {\n          autoCommit: false\n        });\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.autoCommit === void 0) {\n      if (this.connection.uuid) {\n        this.autoCommit = false;\n      } else {\n        this.autoCommit = true;\n      }\n    }\n    if (\"inputParameters\" in this.options && this.options.inputParameters !== null) {\n      Object.assign(this.bindParameters, this.options.inputParameters);\n    }\n    const execOpts = this.getExecOptions();\n    if (this.options.executeMany && bindDef.length > 0) {\n      execOpts.bindDefs = bindDef;\n    }\n    const executePromise = this.options.executeMany ? this.connection.executeMany(this.sql, this.bindParameters, execOpts) : this.connection.execute(this.sql, this.bindParameters, execOpts);\n    try {\n      const result = await executePromise;\n      return this.formatResults(result);\n    } catch (error) {\n      throw this.formatError(error);\n    } finally {\n      complete();\n    }\n  }\n  static formatBindParameters(sql, values, dialect) {\n    const replacementFunc = (match, key, values2) => {\n      if (values2[key] !== void 0) {\n        return `:${key}`;\n      }\n      return void 0;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n    return [sql, values];\n  }\n  _getAttributeMap(attrsMap, rawAttributes) {\n    attrsMap = Object.assign(attrsMap, _.reduce(rawAttributes, (mp, _2, key) => {\n      const catalogKey = this.sequelize.queryInterface.queryGenerator.getCatalogName(key);\n      mp[catalogKey] = key;\n      return mp;\n    }, {}));\n  }\n  _processRows(rows) {\n    let result = rows;\n    let attrsMap = {};\n    if (this.sequelize.options.quoteIdentifiers === false) {\n      attrsMap = _.reduce(this.options.attributes, (mp, v) => {\n        if (typeof v === \"object\") {\n          v = v[1];\n        }\n        const catalogv = this.sequelize.queryInterface.queryGenerator.getCatalogName(v);\n        mp[catalogv] = v;\n        return mp;\n      }, {});\n      if (this.model) {\n        this._getAttributeMap(attrsMap, this.model.rawAttributes);\n      }\n      if (this.options.aliasesMapping) {\n        const obj = Object.fromEntries(this.options.aliasesMapping);\n        rows = rows.map(row => _.toPairs(row).reduce((acc, _ref) => {\n          let [key, value] = _ref;\n          const mapping = Object.values(obj).find(element => {\n            const catalogElement = this.sequelize.queryInterface.queryGenerator.getCatalogName(element);\n            return catalogElement === key;\n          });\n          if (mapping) acc[mapping || key] = value;\n          return acc;\n        }, {}));\n      }\n      result = rows.map(row => {\n        return _.mapKeys(row, (value, key) => {\n          const targetAttr = attrsMap[key];\n          if (typeof targetAttr === \"string\" && targetAttr !== key) {\n            return targetAttr;\n          }\n          return key;\n        });\n      });\n    }\n    if (this.model) {\n      result = result.map(row => {\n        return _.mapValues(row, (value, key) => {\n          if (this.model.rawAttributes[key] && this.model.rawAttributes[key].type) {\n            let typeid = this.model.rawAttributes[key].type.toLocaleString();\n            if (this.model.rawAttributes[key].type.key === \"JSON\") {\n              value = JSON.parse(value);\n            }\n            if (typeid.indexOf(\"(\") > -1 && this.model.rawAttributes[key].type.key !== \"BOOLEAN\") {\n              typeid = typeid.substr(0, typeid.indexOf(\"(\"));\n            }\n            const parse = parserStore.get(typeid);\n            if (value !== null & !!parse) {\n              value = parse(value);\n            }\n          }\n          return value;\n        });\n      });\n    }\n    return result;\n  }\n  formatResults(data) {\n    let result = this.instance;\n    if (this.isInsertQuery(data)) {\n      let insertData;\n      if (data.outBinds) {\n        const keys = Object.keys(this.options.outBindAttributes);\n        insertData = data.outBinds;\n        if (this.instance) {\n          insertData = [insertData];\n        }\n        const res = insertData.map(row => {\n          const obj = {};\n          row.forEach((element, index) => {\n            obj[keys[index]] = element[0];\n          });\n          return obj;\n        });\n        insertData = res;\n        if (!this.instance) {\n          result = res;\n        }\n      }\n      this.handleInsertQuery(insertData);\n      return [result, data.rowsAffected];\n    }\n    if (this.isShowTablesQuery()) {\n      result = this.handleShowTablesQuery(data.rows);\n    } else if (this.isDescribeQuery()) {\n      result = {};\n      const table = Object.keys(this.sequelize.models);\n      const modelAttributes = {};\n      if (this.sequelize.models && table.length > 0) {\n        this._getAttributeMap(modelAttributes, this.sequelize.models[table[0]].rawAttributes);\n      }\n      data.rows.forEach(_result => {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", \"\").replace(\"')\", \"\").replace(/'/g, \"\");\n        }\n        if (!(modelAttributes[_result.COLUMN_NAME] in result)) {\n          let key = modelAttributes[_result.COLUMN_NAME];\n          if (!key) {\n            key = _result.COLUMN_NAME;\n          }\n          result[key] = {\n            type: _result.DATA_TYPE.toUpperCase(),\n            allowNull: _result.NULLABLE === \"N\" ? false : true,\n            defaultValue: void 0,\n            primaryKey: _result.CONSTRAINT_TYPE === \"P\"\n          };\n        }\n      });\n    } else if (this.isShowIndexesQuery()) {\n      result = this.handleShowIndexesQuery(data.rows);\n    } else if (this.isSelectQuery()) {\n      const rows = data.rows;\n      const result2 = this._processRows(rows);\n      return this.handleSelectQuery(result2);\n    } else if (this.isCallQuery()) {\n      result = data.rows[0];\n    } else if (this.isUpdateQuery()) {\n      result = [result, data.rowsAffected];\n    } else if (this.isBulkUpdateQuery()) {\n      result = data.rowsAffected;\n    } else if (this.isBulkDeleteQuery()) {\n      result = data.rowsAffected;\n    } else if (this.isVersionQuery()) {\n      const version = data.rows[0].VERSION_FULL;\n      if (version) {\n        const versions = version.split(\".\");\n        result = `${versions[0]}.${versions[1]}.${versions[2]}`;\n      } else {\n        result = \"0.0.0\";\n      }\n    } else if (this.isForeignKeysQuery()) {\n      result = data.rows;\n    } else if (this.isUpsertQuery()) {\n      data = data.outBinds;\n      const keys = Object.keys(this.options.outBindAttributes);\n      const obj = {};\n      for (const k in keys) {\n        obj[keys[k]] = data[k];\n      }\n      obj.isUpdate = data[data.length - 1];\n      data = obj;\n      result = [{\n        isNewRecord: data.isUpdate,\n        value: data\n      }, data.isUpdate == 0];\n    } else if (this.isShowConstraintsQuery()) {\n      result = this.handleShowConstraintsQuery(data);\n    } else if (this.isRawQuery()) {\n      if (data && data.rows) {\n        return [data.rows, data.metaData];\n      }\n      return [data, data];\n    }\n    return result;\n  }\n  handleShowConstraintsQuery(data) {\n    return data.rows.map(result => {\n      const constraint = {};\n      for (const key in result) {\n        constraint[_.camelCase(key)] = result[key].toLowerCase();\n      }\n      return constraint;\n    });\n  }\n  handleShowTablesQuery(results) {\n    return results.map(resultSet => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n  formatError(err) {\n    let match;\n    match = err.message.match(/unique constraint ([\\s\\S]*) violated/);\n    if (match && match.length > 1) {\n      match[1] = match[1].replace(\"(\", \"\").replace(\")\", \"\").split(\".\")[1];\n      const errors = [];\n      let fields = [],\n        message = \"Validation error\",\n        uniqueKey = null;\n      if (this.model) {\n        const uniqueKeys = Object.keys(this.model.uniqueKeys);\n        const currKey = uniqueKeys.find(key => {\n          return key.toUpperCase() === match[1].toUpperCase() || key.toUpperCase() === `\"${match[1].toUpperCase()}\"`;\n        });\n        if (currKey) {\n          uniqueKey = this.model.uniqueKeys[currKey];\n          fields = uniqueKey.fields;\n        }\n        if (uniqueKey && !!uniqueKey.msg) {\n          message = uniqueKey.msg;\n        }\n        fields.forEach(field => {\n          errors.push(new SequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, null));\n        });\n      }\n      return new SequelizeErrors.UniqueConstraintError({\n        message,\n        errors,\n        err,\n        fields\n      });\n    }\n    match = err.message.match(/ORA-02291/) || err.message.match(/ORA-02292/);\n    if (match && match.length > 0) {\n      return new SequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err\n      });\n    }\n    match = err.message.match(/ORA-02443/);\n    if (match && match.length > 0) {\n      return new SequelizeErrors.UnknownConstraintError(match[1]);\n    }\n    return new SequelizeErrors.DatabaseError(err);\n  }\n  isShowIndexesQuery() {\n    return this.sql.indexOf(\"SELECT i.index_name,i.table_name, i.column_name, u.uniqueness\") > -1;\n  }\n  isSelectCountQuery() {\n    return this.sql.toUpperCase().indexOf(\"SELECT COUNT(\") > -1;\n  }\n  handleShowIndexesQuery(data) {\n    const acc = [];\n    data.forEach(indexRecord => {\n      if (!acc[indexRecord.INDEX_NAME]) {\n        acc[indexRecord.INDEX_NAME] = {\n          unique: indexRecord.UNIQUENESS === \"UNIQUE\" ? true : false,\n          primary: indexRecord.CONSTRAINT_TYPE === \"P\",\n          name: indexRecord.INDEX_NAME.toLowerCase(),\n          tableName: indexRecord.TABLE_NAME.toLowerCase(),\n          type: void 0\n        };\n        acc[indexRecord.INDEX_NAME].fields = [];\n      }\n      acc[indexRecord.INDEX_NAME].fields.push({\n        attribute: indexRecord.COLUMN_NAME,\n        length: void 0,\n        order: indexRecord.DESCEND,\n        collate: void 0\n      });\n    });\n    const returnIndexes = [];\n    const accKeys = Object.keys(acc);\n    for (const accKey of accKeys) {\n      const columns = {};\n      columns.fields = acc[accKey].fields;\n      if (acc[accKey].name.match(/sys_c[0-9]*/)) {\n        acc[accKey].name = Utils.nameIndex(columns, acc[accKey].tableName).name;\n      }\n      returnIndexes.push(acc[accKey]);\n    }\n    return returnIndexes;\n  }\n  handleInsertQuery(results, metaData) {\n    if (this.instance && results.length > 0) {\n      if (\"pkReturnVal\" in results[0]) {\n        results[0][this.model.primaryKeyAttribute] = results[0].pkReturnVal;\n        delete results[0].pkReturnVal;\n      }\n      const autoIncrementField = this.model.autoIncrementAttribute;\n      let autoIncrementFieldAlias = null,\n        id = null;\n      if (Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementField) && this.model.rawAttributes[autoIncrementField].field !== void 0) autoIncrementFieldAlias = this.model.rawAttributes[autoIncrementField].field;\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementField];\n      id = id || autoIncrementFieldAlias && results && results[0][autoIncrementFieldAlias];\n      this.instance[autoIncrementField] = id;\n    }\n  }\n}","map":{"version":3,"mappings":"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","names":["__export","OracleQuery","AbstractQuery","require","SequelizeErrors","parserStore","_","Utils","logger","debug","debugContext","constructor","connection","sequelize","options","extend","logging","console","log","plain","raw","checkLoggingOption","outFormat","connectionManager","lib","OBJECT","getInsertIdField","getExecOptions","execOpts","autoCommit","oracledb","model","isSelectQuery","fInfo","keys","Object","tableAttributes","key","keyValue","type","STRING","fetchInfo","_convertBindAttributes","bindingDictionary","oldBinding","__spreadProps","maxSize","run","sql","parameters","complete","_logQuery","outParameters","bindParameters","bindDef","match","replace","outBindAttributes","Array","isArray","isPlainObject","push","values","isUpsertQuery","dir","BIND_OUT","executeMany","inbindAttributes","forEach","value","assign","startsWith","autocommit","Promise","resolve","uuid","execute","create","error","formatError","result","outBinds","commit","rollback","inputParameters","length","bindDefs","executePromise","formatResults","formatBindParameters","dialect","replacementFunc","values2","_getAttributeMap","attrsMap","rawAttributes","reduce","mp","_2","catalogKey","queryInterface","queryGenerator","getCatalogName","_processRows","rows","quoteIdentifiers","attributes","v","catalogv","aliasesMapping","obj","fromEntries","map","row","toPairs","acc","mapping","find","element","catalogElement","mapKeys","targetAttr","mapValues","typeid","toLocaleString","JSON","parse","indexOf","substr","get","data","instance","isInsertQuery","insertData","res","index","handleInsertQuery","rowsAffected","isShowTablesQuery","handleShowTablesQuery","isDescribeQuery","table","models","modelAttributes","_result","Default","COLUMN_NAME","DATA_TYPE","toUpperCase","allowNull","NULLABLE","defaultValue","primaryKey","CONSTRAINT_TYPE","isShowIndexesQuery","handleShowIndexesQuery","result2","handleSelectQuery","isCallQuery","isUpdateQuery","isBulkUpdateQuery","isBulkDeleteQuery","isVersionQuery","version","VERSION_FULL","versions","split","isForeignKeysQuery","k","isUpdate","isNewRecord","isShowConstraintsQuery","handleShowConstraintsQuery","isRawQuery","metaData","constraint","camelCase","toLowerCase","results","resultSet","tableName","TABLE_NAME","schema","TABLE_SCHEMA","err","message","errors","fields","uniqueKey","uniqueKeys","currKey","msg","field","ValidationErrorItem","getUniqueConstraintErrorMessage","UniqueConstraintError","ForeignKeyConstraintError","parent","UnknownConstraintError","DatabaseError","isSelectCountQuery","indexRecord","INDEX_NAME","unique","UNIQUENESS","primary","name","attribute","order","DESCEND","collate","returnIndexes","accKeys","accKey","columns","nameIndex","primaryKeyAttribute","pkReturnVal","autoIncrementField","autoIncrementAttribute","autoIncrementFieldAlias","id","prototype","hasOwnProperty","call"],"sources":["C:\\Users\\rizla\\projects\\react\\NSBEHack-main\\nsbeapp\\node_modules\\sequelize\\src\\dialects\\oracle\\query.js"],"sourcesContent":["// Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved\n\n'use strict';\n\nconst AbstractQuery = require('../abstract/query');\nconst SequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('oracle');\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst { logger } = require('../../utils/logger');\n\nconst debug = logger.debugContext('sql:oracle');\n\nexport class OracleQuery extends AbstractQuery {\n  constructor(connection, sequelize, options) {\n    super(connection, sequelize, options);\n    this.options = _.extend(\n      {\n        logging: console.log,\n        plain: false,\n        raw: false\n      },\n      options || {}\n    );\n\n    this.checkLoggingOption();\n    this.outFormat = options.outFormat || this.sequelize.connectionManager.lib.OBJECT;\n  }\n\n  getInsertIdField() {\n    return 'id';\n  }\n\n  getExecOptions() {\n    const execOpts = { outFormat: this.outFormat, autoCommit: this.autoCommit };\n\n    // We set the oracledb\n    const oracledb = this.sequelize.connectionManager.lib;\n\n    if (this.model && this.isSelectQuery()) {\n      const fInfo = {};\n      const keys = Object.keys(this.model.tableAttributes);\n      for (const key of keys) {\n        const keyValue = this.model.tableAttributes[key];\n        if (keyValue.type.key === 'DECIMAL') {\n          fInfo[key] = { type: oracledb.STRING };\n        }\n        // Fetching BIGINT as string since, node-oracledb doesn't support JS BIGINT yet\n        if (keyValue.type.key === 'BIGINT') {\n          fInfo[key] = { type: oracledb.STRING };\n        }\n      }\n      if ( fInfo ) {\n        execOpts.fetchInfo = fInfo;\n      }\n    }\n    return execOpts;\n  }\n\n  /**\n   * convert binding values for unsupported\n   * types in connector library\n   *\n   * @param {string} bindingDictionary a string representing the key to scan\n   * @param {object} oracledb native oracle library\n   * @private\n   */\n  _convertBindAttributes(bindingDictionary, oracledb) {\n    if (this.model && this.options[bindingDictionary]) {\n      // check against model if we have some BIGINT\n      const keys = Object.keys(this.model.tableAttributes);\n      for (const key of keys) {\n        const keyValue = this.model.tableAttributes[key];\n        if (keyValue.type.key === 'BIGINT') {\n          const oldBinding = this.options[bindingDictionary][key];\n          if (oldBinding) {\n            this.options[bindingDictionary][key] = {\n              ...oldBinding,\n              type: oracledb.STRING,\n              maxSize: 10000000 //TOTALLY ARBITRARY Number to prevent query failure\n            };\n          }\n        }\n      }\n    }\n  }\n\n  async run(sql, parameters) {\n    // We set the oracledb\n    const oracledb = this.sequelize.connectionManager.lib;\n    const complete = this._logQuery(sql, debug, parameters);\n    const outParameters = [];\n    const bindParameters = [];\n    const bindDef = [];\n\n    if (!sql.match(/END;$/)) {\n      this.sql = sql.replace(/; *$/, '');\n    } else {\n      this.sql = sql;\n    }\n\n    // When this.options.bindAttributes exists then it is an insertQuery/upsertQuery\n    // So we insert the return bind direction and type\n    if (this.options.outBindAttributes && (Array.isArray(parameters) || _.isPlainObject(parameters))) {\n      this._convertBindAttributes('outBindAttributes', oracledb);\n      outParameters.push(...Object.values(this.options.outBindAttributes));\n      // For upsertQuery we need to push the bindDef for isUpdate\n      if (this.isUpsertQuery()) {\n        outParameters.push({ dir: oracledb.BIND_OUT });\n      }\n    }\n\n    this.bindParameters = outParameters;\n    // construct input binds from parameters for single row insert execute call\n    // ex: [3, 4,...]\n    if (Array.isArray(parameters) || _.isPlainObject(parameters)) {\n      if (this.options.executeMany) {\n        // Constructing BindDefs for ExecuteMany call\n        // Building the bindDef for in and out binds\n        this._convertBindAttributes('inbindAttributes', oracledb);\n        bindDef.push(...Object.values(this.options.inbindAttributes));\n        bindDef.push(...outParameters);\n        this.bindParameters = parameters;\n      } else {\n        Object.values(parameters).forEach(value => {\n          bindParameters.push(value);\n        });\n        bindParameters.push(...outParameters);\n        Object.assign(this.bindParameters, bindParameters);\n      }\n    }\n\n    // TRANSACTION SUPPORT\n    if (this.sql.startsWith('BEGIN TRANSACTION')) {\n      this.autocommit = false;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith('SET AUTOCOMMIT ON')) {\n      this.autocommit = true;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith('SET AUTOCOMMIT OFF')) {\n      this.autocommit = false;\n      return Promise.resolve();\n    }\n    if (this.sql.startsWith('DECLARE x NUMBER')) {\n      // Calling a stored procedure for bulkInsert with NO attributes, returns nothing\n      if (this.autoCommit === undefined) {\n        if (this.connection.uuid) {\n          this.autoCommit = false;\n        } else {\n          this.autoCommit = true;\n        }\n      }\n\n      try {\n        await this.connection.execute(this.sql, this.bindParameters, { autoCommit: this.autoCommit });\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith('BEGIN')) {\n      // Call to stored procedures - BEGIN TRANSACTION has been treated before\n      if (this.autoCommit === undefined) {\n        if (this.connection.uuid) {\n          this.autoCommit = false;\n        } else {\n          this.autoCommit = true;\n        }\n      }\n\n      try {\n        const result = await this.connection.execute(this.sql, this.bindParameters, {\n          outFormat: this.outFormat,\n          autoCommit: this.autoCommit\n        });\n        if (!Array.isArray(result.outBinds)) {\n          return [result.outBinds];\n        }\n        return result.outBinds;\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith('COMMIT TRANSACTION')) {\n      try {\n        await this.connection.commit();\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith('ROLLBACK TRANSACTION')) {\n      try {\n        await this.connection.rollback();\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    if (this.sql.startsWith('SET TRANSACTION')) {\n      try {\n        await this.connection.execute(this.sql, [], { autoCommit: false });\n        return Object.create(null);\n      } catch (error) {\n        throw this.formatError(error);\n      } finally {\n        complete();\n      }\n    }\n    // QUERY SUPPORT\n    // As Oracle does everything in transaction, if autoCommit is not defined, we set it to true\n    if (this.autoCommit === undefined) {\n      if (this.connection.uuid) {\n        this.autoCommit = false;\n      } else {\n        this.autoCommit = true;\n      }\n    }\n\n    // inbind parameters added byname. merge them\n    if ('inputParameters' in this.options && this.options.inputParameters !== null) {\n      Object.assign(this.bindParameters, this.options.inputParameters);\n    }\n    const execOpts = this.getExecOptions();\n    if (this.options.executeMany && bindDef.length > 0) {\n      execOpts.bindDefs = bindDef;\n    }\n    const executePromise = this.options.executeMany ? this.connection.executeMany(this.sql, this.bindParameters, execOpts) : this.connection.execute(this.sql, this.bindParameters, execOpts);\n    try {\n      const result = await executePromise;\n      return this.formatResults(result);\n    } catch (error) {\n      throw this.formatError(error);\n    } finally {\n      complete();\n    }\n  }\n\n  /**\n * The parameters to query.run function are built here\n *\n * @param {string} sql\n * @param {Array} values\n * @param {string} dialect\n */\n  static formatBindParameters(sql, values, dialect) {\n\n    const replacementFunc = (match, key, values) => {\n      if (values[key] !== undefined) {\n        return `:${key}`;\n      }\n      return undefined;\n    };\n    sql = AbstractQuery.formatBindParameters(sql, values, dialect, replacementFunc)[0];\n\n    return [sql, values];\n  }\n\n  /**\n   * Building the attribute map by matching the column names received\n   * from DB and the one in rawAttributes\n   * to sequelize format\n   *\n   * @param {object} attrsMap\n   * @param {object} rawAttributes\n   * @private\n   */\n  _getAttributeMap(attrsMap, rawAttributes) {\n    attrsMap = Object.assign(attrsMap, _.reduce(rawAttributes, (mp, _, key) => {\n      const catalogKey = this.sequelize.queryInterface.queryGenerator.getCatalogName(key);\n      mp[catalogKey] = key;\n      return mp;\n    }, {}));\n  }\n\n  /**\n   * Process rows received from the DB.\n   * Use parse function to parse the returned value\n   * to sequelize format\n   *\n   * @param {Array} rows\n   * @private\n   */\n  _processRows(rows) {\n    let result = rows;\n    let attrsMap = {};\n\n    // When quoteIdentifiers is false we need to map the DB column names\n    // To the one in attribute list\n    if (this.sequelize.options.quoteIdentifiers === false) {\n      // Building the attribute map from this.options.attributes\n      // Needed in case of an aggregate function\n      attrsMap = _.reduce(this.options.attributes, (mp, v) => {\n        // Aggregate function is of form\n        // Fn {fn: 'min', min}, so we have the name in index one of the object\n        if (typeof v === 'object') {\n          v = v[1];\n        }\n        const catalogv = this.sequelize.queryInterface.queryGenerator.getCatalogName(v);\n        mp[catalogv] = v;\n        return mp;\n      }, {});\n\n\n      // Building the attribute map by matching the column names received\n      // from DB and the one in model.rawAttributes\n      if (this.model) {\n        this._getAttributeMap(attrsMap, this.model.rawAttributes);\n      }\n\n      // If aliasesmapping exists we update the attribute map\n      if (this.options.aliasesMapping) {\n        const obj = Object.fromEntries(this.options.aliasesMapping);\n        rows = rows\n          .map(row => _.toPairs(row)\n            .reduce((acc, [key, value]) => {\n              const mapping = Object.values(obj).find(element => {\n                const catalogElement = this.sequelize.queryInterface.queryGenerator.getCatalogName(element);\n                return catalogElement === key;\n              });\n              if (mapping)\n                acc[mapping || key] = value;\n              return acc;\n            }, {})\n          );\n      }\n\n      // Modify the keys into the format that sequelize expects\n      result = rows.map(row => {\n        return _.mapKeys(row, (value, key) => {\n          const targetAttr = attrsMap[key];\n          if (typeof targetAttr === 'string' && targetAttr !== key) {\n            return targetAttr;\n          }\n          return key;\n        });\n      });\n    }\n\n    // We parse the value received from the DB based on its datatype\n    if (this.model) {\n      result = result.map(row => {\n        return _.mapValues(row, (value, key) => {\n          if (this.model.rawAttributes[key] && this.model.rawAttributes[key].type) {\n            let typeid = this.model.rawAttributes[key].type.toLocaleString();\n            if (this.model.rawAttributes[key].type.key === 'JSON') {\n              value = JSON.parse(value);\n            }\n            // For some types, the \"name\" of the type is returned with the length, we remove it\n            // For Boolean we skip this because BOOLEAN is mapped to CHAR(1) and we dont' want to\n            // remove the (1) for BOOLEAN\n            if (typeid.indexOf('(') > -1 && this.model.rawAttributes[key].type.key !== 'BOOLEAN') {\n              typeid = typeid.substr(0, typeid.indexOf('('));\n            }\n            const parse = parserStore.get(typeid);\n            if (value !== null & !!parse) {\n              value = parse(value);\n            }\n          }\n          return value;\n        });\n      });\n    }\n\n    return result;\n  }\n\n  /**\n   * High level function that handles the results of a query execution.\n   * Example:\n   * Oracle format :\n   * { rows: //All rows\n     [ [ 'Oracle Database 11g Enterprise Edition Release 11.2.0.1.0 - 64bit Production' ],\n       [ 'PL/SQL Release 11.2.0.1.0 - Production' ],\n       [ 'CORE\\t11.2.0.1.0\\tProduction' ],\n       [ 'TNS for 64-bit Windows: Version 11.2.0.1.0 - Production' ],\n       [ 'NLSRTL Version 11.2.0.1.0 - Production' ] ],\n    resultSet: undefined,\n    outBinds: undefined, //Used for dbms_put.line\n    rowsAffected: undefined, //Number of rows affected\n    metaData: [ { name: 'BANNER' } ] }\n  *\n  * @param {Array} data - The result of the query execution.\n  */\n  formatResults(data) {\n    let result = this.instance;\n    if (this.isInsertQuery(data)) {\n      let insertData;\n      if (data.outBinds) {\n        const keys = Object.keys(this.options.outBindAttributes);\n        insertData = data.outBinds;\n        // For one row insert out bind array is 1D array\n        // we convert it to 2D array for uniformity\n        if (this.instance) {\n          insertData = [insertData];\n        }\n        // Mapping the bind parameter to their values\n        const res = insertData.map(row =>{\n          const obj = {};\n          row.forEach((element, index) =>{\n            obj[keys[index]] = element[0];\n          });\n          return obj;\n        });\n        insertData = res;\n        // For bulk insert this.insert is undefined\n        // we map result to res, for one row insert\n        // result needs to be this.instance\n        if (!this.instance) {\n          result = res;\n        }\n      }\n      this.handleInsertQuery(insertData);\n      return [result, data.rowsAffected];\n    }\n    if (this.isShowTablesQuery()) {\n      result = this.handleShowTablesQuery(data.rows);\n    } else if (this.isDescribeQuery()) {\n      result = {};\n      // Getting the table name on which we are doing describe query\n      const table = Object.keys(this.sequelize.models);\n      const modelAttributes = {};\n      // Get the model raw attributes\n      if (this.sequelize.models && table.length > 0) {\n        this._getAttributeMap(modelAttributes, this.sequelize.models[table[0]].rawAttributes);\n      }\n      data.rows.forEach(_result => {\n        if (_result.Default) {\n          _result.Default = _result.Default.replace(\"('\", '')\n            .replace(\"')\", '')\n            .replace(/'/g, ''); /* jshint ignore: line */\n        }\n\n        if (!(modelAttributes[_result.COLUMN_NAME] in result)) {\n          let key = modelAttributes[_result.COLUMN_NAME];\n          if (!key) {\n            key = _result.COLUMN_NAME;\n          }\n\n          result[key] = {\n            type: _result.DATA_TYPE.toUpperCase(),\n            allowNull: _result.NULLABLE === 'N' ? false : true,\n            defaultValue: undefined,\n            primaryKey: _result.CONSTRAINT_TYPE === 'P'\n          };\n        }\n      });\n    } else if (this.isShowIndexesQuery()) {\n      result = this.handleShowIndexesQuery(data.rows);\n    } else if (this.isSelectQuery()) {\n      const rows = data.rows;\n      const result = this._processRows(rows);\n      return this.handleSelectQuery(result);\n    } else if (this.isCallQuery()) {\n      result = data.rows[0];\n    } else if (this.isUpdateQuery()) {\n      result = [result, data.rowsAffected];\n    } else if (this.isBulkUpdateQuery()) {\n      result = data.rowsAffected;\n    } else if (this.isBulkDeleteQuery()) {\n      result = data.rowsAffected;\n    } else if (this.isVersionQuery()) {\n      const version = data.rows[0].VERSION_FULL;\n      if (version) {\n        const versions = version.split('.');\n        result = `${versions[0]}.${versions[1]}.${versions[2]}`;\n      } else {\n        result = '0.0.0';\n      }\n    } else if (this.isForeignKeysQuery()) {\n      result = data.rows;\n    } else if (this.isUpsertQuery()) {\n      // Upsert Query, will return nothing\n      data = data.outBinds;\n      const keys = Object.keys(this.options.outBindAttributes);\n      const obj = {};\n      for (const k in keys) {\n        obj[keys[k]] = data[k];\n      }\n      obj.isUpdate = data[data.length - 1];\n      data = obj;\n      result = [{ isNewRecord: data.isUpdate, value: data }, data.isUpdate == 0];\n    } else if (this.isShowConstraintsQuery()) {\n      result = this.handleShowConstraintsQuery(data);\n    } else if (this.isRawQuery()) {\n      // If data.rows exists then it is a select query\n      // Hence we would have two components\n      // metaData and rows and we return them\n      // as [data.rows, data.metaData]\n      // Else it is result of update/upsert/insert query\n      // and it has no rows so we return [data, data]\n      if (data && data.rows) {\n        return [data.rows, data.metaData];\n      }\n      return [data, data];\n    }\n\n    return result;\n  }\n\n  handleShowConstraintsQuery(data) {\n    // Convert snake_case keys to camelCase as its generated by stored procedure\n    return data.rows.map(result => {\n      const constraint = {};\n      for (const key in result) {\n        constraint[_.camelCase(key)] = result[key].toLowerCase();\n      }\n      return constraint;\n    });\n  }\n\n  handleShowTablesQuery(results) {\n    return results.map(resultSet => {\n      return {\n        tableName: resultSet.TABLE_NAME,\n        schema: resultSet.TABLE_SCHEMA\n      };\n    });\n  }\n\n  formatError(err) {\n    let match;\n    // ORA-00001: unique constraint (USER.XXXXXXX) violated\n    match = err.message.match(/unique constraint ([\\s\\S]*) violated/);\n    if (match && match.length > 1) {\n      match[1] = match[1].replace('(', '').replace(')', '').split('.')[1]; // As we get (SEQUELIZE.UNIQNAME), we replace to have UNIQNAME\n      const errors = [];\n      let fields = [],\n        message = 'Validation error',\n        uniqueKey = null;\n\n      if (this.model) {\n        const uniqueKeys = Object.keys(this.model.uniqueKeys);\n\n        const currKey = uniqueKeys.find(key => {\n          // We check directly AND with quotes -> \"a\"\" === a || \"a\" === \"a\"\n          return key.toUpperCase() === match[1].toUpperCase() || key.toUpperCase() === `\"${match[1].toUpperCase()}\"`;\n        });\n\n        if (currKey) {\n          uniqueKey = this.model.uniqueKeys[currKey];\n          fields = uniqueKey.fields;\n        }\n\n        if (uniqueKey && !!uniqueKey.msg) {\n          message = uniqueKey.msg;\n        }\n\n        fields.forEach(field => {\n          errors.push(\n            new SequelizeErrors.ValidationErrorItem(\n              this.getUniqueConstraintErrorMessage(field),\n              'unique violation',\n              field,\n              null\n            )\n          );\n        });\n      }\n\n      return new SequelizeErrors.UniqueConstraintError({\n        message,\n        errors,\n        err,\n        fields\n      });\n    }\n\n    // ORA-02291: integrity constraint (string.string) violated - parent key not found / ORA-02292: integrity constraint (string.string) violated - child record found\n    match = err.message.match(/ORA-02291/) || err.message.match(/ORA-02292/);\n    if (match && match.length > 0) {\n      return new SequelizeErrors.ForeignKeyConstraintError({\n        fields: null,\n        index: match[1],\n        parent: err\n      });\n    }\n\n    // ORA-02443: Cannot drop constraint  - nonexistent constraint\n    match = err.message.match(/ORA-02443/);\n    if (match && match.length > 0) {\n      return new SequelizeErrors.UnknownConstraintError(match[1]);\n    }\n\n    return new SequelizeErrors.DatabaseError(err);\n  }\n\n  isShowIndexesQuery() {\n    return this.sql.indexOf('SELECT i.index_name,i.table_name, i.column_name, u.uniqueness') > -1;\n  }\n\n  isSelectCountQuery() {\n    return this.sql.toUpperCase().indexOf('SELECT COUNT(') > -1;\n  }\n\n  handleShowIndexesQuery(data) {\n    const acc = [];\n\n    // We first treat the datas\n    data.forEach(indexRecord => {\n      // We create the object\n      if (!acc[indexRecord.INDEX_NAME]) {\n        acc[indexRecord.INDEX_NAME] = {\n          unique: indexRecord.UNIQUENESS === 'UNIQUE' ? true : false,\n          primary: indexRecord.CONSTRAINT_TYPE === 'P',\n          name: indexRecord.INDEX_NAME.toLowerCase(),\n          tableName: indexRecord.TABLE_NAME.toLowerCase(),\n          type: undefined\n        };\n        acc[indexRecord.INDEX_NAME].fields = [];\n      }\n\n      // We create the fields\n      acc[indexRecord.INDEX_NAME].fields.push({\n        attribute: indexRecord.COLUMN_NAME,\n        length: undefined,\n        order: indexRecord.DESCEND,\n        collate: undefined\n      });\n    });\n\n    const returnIndexes = [];\n    const accKeys = Object.keys(acc);\n    for (const accKey of accKeys) {\n      const columns = {};\n      columns.fields = acc[accKey].fields;\n      // We are generating index field name in the format sequelize expects\n      // to avoid creating a unique index on auto-generated index name\n      if (acc[accKey].name.match(/sys_c[0-9]*/)) {\n        acc[accKey].name = Utils.nameIndex(columns, acc[accKey].tableName).name;\n      }\n      returnIndexes.push(acc[accKey]);\n    }\n    return returnIndexes;\n  }\n\n  handleInsertQuery(results, metaData) {\n    if (this.instance && results.length > 0) {\n      if ('pkReturnVal' in results[0]) {\n        // The PK of the table is a reserved word (ex : uuid), we have to change the name in the result for the model to find the value correctly\n        results[0][this.model.primaryKeyAttribute] = results[0].pkReturnVal;\n        delete results[0].pkReturnVal;\n      }\n      // add the inserted row id to the instance\n      const autoIncrementField = this.model.autoIncrementAttribute;\n      let autoIncrementFieldAlias = null,\n        id = null;\n\n      if (\n        Object.prototype.hasOwnProperty.call(this.model.rawAttributes, autoIncrementField) &&\n        this.model.rawAttributes[autoIncrementField].field !== undefined\n      )\n        autoIncrementFieldAlias = this.model.rawAttributes[autoIncrementField].field;\n\n      id = id || results && results[0][this.getInsertIdField()];\n      id = id || metaData && metaData[this.getInsertIdField()];\n      id = id || results && results[0][autoIncrementField];\n      id = id || autoIncrementFieldAlias && results && results[0][autoIncrementFieldAlias];\n\n      this.instance[autoIncrementField] = id;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}