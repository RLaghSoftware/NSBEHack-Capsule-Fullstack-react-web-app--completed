{"ast":null,"code":"\"use strict\";\n\nconst _ = require(\"lodash\");\nconst Utils = require(\"../../utils\");\nconst AbstractQuery = require(\"../abstract/query\");\nconst QueryTypes = require(\"../../query-types\");\nconst sequelizeErrors = require(\"../../errors\");\nconst parserStore = require(\"../parserStore\")(\"sqlite\");\nconst {\n  logger\n} = require(\"../../utils/logger\");\nconst debug = logger.debugContext(\"sql:sqlite\");\nfunction stringifyIfBigint(value) {\n  if (typeof value === \"bigint\") {\n    return value.toString();\n  }\n  return value;\n}\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return \"lastID\";\n  }\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam[`$${i + 1}`] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, {\n        skipValueReplace: true\n      })[0];\n    } else {\n      bindParam = {};\n      if (typeof values === \"object\") {\n        for (const k of Object.keys(values)) {\n          bindParam[`$${k}`] = values[k];\n        }\n      }\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, {\n        skipValueReplace: true\n      })[0];\n    }\n    return [sql, bindParam];\n  }\n  _collectModels(include, prefix) {\n    const ret = {};\n    if (include) {\n      for (const _include of include) {\n        let key;\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n        ret[key] = _include.model;\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n    return ret;\n  }\n  _handleQueryResponse(metaData, columnTypes, err, results, errStack) {\n    if (err) {\n      err.sql = this.sql;\n      throw this.formatError(err, errStack);\n    }\n    let result = this.instance;\n    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {\n      this.handleInsertQuery(results, metaData);\n      if (!this.instance) {\n        if (metaData.constructor.name === \"Statement\" && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({\n              [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i\n            });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n    if (this.isShowTablesQuery()) {\n      return results.map(row => row.name);\n    }\n    if (this.isShowConstraintsQuery()) {\n      result = results;\n      if (results && results[0] && results[0].sql) {\n        result = this.parseConstraintsFromSql(results[0].sql);\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      if (this.options.raw) {\n        return this.handleSelectQuery(results);\n      }\n      const prefixes = this._collectModels(this.options.include);\n      results = results.map(result2 => {\n        return _.mapValues(result2, (value, name) => {\n          let model;\n          if (name.includes(\".\")) {\n            const lastind = name.lastIndexOf(\".\");\n            model = prefixes[name.substr(0, lastind)];\n            name = name.substr(lastind + 1);\n          } else {\n            model = this.options.model;\n          }\n          const tableName = model.getTableName().toString().replace(/`/g, \"\");\n          const tableTypes = columnTypes[tableName] || {};\n          if (tableTypes && !(name in tableTypes)) {\n            _.forOwn(model.rawAttributes, (attribute, key) => {\n              if (name === key && attribute.field) {\n                name = attribute.field;\n                return false;\n              }\n            });\n          }\n          return Object.prototype.hasOwnProperty.call(tableTypes, name) ? this.applyParsers(tableTypes[name], value) : value;\n        });\n      });\n      return this.handleSelectQuery(results);\n    }\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n    if (this.sql.includes(\"PRAGMA INDEX_LIST\")) {\n      return this.handleShowIndexesQuery(results);\n    }\n    if (this.sql.includes(\"PRAGMA INDEX_INFO\")) {\n      return results;\n    }\n    if (this.sql.includes(\"PRAGMA TABLE_INFO\")) {\n      result = {};\n      let defaultValue;\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          defaultValue = void 0;\n        } else if (_result.dflt_value === \"NULL\") {\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0\n        };\n        if (result[_result.name].type === \"TINYINT(1)\") {\n          result[_result.name].defaultValue = {\n            \"0\": false,\n            \"1\": true\n          }[result[_result.name].defaultValue];\n        }\n        if (typeof result[_result.name].defaultValue === \"string\") {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, \"\");\n        }\n      }\n      return result;\n    }\n    if (this.sql.includes(\"PRAGMA foreign_keys;\")) {\n      return results[0];\n    }\n    if (this.sql.includes(\"PRAGMA foreign_keys\")) {\n      return results;\n    }\n    if (this.sql.includes(\"PRAGMA foreign_key_list\")) {\n      return results;\n    }\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n    if (this.options.type === QueryTypes.VERSION) {\n      return results[0].version;\n    }\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n    if (this.isUpsertQuery()) {\n      return [result, null];\n    }\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n    return result;\n  }\n  async run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n    const complete = this._logQuery(sql, debug, parameters);\n    return new Promise((resolve, reject) => conn.serialize(async () => {\n      const columnTypes = {};\n      const errForStack = new Error();\n      const executeSql = () => {\n        if (sql.startsWith(\"-- \")) {\n          return resolve();\n        }\n        const query = this;\n        function afterExecute(executionError, results) {\n          try {\n            complete();\n            resolve(query._handleQueryResponse(this, columnTypes, executionError, results, errForStack.stack));\n            return;\n          } catch (error) {\n            reject(error);\n          }\n        }\n        if (!parameters) parameters = [];\n        if (_.isPlainObject(parameters)) {\n          const newParameters = Object.create(null);\n          for (const key of Object.keys(parameters)) {\n            newParameters[`${key}`] = stringifyIfBigint(parameters[key]);\n          }\n          parameters = newParameters;\n        } else {\n          parameters = parameters.map(stringifyIfBigint);\n        }\n        conn[method](sql, parameters, afterExecute);\n        return null;\n      };\n      if (this.getDatabaseMethod() === \"all\") {\n        let tableNames = [];\n        if (this.options && this.options.tableNames) {\n          tableNames = this.options.tableNames;\n        } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n          tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n        }\n        tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== \"sqlite_master\");\n        if (!tableNames.length) {\n          return executeSql();\n        }\n        await Promise.all(tableNames.map(tableName => new Promise(resolve2 => {\n          tableName = tableName.replace(/`/g, \"\");\n          columnTypes[tableName] = {};\n          conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\n            if (!err) {\n              for (const result of results) {\n                columnTypes[tableName][result.name] = result.type;\n              }\n            }\n            resolve2();\n          });\n        })));\n      }\n      return executeSql();\n    }));\n  }\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split(\"CONSTRAINT \");\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map(constraintSql => {\n      if (constraintSql.includes(\"REFERENCES\")) {\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(\" \");\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, \"\").split(\", \");\n        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));\n      }\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, \"\");\n      const constraint = constraintSql.split(\" \");\n      if ([\"PRIMARY\", \"FOREIGN\"].includes(constraint[1])) {\n        constraint[1] += \" KEY\";\n      }\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\"/g, \"`\"),\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n    return constraints;\n  }\n  applyParsers(type, value) {\n    if (type.includes(\"(\")) {\n      type = type.substr(0, type.indexOf(\"(\"));\n    }\n    type = type.replace(\"UNSIGNED\", \"\").replace(\"ZEROFILL\", \"\");\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n    if (value !== null && parse) {\n      return parse(value, {\n        timezone: this.sequelize.options.timezone\n      });\n    }\n    return value;\n  }\n  formatError(err, errStack) {\n    switch (err.code) {\n      case \"SQLITE_CONSTRAINT_UNIQUE\":\n      case \"SQLITE_CONSTRAINT_PRIMARYKEY\":\n      case \"SQLITE_CONSTRAINT_TRIGGER\":\n      case \"SQLITE_CONSTRAINT_FOREIGNKEY\":\n      case \"SQLITE_CONSTRAINT\":\n        {\n          if (err.message.includes(\"FOREIGN KEY constraint failed\")) {\n            return new sequelizeErrors.ForeignKeyConstraintError({\n              parent: err,\n              stack: errStack\n            });\n          }\n          let fields = [];\n          let match = err.message.match(/columns (.*?) are/);\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(\", \");\n          } else {\n            match = err.message.match(/UNIQUE constraint failed: (.*)/);\n            if (match !== null && match.length >= 2) {\n              fields = match[1].split(\", \").map(columnWithTable => columnWithTable.split(\".\")[1]);\n            }\n          }\n          const errors = [];\n          let message = \"Validation error\";\n          for (const field of fields) {\n            errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), \"unique violation\", field, this.instance && this.instance[field], this.instance, \"not_unique\"));\n          }\n          if (this.model) {\n            _.forOwn(this.model.uniqueKeys, constraint => {\n              if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n                message = constraint.msg;\n                return false;\n              }\n            });\n          }\n          return new sequelizeErrors.UniqueConstraintError({\n            message,\n            errors,\n            parent: err,\n            fields,\n            stack: errStack\n          });\n        }\n      case \"SQLITE_BUSY\":\n        return new sequelizeErrors.TimeoutError(err, {\n          stack: errStack\n        });\n      default:\n        return new sequelizeErrors.DatabaseError(err, {\n          stack: errStack\n        });\n    }\n  }\n  async handleShowIndexesQuery(data) {\n    return Promise.all(data.reverse().map(async item => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      const columns = await this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`);\n      for (const column of columns) {\n        item.fields[column.seqno] = {\n          attribute: column.name,\n          length: void 0,\n          order: void 0\n        };\n      }\n      return item;\n    }));\n  }\n  getDatabaseMethod() {\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes(\"CREATE TEMPORARY TABLE\".toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return \"run\";\n    }\n    return \"all\";\n  }\n}\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;","map":{"version":3,"mappings":"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","names":["_","require","Utils","AbstractQuery","QueryTypes","sequelizeErrors","parserStore","logger","debug","debugContext","value","toString","getInsertIdField","formatBindParameters","sql","values","dialect","bindParam","Array","isArray","forEach","v","i","skipValueReplace","k","Object","keys","_collectModels","include","prefix","ret","_include","key","as","model","merge","_handleQueryResponse","metaData","columnTypes","err","results","errStack","formatError","result","instance","isInsertQuery","isUpsertQuery","handleInsertQuery","constructor","name","autoIncrementAttribute","primaryKeyAttribute","rawAttributes","startId","changes","push","field","isShowTablesQuery","map","row","isShowConstraintsQuery","parseConstraintsFromSql","isSelectQuery","options","raw","handleSelectQuery","prefixes","result2","mapValues","includes","lastind","lastIndexOf","substr","tableName","getTableName","replace","tableTypes","forOwn","attribute","prototype","hasOwnProperty","call","applyParsers","isShowOrDescribeQuery","handleShowIndexesQuery","defaultValue","_result","dflt_value","type","allowNull","notnull","primaryKey","pk","BULKUPDATE","BULKDELETE","VERSION","version","RAW","isUpdateQuery","run","parameters","conn","connection","method","getDatabaseMethod","complete","_logQuery","Promise","resolve","reject","serialize","errForStack","Error","executeSql","startsWith","query","executionError","stack","error","isPlainObject","newParameters","create","stringifyIfBigint","afterExecute","tableNames","exec","filter","length","all","resolve2","constraints","split","referenceTableName","referenceTableKeys","updateAction","deleteAction","splice","constraintSql","match","referencesRegex","referenceConditions","removeTicks","columnNames","column","constraintCondition","constraint","constraintName","constraintType","indexOf","trim","toUpperCase","parse","get","timezone","sequelize","code","message","ForeignKeyConstraintError","parent","fields","columnWithTable","errors","ValidationErrorItem","getUniqueConstraintErrorMessage","uniqueKeys","isEqual","msg","UniqueConstraintError","TimeoutError","DatabaseError","data","reverse","item","primary","unique","columns","seqno","order","isBulkUpdateQuery","toLowerCase","module","exports","Query","default"],"sources":["C:\\Users\\rizla\\projects\\react\\NSBEHack-main\\nsbeapp\\node_modules\\sequelize\\src\\dialects\\sqlite\\query.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst AbstractQuery = require('../abstract/query');\nconst QueryTypes = require('../../query-types');\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('sqlite');\nconst { logger } = require('../../utils/logger');\n\nconst debug = logger.debugContext('sql:sqlite');\n\n// sqlite3 currently ignores bigint values, so we have to translate to string for now\n// There's a WIP here: https://github.com/TryGhost/node-sqlite3/pull/1501\nfunction stringifyIfBigint(value) {\n  if (typeof value === 'bigint') {\n    return value.toString();\n  }\n\n  return value;\n}\n\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return 'lastID';\n  }\n\n  /**\n   * rewrite query with parameters.\n   *\n   * @param {string} sql\n   * @param {Array|object} values\n   * @param {string} dialect\n   * @private\n   */\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam[`$${i + 1}`] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    } else {\n      bindParam = {};\n      if (typeof values === 'object') {\n        for (const k of Object.keys(values)) {\n          bindParam[`$${k}`] = values[k];\n        }\n      }\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    }\n    return [sql, bindParam];\n  }\n\n  _collectModels(include, prefix) {\n    const ret = {};\n\n    if (include) {\n      for (const _include of include) {\n        let key;\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n        ret[key] = _include.model;\n\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  _handleQueryResponse(metaData, columnTypes, err, results, errStack) {\n    if (err) {\n      err.sql = this.sql;\n      throw this.formatError(err, errStack);\n    }\n    let result = this.instance;\n\n    // add the inserted row id to the instance\n    if (this.isInsertQuery(results, metaData) || this.isUpsertQuery()) {\n      this.handleInsertQuery(results, metaData);\n      if (!this.instance) {\n        // handle bulkCreate AI primary key\n        if (\n          metaData.constructor.name === 'Statement'\n          && this.model\n          && this.model.autoIncrementAttribute\n          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute\n          && this.model.rawAttributes[this.model.primaryKeyAttribute]\n        ) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n\n    if (this.isShowTablesQuery()) {\n      return results.map(row => row.name);\n    }\n    if (this.isShowConstraintsQuery()) {\n      result = results;\n      if (results && results[0] && results[0].sql) {\n        result = this.parseConstraintsFromSql(results[0].sql);\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      if (this.options.raw) {\n        return this.handleSelectQuery(results);\n      }\n      // This is a map of prefix strings to models, e.g. user.projects -> Project model\n      const prefixes = this._collectModels(this.options.include);\n\n      results = results.map(result => {\n        return _.mapValues(result, (value, name) => {\n          let model;\n          if (name.includes('.')) {\n            const lastind = name.lastIndexOf('.');\n\n            model = prefixes[name.substr(0, lastind)];\n\n            name = name.substr(lastind + 1);\n          } else {\n            model = this.options.model;\n          }\n\n          const tableName = model.getTableName().toString().replace(/`/g, '');\n          const tableTypes = columnTypes[tableName] || {};\n\n          if (tableTypes && !(name in tableTypes)) {\n            // The column is aliased\n            _.forOwn(model.rawAttributes, (attribute, key) => {\n              if (name === key && attribute.field) {\n                name = attribute.field;\n                return false;\n              }\n            });\n          }\n\n          return Object.prototype.hasOwnProperty.call(tableTypes, name)\n            ? this.applyParsers(tableTypes[name], value)\n            : value;\n        });\n      });\n\n      return this.handleSelectQuery(results);\n    }\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA INDEX_LIST')) {\n      return this.handleShowIndexesQuery(results);\n    }\n    if (this.sql.includes('PRAGMA INDEX_INFO')) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA TABLE_INFO')) {\n      // this is the sqlite way of getting the metadata of a table\n      result = {};\n\n      let defaultValue;\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          // Column schema omits any \"DEFAULT ...\"\n          defaultValue = undefined;\n        } else if (_result.dflt_value === 'NULL') {\n          // Column schema is a \"DEFAULT NULL\"\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0\n        };\n\n        if (result[_result.name].type === 'TINYINT(1)') {\n          result[_result.name].defaultValue = { '0': false, '1': true }[result[_result.name].defaultValue];\n        }\n\n        if (typeof result[_result.name].defaultValue === 'string') {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, '');\n        }\n      }\n      return result;\n    }\n    if (this.sql.includes('PRAGMA foreign_keys;')) {\n      return results[0];\n    }\n    if (this.sql.includes('PRAGMA foreign_keys')) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA foreign_key_list')) {\n      return results;\n    }\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n    if (this.options.type === QueryTypes.VERSION) {\n      return results[0].version;\n    }\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n    if (this.isUpsertQuery()) {\n      return [result, null];\n    }\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n    return result;\n  }\n\n  async run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n    const complete = this._logQuery(sql, debug, parameters);\n\n    return new Promise((resolve, reject) => conn.serialize(async () => {\n      const columnTypes = {};\n      const errForStack = new Error();\n      const executeSql = () => {\n        if (sql.startsWith('-- ')) {\n          return resolve();\n        }\n        const query = this;\n        // cannot use arrow function here because the function is bound to the statement\n        function afterExecute(executionError, results) {\n          try {\n            complete();\n            // `this` is passed from sqlite, we have no control over this.\n            // eslint-disable-next-line no-invalid-this\n            resolve(query._handleQueryResponse(this, columnTypes, executionError, results, errForStack.stack));\n            return;\n          } catch (error) {\n            reject(error);\n          }\n        }\n\n        if (!parameters) parameters = [];\n\n        if (_.isPlainObject(parameters)) {\n          const newParameters = Object.create(null);\n          for (const key of Object.keys(parameters)) {\n            newParameters[`${key}`] = stringifyIfBigint(parameters[key]);\n          }\n          parameters = newParameters;\n        } else {\n          parameters = parameters.map(stringifyIfBigint);\n        }\n\n        conn[method](sql, parameters, afterExecute);\n\n        return null;\n      };\n\n      if (this.getDatabaseMethod() === 'all') {\n        let tableNames = [];\n        if (this.options && this.options.tableNames) {\n          tableNames = this.options.tableNames;\n        } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n          tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n        }\n\n        // If we already have the metadata for the table, there's no need to ask for it again\n        tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== 'sqlite_master');\n\n        if (!tableNames.length) {\n          return executeSql();\n        }\n        await Promise.all(tableNames.map(tableName =>\n          new Promise(resolve => {\n            tableName = tableName.replace(/`/g, '');\n            columnTypes[tableName] = {};\n\n            conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\n              if (!err) {\n                for (const result of results) {\n                  columnTypes[tableName][result.name] = result.type;\n                }\n              }\n              resolve();\n            });\n          })));\n      }\n      return executeSql();\n    }));\n  }\n\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split('CONSTRAINT ');\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map(constraintSql => {\n      //Parse foreign key snippets\n      if (constraintSql.includes('REFERENCES')) {\n        //Parse out the constraint condition form sql string\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(' ');\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, '').split(', ');\n        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));\n      }\n\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, '');\n      const constraint = constraintSql.split(' ');\n\n      if (['PRIMARY', 'FOREIGN'].includes(constraint[1])) {\n        constraint[1] += ' KEY';\n      }\n\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\"/g, '`'), //Sqlite returns double quotes for table name\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n\n    return constraints;\n  }\n\n  applyParsers(type, value) {\n    if (type.includes('(')) {\n      // Remove the length part\n      type = type.substr(0, type.indexOf('('));\n    }\n    type = type.replace('UNSIGNED', '').replace('ZEROFILL', '');\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n\n    if (value !== null && parse) {\n      return parse(value, { timezone: this.sequelize.options.timezone });\n    }\n    return value;\n  }\n\n  formatError(err, errStack) {\n\n    switch (err.code) {\n      case 'SQLITE_CONSTRAINT_UNIQUE':\n      case 'SQLITE_CONSTRAINT_PRIMARYKEY':\n      case 'SQLITE_CONSTRAINT_TRIGGER':\n      case 'SQLITE_CONSTRAINT_FOREIGNKEY':\n      case 'SQLITE_CONSTRAINT': {\n        if (err.message.includes('FOREIGN KEY constraint failed')) {\n          return new sequelizeErrors.ForeignKeyConstraintError({\n            parent: err,\n            stack: errStack\n          });\n        }\n\n        let fields = [];\n\n        // Sqlite pre 2.2 behavior - Error: SQLITE_CONSTRAINT: columns x, y are not unique\n        let match = err.message.match(/columns (.*?) are/);\n        if (match !== null && match.length >= 2) {\n          fields = match[1].split(', ');\n        } else {\n\n          // Sqlite post 2.2 behavior - Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: table.x, table.y\n          match = err.message.match(/UNIQUE constraint failed: (.*)/);\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(', ').map(columnWithTable => columnWithTable.split('.')[1]);\n          }\n        }\n\n        const errors = [];\n        let message = 'Validation error';\n\n        for (const field of fields) {\n          errors.push(new sequelizeErrors.ValidationErrorItem(\n            this.getUniqueConstraintErrorMessage(field),\n            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n            field,\n            this.instance && this.instance[field],\n            this.instance,\n            'not_unique'\n          ));\n        }\n\n        if (this.model) {\n          _.forOwn(this.model.uniqueKeys, constraint => {\n            if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n              message = constraint.msg;\n              return false;\n            }\n          });\n        }\n\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields, stack: errStack });\n      }\n      case 'SQLITE_BUSY':\n        return new sequelizeErrors.TimeoutError(err, { stack: errStack });\n\n      default:\n        return new sequelizeErrors.DatabaseError(err, { stack: errStack });\n    }\n  }\n\n  async handleShowIndexesQuery(data) {\n    // Sqlite returns indexes so the one that was defined last is returned first. Lets reverse that!\n    return Promise.all(data.reverse().map(async item => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      const columns = await this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`);\n      for (const column of columns) {\n        item.fields[column.seqno] = {\n          attribute: column.name,\n          length: undefined,\n          order: undefined\n        };\n      }\n\n      return item;\n    }));\n  }\n\n  getDatabaseMethod() {\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isUpsertQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes('CREATE TEMPORARY TABLE'.toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return 'run';\n    }\n    return 'all';\n  }\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}