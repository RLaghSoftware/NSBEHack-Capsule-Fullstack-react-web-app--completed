{"ast":null,"code":"\"use strict\";\n\nfunction checkNamingCollision(association) {\n  if (Object.prototype.hasOwnProperty.call(association.source.rawAttributes, association.as)) {\n    throw new Error(`Naming collision between attribute '${association.as}' and association '${association.as}' on model ${association.source.name}. To remedy this, change either foreignKey or as in your association definition`);\n  }\n}\nexports.checkNamingCollision = checkNamingCollision;\nfunction addForeignKeyConstraints(newAttribute, source, target, options, key) {\n  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {\n    const primaryKeys = Object.keys(source.primaryKeys).map(primaryKeyAttribute => source.rawAttributes[primaryKeyAttribute].field || primaryKeyAttribute);\n    if (primaryKeys.length === 1 || !primaryKeys.includes(key)) {\n      newAttribute.references = {\n        model: source.getTableName(),\n        key: key || primaryKeys[0]\n      };\n      newAttribute.onDelete = options.onDelete;\n      newAttribute.onUpdate = options.onUpdate;\n    }\n  }\n}\nexports.addForeignKeyConstraints = addForeignKeyConstraints;\nfunction mixinMethods(association, obj, methods, aliases) {\n  aliases = aliases || {};\n  for (const method of methods) {\n    if (!Object.prototype.hasOwnProperty.call(obj, association.accessors[method])) {\n      const realMethod = aliases[method] || method;\n      obj[association.accessors[method]] = function () {\n        return association[realMethod](this, ...Array.from(arguments));\n      };\n    }\n  }\n}\nexports.mixinMethods = mixinMethods;","map":{"version":3,"mappings":";;AAEA,8BAA8BA,aAAa;EACzC,IAAIC,OAAOC,UAAUC,eAAeC,KAAKJ,YAAYK,OAAOC,eAAeN,YAAYO,KAAK;IAC1F,MAAM,IAAIC,MACR,uCAAuCR,YAAYO,wBAC9BP,YAAYO,gBAAgBP,YAAYK,OAAOI;EAAA;AAAA;AAK1EC,QAAQC,uBAAuBA;AAE/B,kCAAkCC,cAAcP,QAAQQ,QAAQC,SAASC,KAAK;EAI5E,IAAID,QAAQE,wBAAwBF,QAAQG,YAAYH,QAAQI,UAAU;IAExE,MAAMC,cAAclB,OAAOmB,KAAKf,OAAOc,aACpCE,IAAIC,uBAAuBjB,OAAOC,cAAcgB,qBAAqBC,SAASD;IAEjF,IAAIH,YAAYK,WAAW,KAAK,CAACL,YAAYM,SAASV,MAAM;MAC1DH,aAAac,aAAa;QACxBC,OAAOtB,OAAOuB;QACdb,KAAKA,OAAOI,YAAY;MAAA;MAG1BP,aAAaK,WAAWH,QAAQG;MAChCL,aAAaM,WAAWJ,QAAQI;IAAA;EAAA;AAAA;AAItCR,QAAQmB,2BAA2BA;AAanC,sBAAsB7B,aAAa8B,KAAKC,SAASC,SAAS;EACxDA,UAAUA,WAAW;EAErB,WAAWC,UAAUF,SAAS;IAE5B,IAAI,CAAC9B,OAAOC,UAAUC,eAAeC,KAAK0B,KAAK9B,YAAYkC,UAAUD,UAAU;MAC7E,MAAME,aAAaH,QAAQC,WAAWA;MAEtCH,IAAI9B,YAAYkC,UAAUD,WAAW,YAAW;QAC9C,OAAOjC,YAAYmC,YAAY,MAAM,GAAGC,MAAMC,KAAKC;MAAA;IAAA;EAAA;AAAA;AAK3D5B,QAAQ6B,eAAeA","names":["association","Object","prototype","hasOwnProperty","call","source","rawAttributes","as","Error","name","exports","checkNamingCollision","newAttribute","target","options","key","foreignKeyConstraint","onDelete","onUpdate","primaryKeys","keys","map","primaryKeyAttribute","field","length","includes","references","model","getTableName","addForeignKeyConstraints","obj","methods","aliases","method","accessors","realMethod","Array","from","arguments","mixinMethods"],"sources":["C:\\Users\\rizla\\projects\\react\\NSBEHack-main\\nsbeapp\\node_modules\\sequelize\\src\\associations\\helpers.js"],"sourcesContent":["'use strict';\n\nfunction checkNamingCollision(association) {\n  if (Object.prototype.hasOwnProperty.call(association.source.rawAttributes, association.as)) {\n    throw new Error(\n      `Naming collision between attribute '${association.as}'` +\n      ` and association '${association.as}' on model ${association.source.name}` +\n      '. To remedy this, change either foreignKey or as in your association definition'\n    );\n  }\n}\nexports.checkNamingCollision = checkNamingCollision;\n\nfunction addForeignKeyConstraints(newAttribute, source, target, options, key) {\n  // FK constraints are opt-in: users must either set `foreignKeyConstraints`\n  // on the association, or request an `onDelete` or `onUpdate` behavior\n\n  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {\n    // Find primary keys: composite keys not supported with this approach\n    const primaryKeys = Object.keys(source.primaryKeys)\n      .map(primaryKeyAttribute => source.rawAttributes[primaryKeyAttribute].field || primaryKeyAttribute);\n\n    if (primaryKeys.length === 1 || !primaryKeys.includes(key)) {\n      newAttribute.references = {\n        model: source.getTableName(),\n        key: key || primaryKeys[0]\n      };\n\n      newAttribute.onDelete = options.onDelete;\n      newAttribute.onUpdate = options.onUpdate;\n    }\n  }\n}\nexports.addForeignKeyConstraints = addForeignKeyConstraints;\n\n/**\n * Mixin (inject) association methods to model prototype\n *\n * @private\n *\n * @param {object} association instance\n * @param {object} obj Model prototype\n * @param {Array} methods Method names to inject\n * @param {object} aliases Mapping between model and association method names\n *\n */\nfunction mixinMethods(association, obj, methods, aliases) {\n  aliases = aliases || {};\n\n  for (const method of methods) {\n    // don't override custom methods\n    if (!Object.prototype.hasOwnProperty.call(obj, association.accessors[method])) {\n      const realMethod = aliases[method] || method;\n\n      obj[association.accessors[method]] = function() {\n        return association[realMethod](this, ...Array.from(arguments));\n      };\n    }\n  }\n}\nexports.mixinMethods = mixinMethods;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}