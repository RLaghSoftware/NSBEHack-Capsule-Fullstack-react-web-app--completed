{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst Utils = require(\"./../utils\");\nconst Helpers = require(\"./helpers\");\nconst _ = require(\"lodash\");\nconst Association = require(\"./base\");\nconst BelongsTo = require(\"./belongs-to\");\nconst HasMany = require(\"./has-many\");\nconst HasOne = require(\"./has-one\");\nconst AssociationError = require(\"../errors\").AssociationError;\nconst EmptyResultError = require(\"../errors\").EmptyResultError;\nconst Op = require(\"../operators\");\nclass BelongsToMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    if (this.options.through === void 0 || this.options.through === true || this.options.through === null) {\n      throw new AssociationError(`${source.name}.belongsToMany(${target.name}) requires through option, pass either a string or a model`);\n    }\n    if (!this.options.through.model) {\n      this.options.through = {\n        model: options.through\n      };\n    }\n    this.associationType = \"BelongsToMany\";\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.through = __spreadValues({}, this.options.through);\n    this.isMultiAssociation = true;\n    this.doubleLinked = false;\n    if (!this.as && this.isSelfAssociation) {\n      throw new AssociationError(\"'as' must be defined for many-to-many self-associations\");\n    }\n    if (this.as) {\n      this.isAliased = true;\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n    this.combinedTableName = Utils.combineTableNames(this.source.tableName, this.isSelfAssociation ? this.as || this.target.tableName : this.target.tableName);\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n    _.each(this.target.associations, association => {\n      if (association.associationType !== \"BelongsToMany\") return;\n      if (association.target !== this.source) return;\n      if (this.options.through.model === association.options.through.model) {\n        this.paired = association;\n        association.paired = this;\n      }\n    });\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n    if (this.options.targetKey) {\n      this.targetKey = this.options.targetKey;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    } else {\n      this.targetKeyDefault = true;\n      this.targetKey = this.target.primaryKeyAttribute;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    }\n    this._createForeignAndOtherKeys();\n    if (typeof this.through.model === \"string\") {\n      if (!this.sequelize.isDefined(this.through.model)) {\n        this.through.model = this.sequelize.define(this.through.model, {}, Object.assign(this.options, {\n          tableName: this.through.model,\n          indexes: [],\n          paranoid: this.through.paranoid ? this.through.paranoid : false,\n          validate: {}\n        }));\n      } else {\n        this.through.model = this.sequelize.model(this.through.model);\n      }\n    }\n    Object.assign(this.options, _.pick(this.through.model.options, [\"timestamps\", \"createdAt\", \"updatedAt\", \"deletedAt\", \"paranoid\"]));\n    if (this.paired) {\n      let needInjectPaired = false;\n      if (this.targetKeyDefault) {\n        this.targetKey = this.paired.sourceKey;\n        this.targetKeyField = this.paired.sourceKeyField;\n        this._createForeignAndOtherKeys();\n      }\n      if (this.paired.targetKeyDefault) {\n        if (this.paired.targetKey !== this.sourceKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.targetKey = this.sourceKey;\n          this.paired.targetKeyField = this.sourceKeyField;\n          this.paired._createForeignAndOtherKeys();\n          needInjectPaired = true;\n        }\n      }\n      if (this.otherKeyDefault) {\n        this.otherKey = this.paired.foreignKey;\n      }\n      if (this.paired.otherKeyDefault) {\n        if (this.paired.otherKey !== this.foreignKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.otherKey = this.foreignKey;\n          needInjectPaired = true;\n        }\n      }\n      if (needInjectPaired) {\n        this.paired._injectAttributes();\n      }\n    }\n    if (this.through) {\n      this.throughModel = this.through.model;\n    }\n    this.options.tableName = this.combinedName = this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model;\n    this.associationAccessor = this.as;\n    const plural = _.upperFirst(this.options.name.plural);\n    const singular = _.upperFirst(this.options.name.singular);\n    this.accessors = {\n      get: `get${plural}`,\n      set: `set${plural}`,\n      addMultiple: `add${plural}`,\n      add: `add${singular}`,\n      create: `create${singular}`,\n      remove: `remove${singular}`,\n      removeMultiple: `remove${plural}`,\n      hasSingle: `has${singular}`,\n      hasAll: `has${plural}`,\n      count: `count${plural}`\n    };\n  }\n  _createForeignAndOtherKeys() {\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else {\n      this.foreignKeyAttribute = {};\n      this.foreignKey = this.options.foreignKey || Utils.camelize([this.source.options.name.singular, this.sourceKey].join(\"_\"));\n    }\n    if (_.isObject(this.options.otherKey)) {\n      this.otherKeyAttribute = this.options.otherKey;\n      this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;\n    } else {\n      if (!this.options.otherKey) {\n        this.otherKeyDefault = true;\n      }\n      this.otherKeyAttribute = {};\n      this.otherKey = this.options.otherKey || Utils.camelize([this.isSelfAssociation ? Utils.singularize(this.as) : this.target.options.name.singular, this.targetKey].join(\"_\"));\n    }\n  }\n  _injectAttributes() {\n    this.identifier = this.foreignKey;\n    this.foreignIdentifier = this.otherKey;\n    _.each(this.through.model.rawAttributes, (attribute, attributeName) => {\n      if (attribute.primaryKey === true && attribute._autoGenerated === true) {\n        if ([this.foreignKey, this.otherKey].includes(attributeName)) {\n          attribute.primaryKey = false;\n        } else {\n          delete this.through.model.rawAttributes[attributeName];\n        }\n        this.primaryKeyDeleted = true;\n      }\n    });\n    const sourceKey = this.source.rawAttributes[this.sourceKey];\n    const sourceKeyType = sourceKey.type;\n    const sourceKeyField = this.sourceKeyField;\n    const targetKey = this.target.rawAttributes[this.targetKey];\n    const targetKeyType = targetKey.type;\n    const targetKeyField = this.targetKeyField;\n    const sourceAttribute = __spreadValues({\n      type: sourceKeyType\n    }, this.foreignKeyAttribute);\n    const targetAttribute = __spreadValues({\n      type: targetKeyType\n    }, this.otherKeyAttribute);\n    if (this.primaryKeyDeleted === true) {\n      targetAttribute.primaryKey = sourceAttribute.primaryKey = true;\n    } else if (this.through.unique !== false) {\n      let uniqueKey;\n      if (typeof this.options.uniqueKey === \"string\" && this.options.uniqueKey !== \"\") {\n        uniqueKey = this.options.uniqueKey;\n      } else {\n        uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, \"unique\"].join(\"_\");\n      }\n      targetAttribute.unique = sourceAttribute.unique = uniqueKey;\n    }\n    if (!this.through.model.rawAttributes[this.foreignKey]) {\n      this.through.model.rawAttributes[this.foreignKey] = {\n        _autoGenerated: true\n      };\n    }\n    if (!this.through.model.rawAttributes[this.otherKey]) {\n      this.through.model.rawAttributes[this.otherKey] = {\n        _autoGenerated: true\n      };\n    }\n    if (this.options.constraints !== false) {\n      sourceAttribute.references = {\n        model: this.source.getTableName(),\n        key: sourceKeyField\n      };\n      sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;\n      sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;\n      if (!sourceAttribute.onDelete) sourceAttribute.onDelete = \"CASCADE\";\n      if (!sourceAttribute.onUpdate) sourceAttribute.onUpdate = \"CASCADE\";\n      targetAttribute.references = {\n        model: this.target.getTableName(),\n        key: targetKeyField\n      };\n      targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;\n      targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;\n      if (!targetAttribute.onDelete) targetAttribute.onDelete = \"CASCADE\";\n      if (!targetAttribute.onUpdate) targetAttribute.onUpdate = \"CASCADE\";\n    }\n    Object.assign(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);\n    Object.assign(this.through.model.rawAttributes[this.otherKey], targetAttribute);\n    this.through.model.refreshAttributes();\n    this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;\n    if (this.options.sequelize.options.dialect === \"db2\" && this.source.rawAttributes[this.sourceKey].primaryKey !== true) {\n      this.source.rawAttributes[this.sourceKey].unique = true;\n    }\n    if (this.paired && !this.paired.foreignIdentifierField) {\n      this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;\n    }\n    this.toSource = new BelongsTo(this.through.model, this.source, {\n      foreignKey: this.foreignKey\n    });\n    this.manyFromSource = new HasMany(this.source, this.through.model, {\n      foreignKey: this.foreignKey\n    });\n    this.oneFromSource = new HasOne(this.source, this.through.model, {\n      foreignKey: this.foreignKey,\n      sourceKey: this.sourceKey,\n      as: this.through.model.name\n    });\n    this.toTarget = new BelongsTo(this.through.model, this.target, {\n      foreignKey: this.otherKey\n    });\n    this.manyFromTarget = new HasMany(this.target, this.through.model, {\n      foreignKey: this.otherKey\n    });\n    this.oneFromTarget = new HasOne(this.target, this.through.model, {\n      foreignKey: this.otherKey,\n      sourceKey: this.targetKey,\n      as: this.through.model.name\n    });\n    if (this.paired && this.paired.otherKeyDefault) {\n      this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {\n        foreignKey: this.paired.otherKey\n      });\n      this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {\n        foreignKey: this.paired.otherKey,\n        sourceKey: this.paired.targetKey,\n        as: this.paired.through.model.name\n      });\n    }\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n  mixin(obj) {\n    const methods = [\"get\", \"count\", \"hasSingle\", \"hasAll\", \"set\", \"add\", \"addMultiple\", \"remove\", \"removeMultiple\", \"create\"];\n    const aliases = {\n      hasSingle: \"has\",\n      hasAll: \"has\",\n      addMultiple: \"add\",\n      removeMultiple: \"remove\"\n    };\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n  async get(instance, options) {\n    options = Utils.cloneDeep(options) || {};\n    const through = this.through;\n    let scopeWhere;\n    let throughWhere;\n    if (this.scope) {\n      scopeWhere = __spreadValues({}, this.scope);\n    }\n    options.where = {\n      [Op.and]: [scopeWhere, options.where]\n    };\n    if (Object(through.model) === through.model) {\n      throughWhere = {};\n      throughWhere[this.foreignKey] = instance.get(this.sourceKey);\n      if (through.scope) {\n        Object.assign(throughWhere, through.scope);\n      }\n      if (options.through && options.through.where) {\n        throughWhere = {\n          [Op.and]: [throughWhere, options.through.where]\n        };\n      }\n      options.include = options.include || [];\n      options.include.push({\n        association: this.oneFromTarget,\n        attributes: options.joinTableAttributes,\n        required: true,\n        paranoid: _.get(options.through, \"paranoid\", true),\n        where: throughWhere\n      });\n    }\n    let model = this.target;\n    if (Object.prototype.hasOwnProperty.call(options, \"scope\")) {\n      if (!options.scope) {\n        model = model.unscoped();\n      } else {\n        model = model.scope(options.scope);\n      }\n    }\n    if (Object.prototype.hasOwnProperty.call(options, \"schema\")) {\n      model = model.schema(options.schema, options.schemaDelimiter);\n    }\n    return model.findAll(options);\n  }\n  async count(instance, options) {\n    const sequelize = this.target.sequelize;\n    options = Utils.cloneDeep(options);\n    options.attributes = [[sequelize.fn(\"COUNT\", sequelize.col([this.target.name, this.targetKeyField].join(\".\"))), \"count\"]];\n    options.joinTableAttributes = [];\n    options.raw = true;\n    options.plain = true;\n    const result = await this.get(instance, options);\n    return parseInt(result.count, 10);\n  }\n  async has(sourceInstance, instances, options) {\n    if (!Array.isArray(instances)) {\n      instances = [instances];\n    }\n    options = __spreadProps(__spreadValues({\n      raw: true\n    }, options), {\n      scope: false,\n      attributes: [this.targetKey],\n      joinTableAttributes: []\n    });\n    const instancePrimaryKeys = instances.map(instance => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n      return {\n        [this.targetKey]: instance\n      };\n    });\n    options.where = {\n      [Op.and]: [{\n        [Op.or]: instancePrimaryKeys\n      }, options.where]\n    };\n    const associatedObjects = await this.get(sourceInstance, options);\n    return _.differenceWith(instancePrimaryKeys, associatedObjects, (a, b) => _.isEqual(a[this.targetKey], b[this.targetKey])).length === 0;\n  }\n  async set(sourceInstance, newAssociatedObjects, options) {\n    options = options || {};\n    const sourceKey = this.sourceKey;\n    const targetKey = this.targetKey;\n    const identifier = this.identifier;\n    const foreignIdentifier = this.foreignIdentifier;\n    if (newAssociatedObjects === null) {\n      newAssociatedObjects = [];\n    } else {\n      newAssociatedObjects = this.toInstanceArray(newAssociatedObjects);\n    }\n    const where = __spreadValues({\n      [identifier]: sourceInstance.get(sourceKey)\n    }, this.through.scope);\n    const updateAssociations = currentRows => {\n      const obsoleteAssociations = [];\n      const promises = [];\n      const defaultAttributes = options.through || {};\n      const unassociatedObjects = newAssociatedObjects.filter(obj => !currentRows.some(currentRow => currentRow[foreignIdentifier] === obj.get(targetKey)));\n      for (const currentRow of currentRows) {\n        const newObj = newAssociatedObjects.find(obj => currentRow[foreignIdentifier] === obj.get(targetKey));\n        if (!newObj) {\n          obsoleteAssociations.push(currentRow);\n        } else {\n          let throughAttributes = newObj[this.through.model.name];\n          if (throughAttributes instanceof this.through.model) {\n            throughAttributes = {};\n          }\n          const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);\n          if (Object.keys(attributes).length) {\n            promises.push(this.through.model.update(attributes, Object.assign(options, {\n              where: {\n                [identifier]: sourceInstance.get(sourceKey),\n                [foreignIdentifier]: newObj.get(targetKey)\n              }\n            })));\n          }\n        }\n      }\n      if (obsoleteAssociations.length > 0) {\n        promises.push(this.through.model.destroy(__spreadProps(__spreadValues({}, options), {\n          where: __spreadValues({\n            [identifier]: sourceInstance.get(sourceKey),\n            [foreignIdentifier]: obsoleteAssociations.map(obsoleteAssociation => obsoleteAssociation[foreignIdentifier])\n          }, this.through.scope)\n        })));\n      }\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          return __spreadValues(__spreadProps(__spreadValues(__spreadValues({}, defaultAttributes), unassociatedObject[this.through.model.name]), {\n            [identifier]: sourceInstance.get(sourceKey),\n            [foreignIdentifier]: unassociatedObject.get(targetKey)\n          }), this.through.scope);\n        });\n        promises.push(this.through.model.bulkCreate(bulk, __spreadValues({\n          validate: true\n        }, options)));\n      }\n      return Promise.all(promises);\n    };\n    try {\n      const currentRows = await this.through.model.findAll(__spreadProps(__spreadValues({}, options), {\n        where,\n        raw: true\n      }));\n      return await updateAssociations(currentRows);\n    } catch (error) {\n      if (error instanceof EmptyResultError) return updateAssociations([]);\n      throw error;\n    }\n  }\n  async add(sourceInstance, newInstances, options) {\n    if (!newInstances) return Promise.resolve();\n    options = __spreadValues({}, options);\n    const association = this;\n    const sourceKey = association.sourceKey;\n    const targetKey = association.targetKey;\n    const identifier = association.identifier;\n    const foreignIdentifier = association.foreignIdentifier;\n    const defaultAttributes = options.through || {};\n    newInstances = association.toInstanceArray(newInstances);\n    const where = __spreadValues({\n      [identifier]: sourceInstance.get(sourceKey),\n      [foreignIdentifier]: newInstances.map(newInstance => newInstance.get(targetKey))\n    }, association.through.scope);\n    const updateAssociations = currentRows => {\n      const promises = [];\n      const unassociatedObjects = [];\n      const changedAssociations = [];\n      for (const obj of newInstances) {\n        const existingAssociation = currentRows && currentRows.find(current => current[foreignIdentifier] === obj.get(targetKey));\n        if (!existingAssociation) {\n          unassociatedObjects.push(obj);\n        } else {\n          const throughAttributes = obj[association.through.model.name];\n          const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);\n          if (Object.keys(attributes).some(attribute => attributes[attribute] !== existingAssociation[attribute])) {\n            changedAssociations.push(obj);\n          }\n        }\n      }\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          const throughAttributes = unassociatedObject[association.through.model.name];\n          const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n          Object.assign(attributes, association.through.scope);\n          return attributes;\n        });\n        promises.push(association.through.model.bulkCreate(bulk, __spreadValues({\n          validate: true\n        }, options)));\n      }\n      for (const assoc of changedAssociations) {\n        let throughAttributes = assoc[association.through.model.name];\n        const attributes = __spreadValues(__spreadValues({}, defaultAttributes), throughAttributes);\n        if (throughAttributes instanceof association.through.model) {\n          throughAttributes = {};\n        }\n        promises.push(association.through.model.update(attributes, Object.assign(options, {\n          where: {\n            [identifier]: sourceInstance.get(sourceKey),\n            [foreignIdentifier]: assoc.get(targetKey)\n          }\n        })));\n      }\n      return Promise.all(promises);\n    };\n    try {\n      const currentRows = await association.through.model.findAll(__spreadProps(__spreadValues({}, options), {\n        where,\n        raw: true\n      }));\n      const [associations] = await updateAssociations(currentRows);\n      return associations;\n    } catch (error) {\n      if (error instanceof EmptyResultError) return updateAssociations();\n      throw error;\n    }\n  }\n  remove(sourceInstance, oldAssociatedObjects, options) {\n    const association = this;\n    options = options || {};\n    oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);\n    const where = {\n      [association.identifier]: sourceInstance.get(association.sourceKey),\n      [association.foreignIdentifier]: oldAssociatedObjects.map(newInstance => newInstance.get(association.targetKey))\n    };\n    return association.through.model.destroy(__spreadProps(__spreadValues({}, options), {\n      where\n    }));\n  }\n  async create(sourceInstance, values, options) {\n    const association = this;\n    options = options || {};\n    values = values || {};\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n    if (association.scope) {\n      Object.assign(values, association.scope);\n      if (options.fields) {\n        options.fields = options.fields.concat(Object.keys(association.scope));\n      }\n    }\n    const newAssociatedObject = await association.target.create(values, options);\n    await sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, [\"fields\"]));\n    return newAssociatedObject;\n  }\n  verifyAssociationAlias(alias) {\n    if (typeof alias === \"string\") {\n      return this.as === alias;\n    }\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n    return !this.isAliased;\n  }\n}\nmodule.exports = BelongsToMany;\nmodule.exports.BelongsToMany = BelongsToMany;\nmodule.exports.default = BelongsToMany;","map":{"version":3,"mappings":"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","names":["Utils","require","Helpers","_","Association","BelongsTo","HasMany","HasOne","AssociationError","EmptyResultError","Op","constructor","source","target","options","through","name","model","associationType","targetAssociation","sequelize","__spreadValues","isMultiAssociation","doubleLinked","as","isSelfAssociation","isAliased","isPlainObject","plural","singular","singularize","combinedTableName","combineTableNames","tableName","each","associations","association","paired","sourceKey","primaryKeyAttribute","sourceKeyField","rawAttributes","field","targetKey","targetKeyField","targetKeyDefault","_createForeignAndOtherKeys","isDefined","define","Object","assign","indexes","paranoid","validate","pick","needInjectPaired","otherKey","otherKeyDefault","foreignKey","_injectAttributes","throughModel","combinedName","associationAccessor","upperFirst","accessors","get","set","addMultiple","add","create","remove","removeMultiple","hasSingle","hasAll","count","isObject","foreignKeyAttribute","fieldName","camelize","join","otherKeyAttribute","identifier","foreignIdentifier","attribute","attributeName","primaryKey","_autoGenerated","includes","primaryKeyDeleted","sourceKeyType","type","targetKeyType","sourceAttribute","targetAttribute","unique","uniqueKey","constraints","references","getTableName","key","onDelete","onUpdate","refreshAttributes","identifierField","foreignIdentifierField","dialect","toSource","manyFromSource","oneFromSource","toTarget","manyFromTarget","oneFromTarget","checkNamingCollision","mixin","obj","methods","aliases","mixinMethods","instance","cloneDeep","scopeWhere","throughWhere","scope","where","and","include","push","attributes","joinTableAttributes","required","prototype","hasOwnProperty","call","unscoped","schema","schemaDelimiter","findAll","fn","col","raw","plain","result","parseInt","has","sourceInstance","instances","Array","isArray","__spreadProps","instancePrimaryKeys","map","or","associatedObjects","differenceWith","a","b","isEqual","length","newAssociatedObjects","toInstanceArray","updateAssociations","currentRows","obsoleteAssociations","promises","defaultAttributes","unassociatedObjects","filter","some","currentRow","newObj","find","throughAttributes","keys","update","destroy","obsoleteAssociation","bulk","unassociatedObject","bulkCreate","Promise","all","error","newInstances","resolve","newInstance","changedAssociations","existingAssociation","current","assoc","oldAssociatedObjects","values","fields","concat","newAssociatedObject","omit","verifyAssociationAlias","alias","module","exports","BelongsToMany","default"],"sources":["C:\\Users\\rizla\\projects\\react\\NSBEHack-main\\nsbeapp\\node_modules\\sequelize\\src\\associations\\belongs-to-many.js"],"sourcesContent":["'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst BelongsTo = require('./belongs-to');\nconst HasMany = require('./has-many');\nconst HasOne = require('./has-one');\nconst AssociationError = require('../errors').AssociationError;\nconst EmptyResultError = require('../errors').EmptyResultError;\nconst Op = require('../operators');\n\n/**\n * Many-to-many association with a join table.\n *\n * When the join table has additional attributes, these can be passed in the options object:\n *\n * ```js\n * UserProject = sequelize.define('user_project', {\n *   role: Sequelize.STRING\n * });\n * User.belongsToMany(Project, { through: UserProject });\n * Project.belongsToMany(User, { through: UserProject });\n * // through is required!\n *\n * user.addProject(project, { through: { role: 'manager' }});\n * ```\n *\n * All methods allow you to pass either a persisted instance, its primary key, or a mixture:\n *\n * ```js\n * const project = await Project.create({ id: 11 });\n * await user.addProjects([project, 12]);\n * ```\n *\n * If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:\n *\n * ```js\n * p1.UserProjects = {\n *   started: true\n * }\n * user.setProjects([p1, p2], { through: { started: false }}) // The default value is false, but p1 overrides that.\n * ```\n *\n * Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model.\n * ```js\n * const projects = await user.getProjects();\n * const p1 = projects[0];\n * p1.UserProjects.started // Is this project started yet?\n * ```\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.belongsToMany(Project)` the getter will be `user.getProjects()`.\n *\n * @see {@link Model.belongsToMany}\n */\nclass BelongsToMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    if (this.options.through === undefined || this.options.through === true || this.options.through === null) {\n      throw new AssociationError(`${source.name}.belongsToMany(${target.name}) requires through option, pass either a string or a model`);\n    }\n\n    if (!this.options.through.model) {\n      this.options.through = {\n        model: options.through\n      };\n    }\n\n    this.associationType = 'BelongsToMany';\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.through = { ...this.options.through };\n    this.isMultiAssociation = true;\n    this.doubleLinked = false;\n\n    if (!this.as && this.isSelfAssociation) {\n      throw new AssociationError('\\'as\\' must be defined for many-to-many self-associations');\n    }\n\n    if (this.as) {\n      this.isAliased = true;\n\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n\n    this.combinedTableName = Utils.combineTableNames(\n      this.source.tableName,\n      this.isSelfAssociation ? this.as || this.target.tableName : this.target.tableName\n    );\n\n    /*\n    * If self association, this is the target association - Unless we find a pairing association\n    */\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n\n    /*\n    * Find paired association (if exists)\n    */\n    _.each(this.target.associations, association => {\n      if (association.associationType !== 'BelongsToMany') return;\n      if (association.target !== this.source) return;\n\n      if (this.options.through.model === association.options.through.model) {\n        this.paired = association;\n        association.paired = this;\n      }\n    });\n\n    /*\n    * Default/generated source/target keys\n    */\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n\n    if (this.options.targetKey) {\n      this.targetKey = this.options.targetKey;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    } else {\n      this.targetKeyDefault = true;\n      this.targetKey = this.target.primaryKeyAttribute;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    }\n\n    this._createForeignAndOtherKeys();\n\n    if (typeof this.through.model === 'string') {\n      if (!this.sequelize.isDefined(this.through.model)) {\n        this.through.model = this.sequelize.define(this.through.model, {}, Object.assign(this.options, {\n          tableName: this.through.model,\n          indexes: [], //we don't want indexes here (as referenced in #2416)\n          paranoid: this.through.paranoid ? this.through.paranoid : false, // Default to non-paranoid join (referenced in #11991)\n          validate: {} // Don't propagate model-level validations\n        }));\n      } else {\n        this.through.model = this.sequelize.model(this.through.model);\n      }\n    }\n\n    Object.assign(this.options, _.pick(this.through.model.options, [\n      'timestamps', 'createdAt', 'updatedAt', 'deletedAt', 'paranoid'\n    ]));\n\n    if (this.paired) {\n      let needInjectPaired = false;\n\n      if (this.targetKeyDefault) {\n        this.targetKey = this.paired.sourceKey;\n        this.targetKeyField = this.paired.sourceKeyField;\n        this._createForeignAndOtherKeys();\n      }\n      if (this.paired.targetKeyDefault) {\n        // in this case paired.otherKey depends on paired.targetKey,\n        // so cleanup previously wrong generated otherKey\n        if (this.paired.targetKey !== this.sourceKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.targetKey = this.sourceKey;\n          this.paired.targetKeyField = this.sourceKeyField;\n          this.paired._createForeignAndOtherKeys();\n          needInjectPaired = true;\n        }\n      }\n\n      if (this.otherKeyDefault) {\n        this.otherKey = this.paired.foreignKey;\n      }\n      if (this.paired.otherKeyDefault) {\n        // If paired otherKey was inferred we should make sure to clean it up\n        // before adding a new one that matches the foreignKey\n        if (this.paired.otherKey !== this.foreignKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.otherKey = this.foreignKey;\n          needInjectPaired = true;\n        }\n      }\n\n      if (needInjectPaired) {\n        this.paired._injectAttributes();\n      }\n    }\n\n    if (this.through) {\n      this.throughModel = this.through.model;\n    }\n\n    this.options.tableName = this.combinedName = this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model;\n\n    this.associationAccessor = this.as;\n\n    // Get singular and plural names, trying to uppercase the first letter, unless the model forbids it\n    const plural = _.upperFirst(this.options.name.plural);\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: `get${plural}`,\n      set: `set${plural}`,\n      addMultiple: `add${plural}`,\n      add: `add${singular}`,\n      create: `create${singular}`,\n      remove: `remove${singular}`,\n      removeMultiple: `remove${plural}`,\n      hasSingle: `has${singular}`,\n      hasAll: `has${plural}`,\n      count: `count${plural}`\n    };\n  }\n\n  _createForeignAndOtherKeys() {\n    /*\n    * Default/generated foreign/other keys\n    */\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else {\n      this.foreignKeyAttribute = {};\n      this.foreignKey = this.options.foreignKey || Utils.camelize(\n        [\n          this.source.options.name.singular,\n          this.sourceKey\n        ].join('_')\n      );\n    }\n\n    if (_.isObject(this.options.otherKey)) {\n      this.otherKeyAttribute = this.options.otherKey;\n      this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;\n    } else {\n      if (!this.options.otherKey) {\n        this.otherKeyDefault = true;\n      }\n\n      this.otherKeyAttribute = {};\n      this.otherKey = this.options.otherKey || Utils.camelize(\n        [\n          this.isSelfAssociation ? Utils.singularize(this.as) : this.target.options.name.singular,\n          this.targetKey\n        ].join('_')\n      );\n    }\n  }\n\n  // the id is in the target table\n  // or in an extra table which connects two tables\n  _injectAttributes() {\n    this.identifier = this.foreignKey;\n    this.foreignIdentifier = this.otherKey;\n\n    // remove any PKs previously defined by sequelize\n    // but ignore any keys that are part of this association (#5865)\n    _.each(this.through.model.rawAttributes, (attribute, attributeName) => {\n      if (attribute.primaryKey === true && attribute._autoGenerated === true) {\n        if ([this.foreignKey, this.otherKey].includes(attributeName)) {\n          // this key is still needed as it's part of the association\n          // so just set primaryKey to false\n          attribute.primaryKey = false;\n        }\n        else {\n          delete this.through.model.rawAttributes[attributeName];\n        }\n        this.primaryKeyDeleted = true;\n      }\n    });\n\n    const sourceKey = this.source.rawAttributes[this.sourceKey];\n    const sourceKeyType = sourceKey.type;\n    const sourceKeyField = this.sourceKeyField;\n    const targetKey = this.target.rawAttributes[this.targetKey];\n    const targetKeyType = targetKey.type;\n    const targetKeyField = this.targetKeyField;\n    const sourceAttribute = { type: sourceKeyType, ...this.foreignKeyAttribute };\n    const targetAttribute = { type: targetKeyType, ...this.otherKeyAttribute };\n\n    if (this.primaryKeyDeleted === true) {\n      targetAttribute.primaryKey = sourceAttribute.primaryKey = true;\n    } else if (this.through.unique !== false) {\n      let uniqueKey;\n      if (typeof this.options.uniqueKey === 'string' && this.options.uniqueKey !== '') {\n        uniqueKey = this.options.uniqueKey;\n      } else {\n        uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, 'unique'].join('_');\n      }\n      targetAttribute.unique = sourceAttribute.unique = uniqueKey;\n    }\n\n    if (!this.through.model.rawAttributes[this.foreignKey]) {\n      this.through.model.rawAttributes[this.foreignKey] = {\n        _autoGenerated: true\n      };\n    }\n\n    if (!this.through.model.rawAttributes[this.otherKey]) {\n      this.through.model.rawAttributes[this.otherKey] = {\n        _autoGenerated: true\n      };\n    }\n\n    if (this.options.constraints !== false) {\n      sourceAttribute.references = {\n        model: this.source.getTableName(),\n        key: sourceKeyField\n      };\n      // For the source attribute the passed option is the priority\n      sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;\n      sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;\n\n      if (!sourceAttribute.onDelete) sourceAttribute.onDelete = 'CASCADE';\n      if (!sourceAttribute.onUpdate) sourceAttribute.onUpdate = 'CASCADE';\n\n      targetAttribute.references = {\n        model: this.target.getTableName(),\n        key: targetKeyField\n      };\n      // But the for target attribute the previously defined option is the priority (since it could've been set by another belongsToMany call)\n      targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;\n      targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;\n\n      if (!targetAttribute.onDelete) targetAttribute.onDelete = 'CASCADE';\n      if (!targetAttribute.onUpdate) targetAttribute.onUpdate = 'CASCADE';\n    }\n\n    Object.assign(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);\n    Object.assign(this.through.model.rawAttributes[this.otherKey], targetAttribute);\n\n    this.through.model.refreshAttributes();\n\n    this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;\n\n    // For Db2 server, a reference column of a FOREIGN KEY must be unique\n    // else, server throws SQL0573N error. Hence, setting it here explicitly\n    // for non primary columns.\n    if (this.options.sequelize.options.dialect === 'db2' &&\n        this.source.rawAttributes[this.sourceKey].primaryKey !== true) {\n      this.source.rawAttributes[this.sourceKey].unique = true;\n    }\n\n    if (this.paired && !this.paired.foreignIdentifierField) {\n      this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;\n    }\n\n    this.toSource = new BelongsTo(this.through.model, this.source, {\n      foreignKey: this.foreignKey\n    });\n    this.manyFromSource = new HasMany(this.source, this.through.model, {\n      foreignKey: this.foreignKey\n    });\n    this.oneFromSource = new HasOne(this.source, this.through.model, {\n      foreignKey: this.foreignKey,\n      sourceKey: this.sourceKey,\n      as: this.through.model.name\n    });\n\n    this.toTarget = new BelongsTo(this.through.model, this.target, {\n      foreignKey: this.otherKey\n    });\n    this.manyFromTarget = new HasMany(this.target, this.through.model, {\n      foreignKey: this.otherKey\n    });\n    this.oneFromTarget = new HasOne(this.target, this.through.model, {\n      foreignKey: this.otherKey,\n      sourceKey: this.targetKey,\n      as: this.through.model.name\n    });\n\n    if (this.paired && this.paired.otherKeyDefault) {\n      this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {\n        foreignKey: this.paired.otherKey\n      });\n\n      this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {\n        foreignKey: this.paired.otherKey,\n        sourceKey: this.paired.targetKey,\n        as: this.paired.through.model.name\n      });\n    }\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n    const aliases = {\n      hasSingle: 'has',\n      hasAll: 'has',\n      addMultiple: 'add',\n      removeMultiple: 'remove'\n    };\n\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n\n  /**\n   * Get everything currently associated with this, using an optional where clause.\n   *\n   * @see\n   * {@link Model} for a full explanation of options\n   *\n   * @param {Model} instance instance\n   * @param {object} [options] find options\n   * @param {object} [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {string} [options.schema] Apply a schema on the related model\n   * @param {object} [options.through.where] An optional where clause applied to through model (join table)\n   * @param {boolean} [options.through.paranoid=true] If true, only non-deleted records will be returned from the join table. If false, both deleted and non-deleted records will be returned. Only applies if through model is paranoid\n   *\n   * @returns {Promise<Array<Model>>}\n   */\n  async get(instance, options) {\n    options = Utils.cloneDeep(options) || {};\n\n    const through = this.through;\n    let scopeWhere;\n    let throughWhere;\n\n    if (this.scope) {\n      scopeWhere = { ...this.scope };\n    }\n\n    options.where = {\n      [Op.and]: [\n        scopeWhere,\n        options.where\n      ]\n    };\n\n    if (Object(through.model) === through.model) {\n      throughWhere = {};\n      throughWhere[this.foreignKey] = instance.get(this.sourceKey);\n\n      if (through.scope) {\n        Object.assign(throughWhere, through.scope);\n      }\n\n      //If a user pass a where on the options through options, make an \"and\" with the current throughWhere\n      if (options.through && options.through.where) {\n        throughWhere = {\n          [Op.and]: [throughWhere, options.through.where]\n        };\n      }\n\n      options.include = options.include || [];\n      options.include.push({\n        association: this.oneFromTarget,\n        attributes: options.joinTableAttributes,\n        required: true,\n        paranoid: _.get(options.through, 'paranoid', true),\n        where: throughWhere\n      });\n    }\n\n    let model = this.target;\n    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n      if (!options.scope) {\n        model = model.unscoped();\n      } else {\n        model = model.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n      model = model.schema(options.schema, options.schemaDelimiter);\n    }\n\n    return model.findAll(options);\n  }\n\n  /**\n   * Count everything currently associated with this, using an optional where clause.\n   *\n   * @param {Model} instance instance\n   * @param {object} [options] find options\n   * @param {object} [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   *\n   * @returns {Promise<number>}\n   */\n  async count(instance, options) {\n    const sequelize = this.target.sequelize;\n\n    options = Utils.cloneDeep(options);\n    options.attributes = [\n      [sequelize.fn('COUNT', sequelize.col([this.target.name, this.targetKeyField].join('.'))), 'count']\n    ];\n    options.joinTableAttributes = [];\n    options.raw = true;\n    options.plain = true;\n\n    const result = await this.get(instance, options);\n\n    return parseInt(result.count, 10);\n  }\n\n  /**\n   * Check if one or more instance(s) are associated with this. If a list of instances is passed, the function returns true if _all_ instances are associated\n   *\n   * @param {Model} sourceInstance source instance to check for an association with\n   * @param {Model|Model[]|string[]|string|number[]|number} [instances] Can be an array of instances or their primary keys\n   * @param {object} [options] Options passed to getAssociations\n   *\n   * @returns {Promise<boolean>}\n   */\n  async has(sourceInstance, instances, options) {\n    if (!Array.isArray(instances)) {\n      instances = [instances];\n    }\n\n    options = {\n      raw: true,\n      ...options,\n      scope: false,\n      attributes: [this.targetKey],\n      joinTableAttributes: []\n    };\n\n    const instancePrimaryKeys = instances.map(instance => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n      return {\n        [this.targetKey]: instance\n      };\n    });\n\n    options.where = {\n      [Op.and]: [\n        { [Op.or]: instancePrimaryKeys },\n        options.where\n      ]\n    };\n\n    const associatedObjects = await this.get(sourceInstance, options);\n\n    return _.differenceWith(instancePrimaryKeys, associatedObjects,\n      (a, b) => _.isEqual(a[this.targetKey], b[this.targetKey])).length === 0;\n  }\n\n  /**\n   * Set the associated models by passing an array of instances or their primary keys.\n   * Everything that it not in the passed array will be un-associated.\n   *\n   * @param {Model} sourceInstance source instance to associate new instances with\n   * @param {Model|Model[]|string[]|string|number[]|number} [newAssociatedObjects] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {object} [options] Options passed to `through.findAll`, `bulkCreate`, `update` and `destroy`\n   * @param {object} [options.validate] Run validation for the join model\n   * @param {object} [options.through] Additional attributes for the join table.\n   *\n   * @returns {Promise}\n   */\n  async set(sourceInstance, newAssociatedObjects, options) {\n    options = options || {};\n\n    const sourceKey = this.sourceKey;\n    const targetKey = this.targetKey;\n    const identifier = this.identifier;\n    const foreignIdentifier = this.foreignIdentifier;\n\n    if (newAssociatedObjects === null) {\n      newAssociatedObjects = [];\n    } else {\n      newAssociatedObjects = this.toInstanceArray(newAssociatedObjects);\n    }\n    const where = {\n      [identifier]: sourceInstance.get(sourceKey),\n      ...this.through.scope\n    };\n\n    const updateAssociations = currentRows => {\n      const obsoleteAssociations = [];\n      const promises = [];\n      const defaultAttributes = options.through || {};\n\n      const unassociatedObjects = newAssociatedObjects.filter(obj =>\n        !currentRows.some(currentRow => currentRow[foreignIdentifier] === obj.get(targetKey))\n      );\n\n      for (const currentRow of currentRows) {\n        const newObj = newAssociatedObjects.find(obj => currentRow[foreignIdentifier] === obj.get(targetKey));\n\n        if (!newObj) {\n          obsoleteAssociations.push(currentRow);\n        } else {\n          let throughAttributes = newObj[this.through.model.name];\n          // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n          if (throughAttributes instanceof this.through.model) {\n            throughAttributes = {};\n          }\n\n          const attributes = { ...defaultAttributes, ...throughAttributes };\n\n          if (Object.keys(attributes).length) {\n            promises.push(\n              this.through.model.update(attributes, Object.assign(options, {\n                where: {\n                  [identifier]: sourceInstance.get(sourceKey),\n                  [foreignIdentifier]: newObj.get(targetKey)\n                }\n              }\n              ))\n            );\n          }\n        }\n      }\n\n      if (obsoleteAssociations.length > 0) {\n        promises.push(\n          this.through.model.destroy({\n            ...options,\n            where: {\n              [identifier]: sourceInstance.get(sourceKey),\n              [foreignIdentifier]: obsoleteAssociations.map(obsoleteAssociation => obsoleteAssociation[foreignIdentifier]),\n              ...this.through.scope\n            }\n          })\n        );\n      }\n\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          return {\n            ...defaultAttributes,\n            ...unassociatedObject[this.through.model.name],\n            [identifier]: sourceInstance.get(sourceKey),\n            [foreignIdentifier]: unassociatedObject.get(targetKey),\n            ...this.through.scope\n          };\n        });\n\n        promises.push(this.through.model.bulkCreate(bulk, { validate: true, ...options }));\n      }\n\n      return Promise.all(promises);\n    };\n\n    try {\n      const currentRows = await this.through.model.findAll({ ...options, where, raw: true });\n      return await updateAssociations(currentRows);\n    } catch (error) {\n      if (error instanceof EmptyResultError) return updateAssociations([]);\n      throw error;\n    }\n  }\n\n  /**\n   * Associate one or several rows with source instance. It will not un-associate any already associated instance\n   * that may be missing from `newInstances`.\n   *\n   * @param {Model} sourceInstance source instance to associate new instances with\n   * @param {Model|Model[]|string[]|string|number[]|number} [newInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {object} [options] Options passed to `through.findAll`, `bulkCreate` and `update`\n   * @param {object} [options.validate] Run validation for the join model.\n   * @param {object} [options.through] Additional attributes for the join table.\n   *\n   * @returns {Promise}\n   */\n  async add(sourceInstance, newInstances, options) {\n    // If newInstances is null or undefined, no-op\n    if (!newInstances) return Promise.resolve();\n\n    options = { ...options };\n\n    const association = this;\n    const sourceKey = association.sourceKey;\n    const targetKey = association.targetKey;\n    const identifier = association.identifier;\n    const foreignIdentifier = association.foreignIdentifier;\n    const defaultAttributes = options.through || {};\n\n    newInstances = association.toInstanceArray(newInstances);\n\n    const where = {\n      [identifier]: sourceInstance.get(sourceKey),\n      [foreignIdentifier]: newInstances.map(newInstance => newInstance.get(targetKey)),\n      ...association.through.scope\n    };\n\n    const updateAssociations = currentRows => {\n      const promises = [];\n      const unassociatedObjects = [];\n      const changedAssociations = [];\n      for (const obj of newInstances) {\n        const existingAssociation = currentRows && currentRows.find(current => current[foreignIdentifier] === obj.get(targetKey));\n\n        if (!existingAssociation) {\n          unassociatedObjects.push(obj);\n        } else {\n          const throughAttributes = obj[association.through.model.name];\n          const attributes = { ...defaultAttributes, ...throughAttributes };\n\n          if (Object.keys(attributes).some(attribute => attributes[attribute] !== existingAssociation[attribute])) {\n            changedAssociations.push(obj);\n          }\n        }\n      }\n\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          const throughAttributes = unassociatedObject[association.through.model.name];\n          const attributes = { ...defaultAttributes, ...throughAttributes };\n\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n\n          Object.assign(attributes, association.through.scope);\n\n          return attributes;\n        });\n\n        promises.push(association.through.model.bulkCreate(bulk, { validate: true, ...options }));\n      }\n\n      for (const assoc of changedAssociations) {\n        let throughAttributes = assoc[association.through.model.name];\n        const attributes = { ...defaultAttributes, ...throughAttributes };\n        // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n        if (throughAttributes instanceof association.through.model) {\n          throughAttributes = {};\n        }\n\n        promises.push(association.through.model.update(attributes, Object.assign(options, { where: {\n          [identifier]: sourceInstance.get(sourceKey),\n          [foreignIdentifier]: assoc.get(targetKey)\n        } })));\n      }\n\n      return Promise.all(promises);\n    };\n\n    try {\n      const currentRows = await association.through.model.findAll({ ...options, where, raw: true });\n      const [associations] = await updateAssociations(currentRows);\n      return associations;\n    } catch (error) {\n      if (error instanceof EmptyResultError) return updateAssociations();\n      throw error;\n    }\n  }\n\n  /**\n   * Un-associate one or more instance(s).\n   *\n   * @param {Model} sourceInstance instance to un associate instances with\n   * @param {Model|Model[]|string|string[]|number|number[]} [oldAssociatedObjects] Can be an Instance or its primary key, or a mixed array of instances and primary keys\n   * @param {object} [options] Options passed to `through.destroy`\n   *\n   * @returns {Promise}\n   */\n  remove(sourceInstance, oldAssociatedObjects, options) {\n    const association = this;\n\n    options = options || {};\n\n    oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);\n\n    const where = {\n      [association.identifier]: sourceInstance.get(association.sourceKey),\n      [association.foreignIdentifier]: oldAssociatedObjects.map(newInstance => newInstance.get(association.targetKey))\n    };\n\n    return association.through.model.destroy({ ...options, where });\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Model} sourceInstance source instance\n   * @param {object} [values] values for target model\n   * @param {object} [options] Options passed to create and add\n   * @param {object} [options.through] Additional attributes for the join table\n   *\n   * @returns {Promise}\n   */\n  async create(sourceInstance, values, options) {\n    const association = this;\n\n    options = options || {};\n    values = values || {};\n\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n\n    if (association.scope) {\n      Object.assign(values, association.scope);\n      if (options.fields) {\n        options.fields = options.fields.concat(Object.keys(association.scope));\n      }\n    }\n\n    // Create the related model instance\n    const newAssociatedObject = await association.target.create(values, options);\n\n    await sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, ['fields']));\n    return newAssociatedObject;\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === 'string') {\n      return this.as === alias;\n    }\n\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n\n    return !this.isAliased;\n  }\n}\n\nmodule.exports = BelongsToMany;\nmodule.exports.BelongsToMany = BelongsToMany;\nmodule.exports.default = BelongsToMany;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}