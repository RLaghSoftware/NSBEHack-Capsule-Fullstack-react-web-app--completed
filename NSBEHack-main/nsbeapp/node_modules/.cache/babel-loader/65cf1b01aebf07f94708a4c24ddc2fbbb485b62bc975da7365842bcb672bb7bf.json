{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __markAsModule = target => __defProp(target, \"__esModule\", {\n  value: true\n});\nvar __export = (target, all) => {\n  __markAsModule(target);\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n__export(exports, {\n  OracleQueryInterface: () => OracleQueryInterface\n});\nconst {\n  QueryInterface\n} = require(\"../abstract/query-interface\");\nconst QueryTypes = require(\"../../query-types\");\nconst _ = require(\"lodash\");\nclass OracleQueryInterface extends QueryInterface {\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    const primaryKeys = Object.values(model.primaryKeys).map(item => item.field);\n    const uniqueKeys = Object.values(model.uniqueKeys).filter(c => c.fields.length > 0).map(c => c.fields);\n    const indexKeys = Object.values(model._indexes).filter(c => c.unique && c.fields.length > 0).map(c => c.fields);\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = [];\n    for (const field of options.updateOnDuplicate) {\n      const uniqueKey = uniqueKeys.find(fields => fields.includes(field));\n      if (uniqueKey) {\n        options.upsertKeys = uniqueKey;\n        break;\n      }\n      const indexKey = indexKeys.find(fields => fields.includes(field));\n      if (indexKey) {\n        options.upsertKeys = indexKey;\n        break;\n      }\n    }\n    if (options.upsertKeys.length === 0 || _.intersection(options.updateOnDuplicate, primaryKeys).length) {\n      options.upsertKeys = primaryKeys;\n    }\n    options.upsertKeys = _.uniq(options.upsertKeys);\n    let whereHasNull = false;\n    primaryKeys.forEach(element => {\n      if (where[element] === null) {\n        whereHasNull = true;\n      }\n    });\n    if (whereHasNull === true) {\n      where = options.upsertKeys.reduce((result, attribute) => {\n        result[attribute] = insertValues[attribute];\n        return result;\n      }, {});\n    }\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    if (sql.bind) {\n      options.bind = void 0;\n    }\n    return await this.sequelize.query(sql, options);\n  }\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAAA;EAAAC;AAAA;AAGA,MAAM;EAAEC;AAAA,IAAmBC,QAAQ;AACnC,MAAMC,aAAaD,QAAQ;AAE3B,MAAME,IAAIF,QAAQ;AAIX,mCAAmCD,eAAe;EAAA,MAajDI,OAAOC,WAAWC,cAAcC,cAAcC,OAAOC,SAAS;IAClEA,UAAUC,mBAAKD;IAEf,MAAME,QAAQF,QAAQE;IACtB,MAAMC,cAAcC,OAAOC,OAAOH,MAAMC,aAAaG,IAAIC,QAAQA,KAAKC;IACtE,MAAMC,aAAaL,OAAOC,OAAOH,MAAMO,YAAYC,OAAOC,KAAKA,EAAEC,OAAOC,SAAS,GAAGP,IAAIK,KAAKA,EAAEC;IAC/F,MAAME,YAAYV,OAAOC,OAAOH,MAAMa,UAAUL,OAAOC,KAAKA,EAAEK,UAAUL,EAAEC,OAAOC,SAAS,GAAGP,IAAIK,KAAKA,EAAEC;IAExGZ,QAAQiB,OAAOxB,WAAWyB;IAC1BlB,QAAQmB,oBAAoBf,OAAOgB,KAAKtB;IACxCE,QAAQqB,aAAa;IAIrB,WAAWb,SAASR,QAAQmB,mBAAmB;MAC7C,MAAMG,YAAYb,WAAWc,KAAKX,UAAUA,OAAOY,SAAShB;MAC5D,IAAIc,WAAW;QACbtB,QAAQqB,aAAaC;QACrB;MAAA;MAGF,MAAMG,WAAWX,UAAUS,KAAKX,UAAUA,OAAOY,SAAShB;MAC1D,IAAIiB,UAAU;QACZzB,QAAQqB,aAAaI;QACrB;MAAA;IAAA;IAKJ,IACEzB,QAAQqB,WAAWR,WAAW,KAC3BnB,EAAEgC,aAAa1B,QAAQmB,mBAAmBhB,aAAaU,QAC1D;MACAb,QAAQqB,aAAalB;IAAA;IAGvBH,QAAQqB,aAAa3B,EAAEiC,KAAK3B,QAAQqB;IAEpC,IAAIO,eAAe;IAEnBzB,YAAY0B,QAAQC,WAAW;MAC7B,IAAI/B,MAAM+B,aAAa,MAAM;QAC3BF,eAAe;MAAA;IAAA;IAInB,IAAIA,iBAAiB,MAAM;MACzB7B,QAAQC,QAAQqB,WAAWU,OAAO,CAACC,QAAQC,cAAc;QACvDD,OAAOC,aAAapC,aAAaoC;QACjC,OAAOD;MAAA,GACN;IAAA;IAGL,MAAME,MAAM,KAAKC,eAAeC,YAAYxC,WAAWC,cAAcC,cAAcC,OAAOG,OAAOF;IAGjG,IAAIkC,IAAIG,MAAM;MACZrC,QAAQqC,OAAO;IAAA;IAEjB,OAAO,MAAM,KAAKC,UAAUC,MAAML,KAAKlC;EAAA;AAAA","names":["__export","OracleQueryInterface","QueryInterface","require","QueryTypes","_","upsert","tableName","insertValues","updateValues","where","options","__spreadValues","model","primaryKeys","Object","values","map","item","field","uniqueKeys","filter","c","fields","length","indexKeys","_indexes","unique","type","UPSERT","updateOnDuplicate","keys","upsertKeys","uniqueKey","find","includes","indexKey","intersection","uniq","whereHasNull","forEach","element","reduce","result","attribute","sql","queryGenerator","upsertQuery","bind","sequelize","query"],"sources":["C:\\Users\\rizla\\projects\\react\\NSBEHack-main\\nsbeapp\\node_modules\\sequelize\\src\\dialects\\oracle\\query-interface.js"],"sourcesContent":["// Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved\n\n'use strict';\nconst { QueryInterface } = require('../abstract/query-interface');\nconst QueryTypes = require('../../query-types');\n\nconst _ = require('lodash');\n/**\n * The interface that Sequelize uses to talk with Oracle database\n */\nexport class OracleQueryInterface extends QueryInterface {\n\n  /**\n   * Upsert\n   *\n   * @param {string} tableName    table to upsert on\n   * @param {object} insertValues values to be inserted, mapped to field name\n   * @param {object} updateValues values to be updated, mapped to field name\n   * @param {object} where        where conditions, which can be used for UPDATE part when INSERT fails\n   * @param {object} options      query options\n   *\n   * @returns {Promise<boolean,?number>} Resolves an array with <created, primaryKey>\n   */\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = { ...options };\n\n    const model = options.model;\n    const primaryKeys = Object.values(model.primaryKeys).map(item => item.field);\n    const uniqueKeys = Object.values(model.uniqueKeys).filter(c => c.fields.length > 0).map(c => c.fields);\n    const indexKeys = Object.values(model._indexes).filter(c => c.unique && c.fields.length > 0).map(c => c.fields);\n\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = [];\n\n    // For fields in updateValues, try to find a constraint or unique index\n    // that includes given field. Only first matching upsert key is used.\n    for (const field of options.updateOnDuplicate) {\n      const uniqueKey = uniqueKeys.find(fields => fields.includes(field));\n      if (uniqueKey) {\n        options.upsertKeys = uniqueKey;\n        break;\n      }\n\n      const indexKey = indexKeys.find(fields => fields.includes(field));\n      if (indexKey) {\n        options.upsertKeys = indexKey;\n        break;\n      }\n    }\n\n    // Always use PK, if no constraint available OR update data contains PK\n    if (\n      options.upsertKeys.length === 0\n      || _.intersection(options.updateOnDuplicate, primaryKeys).length\n    ) {\n      options.upsertKeys = primaryKeys;\n    }\n\n    options.upsertKeys = _.uniq(options.upsertKeys);\n\n    let whereHasNull = false;\n\n    primaryKeys.forEach(element => {\n      if (where[element] === null) {\n        whereHasNull = true;\n      }\n    });\n\n    if (whereHasNull === true) {\n      where = options.upsertKeys.reduce((result, attribute) => {\n        result[attribute] = insertValues[attribute];\n        return result;\n      }, {}); \n    }\n\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    // we need set this to undefined otherwise sequelize would raise an error\n    // Error: Both `sql.bind` and `options.bind` cannot be set at the same time\n    if (sql.bind) {\n      options.bind = undefined;\n    }\n    return await this.sequelize.query(sql, options);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}