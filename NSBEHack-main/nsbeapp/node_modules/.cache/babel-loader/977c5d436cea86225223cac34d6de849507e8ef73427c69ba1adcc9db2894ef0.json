{"ast":null,"code":"\"use strict\";\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst _ = require(\"lodash\");\nconst Utils = require(\"../../utils\");\nconst Op = require(\"../../operators\");\nconst {\n  QueryInterface\n} = require(\"../abstract/query-interface\");\nconst QueryTypes = require(\"../../query-types\");\nclass Db2QueryInterface extends QueryInterface {\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = __spreadProps(__spreadValues({}, options), {\n      type: QueryTypes.FOREIGNKEYS\n    });\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.username.toUpperCase());\n    return this.sequelize.query(query, queryOptions);\n  }\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = __spreadValues({}, options);\n    const model = options.model;\n    const wheres = [];\n    const attributes = Object.keys(insertValues);\n    let indexes = [];\n    let indexFields;\n    options = _.clone(options);\n    if (!Utils.isWhereEmpty(where)) {\n      wheres.push(where);\n    }\n    indexes = _.map(model.uniqueKeys, value => {\n      return value.fields;\n    });\n    model._indexes.forEach(value => {\n      if (value.unique) {\n        indexFields = value.fields.map(field => {\n          if (_.isPlainObject(field)) {\n            return field.attribute;\n          }\n          return field;\n        });\n        indexes.push(indexFields);\n      }\n    });\n    for (const index of indexes) {\n      if (_.intersection(attributes, index).length === index.length) {\n        where = {};\n        for (const field of index) {\n          where[field] = insertValues[field];\n        }\n        wheres.push(where);\n      }\n    }\n    where = {\n      [Op.or]: wheres\n    };\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    const result = await this.sequelize.query(sql, options);\n    return [result, void 0];\n  }\n  async createTable(tableName, attributes, options, model) {\n    let sql = \"\";\n    options = __spreadValues({}, options);\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, uniqueKey => {\n        if (uniqueKey.customIndex === void 0) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n    attributes = _.mapValues(attributes, attribute => this.sequelize.normalizeAttribute(attribute));\n    if (options.indexes) {\n      options.indexes.forEach(fields => {\n        const fieldArr = fields.fields;\n        if (fieldArr.length === 1) {\n          fieldArr.forEach(field => {\n            for (const property in attributes) {\n              if (field === attributes[property].field) {\n                attributes[property].unique = true;\n              }\n            }\n          });\n        }\n      });\n    }\n    if (options.alter) {\n      if (options.indexes) {\n        options.indexes.forEach(fields => {\n          const fieldArr = fields.fields;\n          if (fieldArr.length === 1) {\n            fieldArr.forEach(field => {\n              for (const property in attributes) {\n                if (field === attributes[property].field && attributes[property].unique) {\n                  attributes[property].unique = false;\n                }\n              }\n            });\n          }\n        });\n      }\n    }\n    if (!tableName.schema && (options.schema || !!model && model._schema)) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n    attributes = this.queryGenerator.attributesToSQL(attributes, {\n      table: tableName,\n      context: \"createTable\",\n      withoutForeignKeyConstraints: options.withoutForeignKeyConstraints\n    });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n}\nexports.Db2QueryInterface = Db2QueryInterface;","map":{"version":3,"mappings":"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","names":["_","require","Utils","Op","QueryInterface","QueryTypes","getForeignKeyReferencesForTable","tableName","options","queryOptions","__spreadProps","type","FOREIGNKEYS","query","queryGenerator","getForeignKeysQuery","sequelize","config","username","toUpperCase","upsert","insertValues","updateValues","where","__spreadValues","model","wheres","attributes","Object","keys","indexes","indexFields","clone","isWhereEmpty","push","map","uniqueKeys","value","fields","_indexes","forEach","unique","field","isPlainObject","attribute","index","intersection","length","or","UPSERT","raw","sql","upsertQuery","result","createTable","forOwn","uniqueKey","customIndex","mapValues","normalizeAttribute","fieldArr","property","alter","schema","_schema","addSchema","attributesToSQL","table","context","withoutForeignKeyConstraints","createTableQuery","exports","Db2QueryInterface"],"sources":["C:\\Users\\rizla\\projects\\react\\NSBEHack-main\\nsbeapp\\node_modules\\sequelize\\src\\dialects\\db2\\query-interface.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst Op = require('../../operators');\nconst { QueryInterface } = require('../abstract/query-interface');\nconst QueryTypes = require('../../query-types');\n\n/**\n * The interface that Sequelize uses to talk with Db2 database\n */\nclass Db2QueryInterface extends QueryInterface {\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = {\n      ...options,\n      type: QueryTypes.FOREIGNKEYS\n    };\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.username.toUpperCase());\n    return this.sequelize.query(query, queryOptions);\n  }\n\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = { ...options };\n\n    const model = options.model;\n    const wheres = [];\n    const attributes = Object.keys(insertValues);\n    let indexes = [];\n    let indexFields;\n\n    options = _.clone(options);\n\n    if (!Utils.isWhereEmpty(where)) {\n      wheres.push(where);\n    }\n\n    // Lets combine unique keys and indexes into one\n    indexes = _.map(model.uniqueKeys, value => {\n      return value.fields;\n    });\n\n    model._indexes.forEach(value => {\n      if (value.unique) {\n        // fields in the index may both the strings or objects with an attribute property - lets sanitize that\n        indexFields = value.fields.map(field => {\n          if (_.isPlainObject(field)) {\n            return field.attribute;\n          }\n          return field;\n        });\n        indexes.push(indexFields);\n      }\n    });\n\n    for (const index of indexes) {\n      if (_.intersection(attributes, index).length === index.length) {\n        where = {};\n        for (const field of index) {\n          where[field] = insertValues[field];\n        }\n        wheres.push(where);\n      }\n    }\n\n    where = { [Op.or]: wheres };\n\n    options.type = QueryTypes.UPSERT;\n    options.raw = true;\n\n    const sql = this.queryGenerator.upsertQuery(tableName, insertValues, updateValues, where, model, options);\n    const result = await this.sequelize.query(sql, options);\n    return [result, undefined];\n  }\n\n  async createTable(tableName, attributes, options, model) {\n    let sql = '';\n\n    options = { ...options };\n\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, uniqueKey => {\n        if (uniqueKey.customIndex === undefined) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n    attributes = _.mapValues(\n      attributes,\n      attribute => this.sequelize.normalizeAttribute(attribute)\n    );  \n    if (options.indexes) {\n      options.indexes.forEach(fields=>{\n        const fieldArr = fields.fields;\n        if (fieldArr.length === 1) {\n          fieldArr.forEach(field=>{       \n            for (const property in attributes) {\n              if (field === attributes[property].field) {\n                attributes[property].unique = true;\n              }\n            }\n          });\n        }\n      });\n    }\n    if (options.alter) {\n      if (options.indexes) {\n        options.indexes.forEach(fields=>{\n          const fieldArr = fields.fields;\n          if (fieldArr.length === 1) {\n            fieldArr.forEach(field=>{       \n              for (const property in attributes) {\n                if (field === attributes[property].field && attributes[property].unique) {\n                  attributes[property].unique = false;\n                }\n              }\n            });\n          }\n        });\n      }\n    }\n\n    if (\n      !tableName.schema &&\n      (options.schema || !!model && model._schema)\n    ) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n\n    attributes = this.queryGenerator.attributesToSQL(attributes, { table: tableName, context: 'createTable', withoutForeignKeyConstraints: options.withoutForeignKeyConstraints });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n\n    return await this.sequelize.query(sql, options);\n  }\n\n}\n\nexports.Db2QueryInterface = Db2QueryInterface;\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}